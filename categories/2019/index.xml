<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>2019 on std::bodun::blog</title><link>https://www.bodunhu.com/blog/categories/2019/</link><description>Recent content in 2019 on std::bodun::blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 17 Sep 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://www.bodunhu.com/blog/categories/2019/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding Probabilistic Clock Synchronization</title><link>https://www.bodunhu.com/blog/posts/understanding-probabilistic-clock-synchronization/</link><pubDate>Tue, 17 Sep 2019 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/understanding-probabilistic-clock-synchronization/</guid><description>This post is meant to discuss the probabilistic clock synchronization technique. The main goal of this technique is to bound the difference between systems by setting up an upper bound. Formally, we define the problem as \(|P(t)-Q(t)|\leq \varepsilon\), or the difference between clocks across the network. We will go over the technical detains and discuss what these symbols represent in later sections. Most of these materials are from Prof. Mok &amp;rsquo;s slides on his dependable systems classes.</description></item><item><title>How to Put Papers on ArXiv</title><link>https://www.bodunhu.com/blog/posts/how-to-put-papers-on-arxiv/</link><pubDate>Tue, 25 Jun 2019 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/how-to-put-papers-on-arxiv/</guid><description>I was recently trying to put my research paper draft on ArXiv. I thought it would be as simple as submitting the pdf file, which should take approximately less than ten minutes. I was wrong. It took several hours to figure what was going on. I included some tips here to prevent mistakes I made from happening again</description></item><item><title>A Little Review on Barrelfish Memory Management</title><link>https://www.bodunhu.com/blog/posts/a-little-review-on-barrelfish-memory-management/</link><pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/a-little-review-on-barrelfish-memory-management/</guid><description>The memory management has been mentioned numerous times and still remains huge topic. virtual vs. physical memory, physical frame allocation, MMUs, page faults, address space layout, and demand paging and swapping are familiar terms for every undergrad in college. In monolithic kernels such as Linux, much of the functionality is handled in kernel. However, there are OSes, such as Barrelfish, that takes a different approach by pushing these functionalities to user space.</description></item><item><title>Pascal GPU memory and cache hierarchy</title><link>https://www.bodunhu.com/blog/posts/pascal-gpu-memory-and-cache-hierarchy/</link><pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/pascal-gpu-memory-and-cache-hierarchy/</guid><description>Memory access efﬁciency is an important factor in fully utilizing the computational power of graphics processing units (GPUs). However, many GPU vendors like NVIDIA kept the GPU memory hierarchy as a secret. Therefore it becomes hard to measure GPUs performance and sets barriers to understand memory access patterns, which is a key component to improve program&amp;rsquo;s performance. Here we introduce a novel fine-grained microbenchmark approach and apply to the Pascal generation. Turing architecture might have different results, but the method we used here can be applied as well with slight modification. The method we use in this guide is inspired by the research paper: &lt;a
href="https://ieeexplore.ieee.org/document/7445236"
target="_blank"
rel="noopener"
>
Dissecting GPU Memory Hierarchy through Microbenchmarking
&lt;/a>. Here we will explain how P-Chase works and walk through a small example</description></item></channel></rss>