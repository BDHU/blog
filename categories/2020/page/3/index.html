<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2020 | std::bodun::blog</title><meta name=keywords content><meta name=description content="Personal Blog for Bodun Hu. Longhorn at UT Austin"><meta name=author content><link rel=canonical href=https://www.bodunhu.com/blog/categories/2020/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/blog/assets/css/stylesheet.min.758151a3f029732139c5ed917da59127bed78e4d7fce57610c1cd24d4cb52b2a.css integrity="sha256-dYFRo/ApcyE5xe2RfaWRJ77Xjk1/zldhDBzSTUy1Kyo=" rel="preload stylesheet" as=style><link rel=icon href=https://www.cs.utexas.edu/sites/default/files/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.utexas.edu/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.utexas.edu/favicon-32x32.png><link rel=apple-touch-icon href=https://www.utexas.edu/apple-touch-icon.png><link rel=mask-icon href=https://www.cs.utexas.edu/sites/default/files/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><link rel=alternate type=application/rss+xml href=https://www.bodunhu.com/blog/categories/2020/index.xml><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="2020"><meta property="og:description" content="Personal Blog for Bodun Hu. Longhorn at UT Austin"><meta property="og:type" content="website"><meta property="og:url" content="https://www.bodunhu.com/blog/categories/2020/"><meta property="og:image" content="https://www.bodunhu.com/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="Bodun's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.bodunhu.com/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="2020"><meta name=twitter:description content="Personal Blog for Bodun Hu. Longhorn at UT Austin"><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://www.bodunhu.com/blog/ accesskey=h title="std::bodun::blog (Alt + H)">std::bodun::blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.bodunhu.com/blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.bodunhu.com/blog/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://www.bodunhu.com/blog/about/ title=About><span>About</span></a></li><li><a href=https://www.bodunhu.com/blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://www.bodunhu.com/blog/>Home</a>&nbsp;»&nbsp;<a href=https://www.bodunhu.com/blog/categories/>Categories</a></div><h1>2020</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2><a href=https://www.bodunhu.com/blog/posts/monad/>Monads in Haskell</a></h2></header><footer class=entry-footer>March 1, 2020&nbsp;·&nbsp;4 min</footer><section class=entry-content><p><p>I&rsquo;ve scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads. I take William Cook&rsquo;s <a href=http://www.cs.utexas.edu/~wcook/anatomy/anatomy.htm>Anatomy of Programming Languages</a> as my reference.</p><h2 id=definitions-of-monads>Definitions of Monads</h2><p>A monad is defined as a computational structure that involves three parts:</p><ul><li>A generic data type \(m\)</li><li>A <em>return</em> function \(return_m\) :: \(t\rightarrow mt\)</li><li>A <em>bind</em> function \(\triangleright_mt\rightarrow (t\rightarrow ms)\rightarrow ms\)</li></ul><p>Here the symbol \(m\) gives the name of the monad as well as the shape of the computation. We can call the program that uses the monad \(m\) as an m-computation. The instantiation of the generic type \(mt\) at a particular type \(t\) represents n m-computation that produces a value of type \(t\). The \(m\)-computation indicates that in addition to value \(t\), some additional requirements or effects will take place. This is the essence of monads.</p><p>The definition of the <code>return</code> function states that how values are converted into m-computations. The <code>return</code> will just return the value of type \(t\). For example, if we pass in a stateful memory information, <code>return</code> shouldn&rsquo;t modify the actual but only provide a context to which the value lies in. The reason we convert value into m-computation is that if any error occur then <code>return</code> will catch the error without adding additional error checking codes.</p><p>The bind function \(\triangleright_m\) specifies how computations are combined together. THe general idea is that the computation behavior of \(A\triangleright_m F\) indicates the m-computation \(A\) is performed first, the value it produces wil be passed to the function \(F\) to create a second m-computation. Because \(A\) is a m-computation, if an error happens, the computation will stop and \(F\) will not be performed.</p><h2 id=monads-in-haskell>Monads in Haskell</h2><p>In Haskell, we can use Monads using type class. A type class is defined as:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>Monad</span> m <span style=color:#66d9ef>where</span>
  (<span style=color:#f92672>&gt;&gt;=</span>) <span style=color:#f92672>::</span> m t <span style=color:#f92672>-&gt;</span> (t <span style=color:#f92672>-&gt;</span> m s) <span style=color:#f92672>-&gt;</span> m s
  return <span style=color:#f92672>::</span> t <span style=color:#f92672>-&gt;</span> m t
</code></pre></div><p>For a object of generic type \(m\) to be a Monad, it must have those two functions defined. A type class allows us to overload functions according to their type.</p><p>So why do we need Monads in the first place? If we are given a function \(func1\) which takes in an Int value and produces an Int output, we could link the function together to form a chain of computation. If we make a function like this:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>func1</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>) <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>) 
<span style=color:#a6e22e>x</span> <span style=color:#f92672>&amp;</span> func1 <span style=color:#f92672>=</span> func1 x
</code></pre></div><p>we could use the output of the function as the input to the same function to produce another value. This process can be repeated and thus form a chain of operation:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&amp;</span> func1 <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;</span> func1 <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;</span> func1 <span style=color:#ae81ff>3</span> <span style=color:#f92672>...</span>
</code></pre></div><p>However, the function \(func1\) could potentially return a Nothing if the given input doesn&rsquo;t meet certain standards (exp. devide by 0). Therefore, \(func1\) can modified to:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>func1</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> (<span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>)
</code></pre></div><p>The previous definition of \(func1\) says \(func1\) takes a (Int, Int) tuple as one input, but now if we feed the output of \(func1\) directly to the next \(func1\) in the chain, error would occur because \(func1\) takes a raw (Int, Int) tuple as the input, but now we have (Int, Int) wrapped in a Maybe context. The & operator is not able to pass the argument with a context to the next func1. Fortunately, we have the bind operator defined.</p><p>If we look at the definition of the <strong>&#187;=</strong> in Monad definition, we see:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>(<span style=color:#f92672>&gt;&gt;=</span>) <span style=color:#f92672>::</span> m t <span style=color:#f92672>-&gt;</span> (t <span style=color:#f92672>-&gt;</span> m s) <span style=color:#f92672>-&gt;</span> m s
</code></pre></div><p>This means <strong>&#187;=</strong> is able to take a value within certain context and map a function that takes the raw value as input to the it. We can simply switch the <strong>&</strong> operator to <strong>&#187;=</strong> such that the chaining would still work:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>return</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&gt;&gt;=</span> func1 <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;&gt;=</span> func1 <span style=color:#ae81ff>2</span> <span style=color:#f92672>&gt;&gt;=</span> func1 <span style=color:#ae81ff>3</span> <span style=color:#f92672>...</span>
</code></pre></div><p>If an error occurred in one part of the chain (let&rsquo;s assume one computation yields Nothing). Then the Nothing value will be propagated to the next function, whill will automatically generate an error, or Nothing. Otherwise we would have written error checking code at the end of each single computation to check their output.</p><p>In short, <strong>&#187;=</strong> is just a way to chain functions with parametric polymorphism together.</p><h2 id=haskell-do-notation>Haskell <em>do</em> Notation</h2><p>Using the do notation can simply the use of bind operator. The basic pattern of do notation is:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#66d9ef>do</span>
  x <span style=color:#f92672>&lt;-</span> e1
  e2
</code></pre></div><p>which is equivalent to:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>e1</span> <span style=color:#f92672>&gt;&gt;=</span> (<span style=color:#a6e22e>\</span>lambda x<span style=color:#f92672>.</span>e2)
</code></pre></div><p>The <strong>&lt;-</strong> notation simply indicates \(x\) is bind to the value the computation generates. In other words, \(x\) doesn&rsquo;t lie in a context. if \(e1\) returns Nothing, \(x\) is not bind to anything. It&rsquo;s important to remember that do expressions are just different syntax for chaining monadic values.</p><p>For a more detailed explaination of Monads, I found <a href=http://learnyouahaskell.com/a-fistful-of-monads>A Fistful of Monads</a> to be extremely helpful in terms of clarifying the concept.</p></p></section></article><article class="post-entry tag-entry"><header class=entry-header><h2><a href=https://www.bodunhu.com/blog/posts/svd/>Singular Value Decomposition</a></h2></header><footer class=entry-footer>February 10, 2020&nbsp;·&nbsp;2 min</footer><section class=entry-content><p><p>Unitary matrices and the Singular Value Decomposition (SVD) are two important concepts in linear algebra. In order to fully understand these concepts, we will need to first discuss orthogonality. Most materials are convered in Advanced Linear Algebra: Foundations to Frontiers taught by professor <a href=https://www.cs.utexas.edu/~rvdg/>Robert van de Geijn</a>. This is a brief summary over the important concepts covered in Chapter 2.</p><h2 id=components-in-the-direction-of-a-vector>Components in the direction of a vector</h2><p>By Pythagorean theorem, we know that \(b = \chi a + c\) where \(a\) is a unit vector orthogonal to \(c\) and \(\chi\) is a scaler. Then we have</p><p>$$a^T (b-\chi a) = 0$$</p><p>Solving it gives us \(\chi = \frac{a^T b}{a^T a}\). We have \(\frac{a^T b}{a^T a}a = \frac{a a^T}{a^T a}b\). And \(\frac{a a^T}{a^T a}\) can map vector \(b\) in the direction of \(a\). The orthogonal component of \(a\) can thus be calculated as \(I-\frac{a a^T}{a^T a}\).</p><p>The linear transformation can be simplified by letting \(\left\lVert a\right\rVert_{2}=1\) because this will render \(a^T a = 1\).</p><h2 id=unitary-matrix>Unitary Matrix</h2><p>A matrix \(U\) is said to unitary matrix is if \(U\) is a square matrix and satifies \(U^H U= I\).</p><p>In addition, unitary matrix has some nice properties. First, the product of a sequence of unitary matrix is also unitary matrix. This can be proven by first explore the product of \((U_0 U_1)^H (U_0 U_1)= I\), showing \(U_0 U_1\) is a unitary matrix, and then perform induction.</p><p>Unitary matrix also preserves <strong>length</strong>. This is done by showing \(\left\lVert Ux \right\rVert _2^2 = (Ux)^H (Ux) = x^H x= \left\lVert x \right\rVert _2^2\).</p><h2 id=change-of-orthonormal-basis>Change of orthonormal basis</h2><p>We mentioned we can map a vector \(x\) another vector in the same direction as vector \(a\). Now we extend it to express a vector \(x\) using a set of orthonormal basis \(U\).</p><p>We know that \(x = Ix= UU^Tx=U(U^Tx)=u_0^Hxu_0+&mldr;+u_{m-1}^Hxu_{m-1}\). We notice that \(u_0^Hx\) is a scalor so we can write then equation as \(U(U^Tx)=a_0u_0+&mldr;+a_{m-1}u_{m-1}\). We successfully expressed the vector \(x\) based on the orthonormal basis.</p><h2 id=todo>TODO</h2></p></section></article><footer class=page-footer><nav class=pagination><a class=prev href=https://www.bodunhu.com/blog/categories/2020/page/2/>« Prev Page</a></nav></footer></main><footer class=footer><span>&copy; 2021 <a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>