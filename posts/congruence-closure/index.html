<!doctype html><html lang=en-us><head><meta http-equiv=x-clacks-overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Congruence Closure | std::bodun::blog</title><meta name=title content="Congruence Closure"><meta name=description content="This is a summary of how to compute congruence closure. I implemented the algorithm to compute congruence closure and thought I'd never forget it. But my memory starts to get blurry just after two days. So I figured I'd put things down so I don't have to watch the entire lecture again the next time I need it"><meta name=keywords content="algorithm,theory,PL,"><meta property="og:title" content="Congruence Closure"><meta property="og:description" content="This is a summary of how to compute congruence closure. I implemented the algorithm to compute congruence closure and thought I'd never forget it. But my memory starts to get blurry just after two days. So I figured I'd put things down so I don't have to watch the entire lecture again the next time I need it"><meta property="og:type" content="article"><meta property="og:url" content="https://www.bodunhu.com/blog/posts/congruence-closure/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-14T18:31:56-06:00"><meta property="og:site_name" content="std::bodun::blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Congruence Closure"><meta name=twitter:description content="This is a summary of how to compute congruence closure. I implemented the algorithm to compute congruence closure and thought I'd never forget it. But my memory starts to get blurry just after two days. So I figured I'd put things down so I don't have to watch the entire lecture again the next time I need it"><meta name=twitter:site content="@https://twitter.com/BodunHu"><meta itemprop=name content="Congruence Closure"><meta itemprop=description content="This is a summary of how to compute congruence closure. I implemented the algorithm to compute congruence closure and thought I'd never forget it. But my memory starts to get blurry just after two days. So I figured I'd put things down so I don't have to watch the entire lecture again the next time I need it"><meta itemprop=datePublished content="2021-03-27T00:00:00+00:00"><meta itemprop=dateModified content="2022-02-14T18:31:56-06:00"><meta itemprop=wordCount content="643"><meta itemprop=keywords content="algorithm,theory,PL,"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style></head><body><header><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><a href=/blog/ class=title><h2>std::bodun::blog</h2></a><nav><a href=/blog/>Home</a>
<a href=/blog/posts/>Archive</a>
<a href=https://www.bodunhu.com/>About</a></nav></header><main><h1>Congruence Closure</h1><p><i><time datetime=2021-03-27 pubdate>27 Mar, 2021</time></i></p><content><p>This is a summary of how to compute congruence closure. I implemented the algorithm to compute congruence closure and thought I&rsquo;d never forget it. But my memory starts to get blurry just after two days. So I figured I&rsquo;d put things down so I don&rsquo;t have to watch the entire lecture again the next time I need it.</p><h2 id=equivalence-relation>Equivalence Relation</h2><p>Equivalence relation has three properties: reflexive, symmetric, and transitive.
(E.g. \(\geq\) is not an equivalence relation because it break the symmetric property. \(4 \geq 6\) does not imply that \(6 \geq 4\).
For example, a binary relation $R$ over a set $S$ meeting these three properties can be expressed as:</p><ul><li>Reflexive: $\forall s \in S.\ sRs$</li><li>Symmetric : $\forall s_1, s_2 \in S.\ s_1 R s_2 \rightarrow s_2 R s_1$</li><li>Transitive: $\forall s_1, s_2, s_3 \in S.\ s_1 R s_2 \land s_2 R s_3 \rightarrow s_1 Rs_3$</li></ul><h2 id=congruence-relation>Congruence Relation</h2><p>Given a set $S$ equipped with functions $F = {f_1, &mldr;, f_n}$, a relation $R$ over $S$ is a congruence relation if $R$ is an equivalence relation and for every $n$&lsquo;ary function $f \in F$ we have:</p><p>\[\forall \overset{\rightarrow}{s}, \overset{\rightarrow}{t}.\ \bigwedge\limits_{i=1}^{n}s_i R t_i \rightarrow f(\overset{\rightarrow}{s}) R f(\overset{\rightarrow}{t})\]</p><p>A counter example would be given $R(x, y)$ defined as $|x| = |y|$ on all integers. If we have $R = {2, 2}$ and $f(x) = x + 1$ (successor function), then we know it violates the equivalence relation we mentioned above</p><h2 id=equivalence-closure>Equivalence Closure</h2><p>In short, the equivalence closure $R^E$ is the smallest equivalence relation that includes $R$.
This is illustrated through an example. Given a set $S = {a, b, c}$ and binary relation $R:{\langle a, b \rangle , \langle b, c \rangle, \langle d, d \rangle}$, $R^E$ would contain all elements extended from $R$ based on the three properties of equivalence relation.</p><h2 id=congruence-closure>Congruence Closure</h2><p>Naturally, congruence closure $R^C$ would be the smallest set that contains congruence relation $R$. What this means is $R^C$ contains $R^E$ (the equivlance closure we derived before), and any element generated from $R^E$ by a given function that produces element which also satisfies equivelance relation. For example, Given $S = {a, b, c}$ and function $f$ such that $f(a) = b$, $f(b) = c$, $f(c) = c$, the congruence closure would contain nine elments in total. First, we
would use the procedure above to generated equivalence closure. Then, because $f(a) = b$ and $f(b) = c$ due to congruence relation, we know $b = c$, now we apply the procure for generating equivalence closure again.</p><h2 id=algorithm-to-compute-congruence-closure>Algorithm to Compute Congruence Closure</h2><p>The high-level description of the algorithm is as following:</p><p>To decide satisfiability of $T_{=}$ (equality theory) formula:</p><p>\[F\ : \ s_1 = t_1 \land &mldr; s_m = t_m \land s_{m+1} \neq t_{m+1} \land &mldr; s_n \neq t_n\]</p><ol><li>Compute subterms and construct initial DAG (each node’s representative is itself)</li><li>For each $i \in [1,m]$, process equality $s_i= t_i$ as described. (Essentially, process all equiv expression first)</li><li>For each $i \in [m + 1,n]$, check if $Rep(s_i) =Rep(t_i)$. (Check if any nequiv expression contradicts any equiv expression)</li><li>If there exists some $i \in [m + 1, n]$, for which $Rep(s_i) =Rep(t_i)$, return UNSAT</li><li>if for all $i$, $Rep(s_i) \neq Rep(t_i)$, return SAT</li></ol><p>This is an example for illustration purposes, borrowed from Prof. <a href=https://www.cs.utexas.edu/~isil/>Dillig</a>&rsquo;s slides:</p><p>Given formula $F\ : \ f^3(a) = a \land f^5(a) = a \land f(a) \neq a$</p><p>The initial DAG would be:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/congruence_algorithm/DAG.png#center alt=congruence-closure-DAG></p><p>Process equality $f^3(a) = a$ gives us:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/congruence_algorithm/DAG_1.png#center alt=congruence-closure-DAG-2></p><p>Recursively merging the parents results in:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/congruence_algorithm/DAG_2.png#center alt=congruence-closure-DAG-3></p><p>Process equality $f^5(a) = a$ gives us:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/congruence_algorithm/DAG_3.png#center alt=congruence-closure-DAG-4></p><p>Now in this step, $f^2(a)$ and $a$ are in the same congruence class, thus we will perform the same operation on their parents, processing equality $f^3(a) = f(a)$:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/congruence_algorithm/DAG_5.png#center alt=congruence-closure-DAG-5></p><p>We find $f(a) \neq a$ has a conflict because node $a$&rsquo;s representative is $f(a)$, indicating they are in the same congruence class, meeting congruence relation.
Thus the formula is UNSAT.</p></content><p></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>