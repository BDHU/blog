<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Personal Blog of Bodun (Edward) Hu. CS PhD student at University of Texas at Austin. Operating systems, network, heterogeneity, MLSys, anything system. UTCS">
<link rel="shortcut icon" href=https://www.bodunhu.com/blog/favicon.ico>
<link rel=stylesheet href=/blog/css/style.min.css>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css rel=stylesheet>
<title>Congruence Closure</title>
</head>
<body><header id=banner>
<h2><a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></h2>
<nav>
<ul>
<li>
<a href=/blog/posts/ title=posts>archive</a>
</li><li>
<a href=https://www.bodunhu.com/ title=about>about</a>
</li>
</ul>
</nav>
</header>
<main id=content>
<article>
<header id=post-header>
<h1>Congruence Closure</h1>
<div>
Updated <time>October 18, 2021</time>
</div>
</header><p>This is a summary of how to compute congruence closure. I implemented the algorithm to compute congruence closure and thought I&rsquo;d never forget it. But my memory starts to get blurry just after two days. So I figured I&rsquo;d put things down so I don&rsquo;t have to watch the entire lecture again the next time I need it.</p>
<h2 id=equivalence-relation>Equivalence Relation</h2>
<p>Equivalence relation has three properties: reflexive, symmetric, and transitive.
(E.g. \(\geq\) is not an equivalence relation because it break the symmetric property. \(4 \geq 6\) does not imply that \(6 \geq 4\).
For example, a binary relation $R$ over a set $S$ meeting these three properties can be expressed as:</p>
<ul>
<li>Reflexive: $\forall s \in S.\ sRs$</li>
<li>Symmetric : $\forall s_1, s_2 \in S.\ s_1 R s_2 \rightarrow s_2 R s_1$</li>
<li>Transitive: $\forall s_1, s_2, s_3 \in S.\ s_1 R s_2 \land s_2 R s_3 \rightarrow s_1 Rs_3$</li>
</ul>
<h2 id=congruence-relation>Congruence Relation</h2>
<p>Given a set $S$ equipped with functions $F = {f_1, &mldr;, f_n}$, a relation $R$ over $S$ is a congruence relation if $R$ is an equivalence relation and for every $n$&lsquo;ary function $f \in F$ we have:</p>
<p>\[\forall \overset{\rightarrow}{s}, \overset{\rightarrow}{t}.\ \bigwedge\limits_{i=1}^{n}s_i R t_i \rightarrow f(\overset{\rightarrow}{s}) R f(\overset{\rightarrow}{t})\]</p>
<p>A counter example would be given $R(x, y)$ defined as $|x| = |y|$ on all integers. If we have $R = {2, 2}$ and $f(x) = x + 1$ (successor function), then we know it violates the equivalence relation we mentioned above</p>
<h2 id=equivalence-closure>Equivalence Closure</h2>
<p>In short, the equivalence closure $R^E$ is the smallest equivalence relation that includes $R$.
This is illustrated through an example. Given a set $S = {a, b, c}$ and binary relation $R:{\langle a, b \rangle , \langle b, c \rangle, \langle d, d \rangle}$, $R^E$ would contain all elements extended from $R$ based on the three properties of equivalence relation.</p>
<h2 id=congruence-closure>Congruence Closure</h2>
<p>Naturally, congruence closure $R^C$ would be the smallest set that contains congruence relation $R$. What this means is $R^C$ contains $R^E$ (the equivlance closure we derived before), and any element generated from $R^E$ by a given function that produces element which also satisfies equivelance relation. For example, Given $S = {a, b, c}$ and function $f$ such that $f(a) = b$, $f(b) = c$, $f(c) = c$, the congruence closure would contain nine elments in total. First, we
would use the procedure above to generated equivalence closure. Then, because $f(a) = b$ and $f(b) = c$ due to congruence relation, we know $b = c$, now we apply the procure for generating equivalence closure again.</p>
<h2 id=algorithm-to-compute-congruence-closure>Algorithm to Compute Congruence Closure</h2>
<p>The high-level description of the algorithm is as following:</p>
<p>To decide satisfiability of $T_{=}$ (equality theory) formula:</p>
<p>\[F\ : \ s_1 = t_1 \land &mldr; s_m = t_m \land s_{m+1} \neq t_{m+1} \land &mldr; s_n \neq t_n\]</p>
<ol>
<li>Compute subterms and construct initial DAG (each node’s representative is itself)</li>
<li>For each $i \in [1,m]$, process equality $s_i= t_i$ as described. (Essentially, process all equiv expression first)</li>
<li>For each $i \in [m + 1,n]$, check if $Rep(s_i) =Rep(t_i)$. (Check if any nequiv expression contradicts any equiv expression)</li>
<li>If there exists some $i \in [m + 1, n]$, for which $Rep(s_i) =Rep(t_i)$, return UNSAT</li>
<li>if for all $i$, $Rep(s_i) \neq Rep(t_i)$, return SAT</li>
</ol>
<p>This is an example for illustration purposes, borrowed from Prof. <a href=https://www.cs.utexas.edu/~isil/>Dillig</a>&rsquo;s slides:</p>
<p>Given formula $F\ : \ f^3(a) = a \land f^5(a) = a \land f(a) \neq a$</p>
<p>The initial DAG would be:</p>
<p><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/congruence_algorithm/DAG.png#center alt=congruence-closure-DAG></p>
<p>Process equality $f^3(a) = a$ gives us:</p>
<p><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/congruence_algorithm/DAG_1.png#center alt=congruence-closure-DAG-2></p>
<p>Recursively merging the parents results in:</p>
<p><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/congruence_algorithm/DAG_2.png#center alt=congruence-closure-DAG-3></p>
<p>Process equality $f^5(a) = a$ gives us:</p>
<p><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/congruence_algorithm/DAG_3.png#center alt=congruence-closure-DAG-4></p>
<p>Now in this step, $f^2(a)$ and $a$ are in the same congruence class, thus we will perform the same operation on their parents, processing equality $f^3(a) = f(a)$:</p>
<p><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/congruence_algorithm/DAG_5.png#center alt=congruence-closure-DAG-5></p>
<p>We find $f(a) \neq a$ has a conflict because node $a$&rsquo;s representative is $f(a)$, indicating they are in the same congruence class, meeting congruence relation.
Thus the formula is UNSAT.</p>
<div style=width:100% id=comment>
<script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script>
</div>
</article>
</main><footer id=footer>
<p>Copyright © 2021 Bodun Hu. All rights reserved.</p>
</footer></body>
</html>