<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Congruence Closure</title><link rel=stylesheet href=https://www.bodunhu.com/blog/css/colors-preference.min.79f305c614b4ceb62b5bba50782f7c04f68b58d85622e7a8bf1c71f396386716.css><link rel="shortcut icon" href=https://www.bodunhu.com/blog/favicon.ico><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js async></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-108144808-1","auto"),ga("send","pageview"))</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-108144808-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><header id=header><h1><a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></h1><p>PhD student at University of Texas at Austin ðŸ¤˜. Doing systems for ML.</p></header><div id=page><div id=sidebar><nav><ul class=nav><li><a href=/blog/posts/><span>Archive</span>&nbsp;</a></li><li><a href=https://www.bodunhu.com/><span>About</span>&nbsp;</a></li><li><a href=/blog/index.xml><span>Feed</span>&nbsp;</a></li></ul></nav></div><div id=content><article class=post><h1><a href=https://www.bodunhu.com/blog/posts/congruence-closure/>Congruence Closure</a></h1><div class=post-content><p>This is a summary of how to compute congruence closure. I implemented the algorithm to compute congruence closure and thought I&rsquo;d never forget it. But my memory starts to get blurry just after two days. So I figured I&rsquo;d put things down so I don&rsquo;t have to watch the entire lecture again the next time I need it.</p><h2 id=equivalence-relation>Equivalence Relation</h2><p>Equivalence relation has three properties: reflexive, symmetric, and transitive.
(E.g. \(\geq\) is not an equivalence relation because it break the symmetric property. \(4 \geq 6\) does not imply that \(6 \geq 4\).
For example, a binary relation $R$ over a set $S$ meeting these three properties can be expressed as:</p><ul><li>Reflexive: $\forall s \in S.\ sRs$</li><li>Symmetric : $\forall s_1, s_2 \in S.\ s_1 R s_2 \rightarrow s_2 R s_1$</li><li>Transitive: $\forall s_1, s_2, s_3 \in S.\ s_1 R s_2 \land s_2 R s_3 \rightarrow s_1 Rs_3$</li></ul><h2 id=congruence-relation>Congruence Relation</h2><p>Given a set $S$ equipped with functions $F = {f_1, &mldr;, f_n}$, a relation $R$ over $S$ is a congruence relation if $R$ is an equivalence relation and for every $n$&lsquo;ary function $f \in F$ we have:</p><p>\[\forall \overset{\rightarrow}{s}, \overset{\rightarrow}{t}.\ \bigwedge\limits_{i=1}^{n}s_i R t_i \rightarrow f(\overset{\rightarrow}{s}) R f(\overset{\rightarrow}{t})\]</p><p>A counter example would be given $R(x, y)$ defined as $|x| = |y|$ on all integers. If we have $R = {2, 2}$ and $f(x) = x + 1$ (successor function), then we know it violates the equivalence relation we mentioned above</p><h2 id=equivalence-closure>Equivalence Closure</h2><p>In short, the equivalence closure $R^E$ is the smallest equivalence relation that includes $R$.
This is illustrated through an example. Given a set $S = {a, b, c}$ and binary relation $R:{\langle a, b \rangle , \langle b, c \rangle, \langle d, d \rangle}$, $R^E$ would contain all elements extended from $R$ based on the three properties of equivalence relation.</p><h2 id=congruence-closure>Congruence Closure</h2><p>Naturally, congruence closure $R^C$ would be the smallest set that contains congruence relation $R$. What this means is $R^C$ contains $R^E$ (the equivlance closure we derived before), and any element generated from $R^E$ by a given function that produces element which also satisfies equivelance relation. For example, Given $S = {a, b, c}$ and function $f$ such that $f(a) = b$, $f(b) = c$, $f(c) = c$, the congruence closure would contain nine elments in total. First, we
would use the procedure above to generated equivalence closure. Then, because $f(a) = b$ and $f(b) = c$ due to congruence relation, we know $b = c$, now we apply the procure for generating equivalence closure again.</p><h2 id=algorithm-to-compute-congruence-closure>Algorithm to Compute Congruence Closure</h2><p>The high-level description of the algorithm is as following:</p><p>To decide satisfiability of $T_{=}$ (equality theory) formula:</p><p>\[F\ : \ s_1 = t_1 \land &mldr; s_m = t_m \land s_{m+1} \neq t_{m+1} \land &mldr; s_n \neq t_n\]</p><ol><li>Compute subterms and construct initial DAG (each nodeâ€™s representative is itself)</li><li>For each $i \in [1,m]$, process equality $s_i= t_i$ as described. (Essentially, process all equiv expression first)</li><li>For each $i \in [m + 1,n]$, check if $Rep(s_i) =Rep(t_i)$. (Check if any nequiv expression contradicts any equiv expression)</li><li>If there exists some $i \in [m + 1, n]$, for which $Rep(s_i) =Rep(t_i)$, return UNSAT</li><li>if for all $i$, $Rep(s_i) \neq Rep(t_i)$, return SAT</li></ol><p>This is an example for illustration purposes, borrowed from Prof. <a href=https://www.cs.utexas.edu/~isil/>Dillig</a>&rsquo;s slides:</p><p>Given formula $F\ : \ f^3(a) = a \land f^5(a) = a \land f(a) \neq a$</p><p>The initial DAG would be:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/congruence_algorithm/DAG.png#center alt=congruence-closure-DAG></p><p>Process equality $f^3(a) = a$ gives us:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/congruence_algorithm/DAG_1.png#center alt=congruence-closure-DAG-2></p><p>Recursively merging the parents results in:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/congruence_algorithm/DAG_2.png#center alt=congruence-closure-DAG-3></p><p>Process equality $f^5(a) = a$ gives us:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/congruence_algorithm/DAG_3.png#center alt=congruence-closure-DAG-4></p><p>Now in this step, $f^2(a)$ and $a$ are in the same congruence class, thus we will perform the same operation on their parents, processing equality $f^3(a) = f(a)$:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/congruence_algorithm/DAG_5.png#center alt=congruence-closure-DAG-5></p><p>We find $f(a) \neq a$ has a conflict because node $a$&rsquo;s representative is $f(a)$, indicating they are in the same congruence class, meeting congruence relation.
Thus the formula is UNSAT.</p></div><p class=meta>Posted on <span class=postdate>27. March 2021</span></p></article></div><footer id=footer><p class=copyright><p>Â© 2022 <a href=https://www.bodunhu.com>Bodun Hu</a>. All rights reserved.</p></p></footer></div></body></html>