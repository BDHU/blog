<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Personal Blog of Bodun (Edward) Hu. CS PhD student at University of Texas at Austin. Operating systems, network, heterogeneity, MLSys, anything system. UTCS">
<link rel="shortcut icon" href=https://www.bodunhu.com/blog/favicon.ico>
<link rel=stylesheet href=/blog/css/style.min.css>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css rel=stylesheet>
<title>Fault Tolerance in Distributed Systems</title>
</head>
<body><header id=banner>
<h2><a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></h2>
<nav>
<ul>
<li>
<a href=/blog/posts/ title=posts>archive</a>
</li><li>
<a href=https://www.bodunhu.com/ title=about>about</a>
</li>
</ul>
</nav>
</header>
<main id=content>
<article>
<header id=post-header>
<h1>Fault Tolerance in Distributed Systems</h1>
<div>
Updated <time>October 17, 2021</time>
</div>
</header><p>No systems can provide fault-free guarantees, including distributed systems. However, failures in distributed systems are <em>independent</em>. It means only a subset of processes fail at once. We can exploit this feature and provide some degree of fault tolerance. The problem is, fault tolerance makes everything else much more difficult.</p>
<p>The most common fault models is the <em>fail-stop</em>. It means a process completely &ldquo;bricks&rdquo;. When a process fail-stops, no messages can emerge from this process any more. We also don&rsquo;t know if this process will ever restart. In addition, we must account for all possible states of the faulty process, including unsent messages in the process&rsquo;s queue. On the other hand, it&rsquo;s important to point out a process that takes a long time to respond is indistinguishable from a fail-stop. The intuition is such processes and the faulty ones may take an unknown amount of time before message emerge.</p>
<p>We use an example here to illustrate how and why a system fails to provide fault-tolerance. We take a system that replicates data by broadcasting operations using logical timestamps. This system uses <a href=https://en.wikipedia.org/wiki/Lamport_timestamp>Lamport clock</a> to update local clocks (our previous <a href=/blog/posts/lamport-distributed-mutual-exclusion/>post</a> on Lamport Distributed Mutual Exclusion explains how Lamport clock works). In short, we overwrite the value stored in a replica if an incoming message has later timestamp \(ts\).</p>
<p><img src=https://raw.githubusercontent.com/BDHU/Page_pics/670f3b49245d07e57781b1800609675ddcd1d33b/posts/fault-tolerance-in-distributed-systems/replication.png#center alt=replication></p>
<center>Source: Ken McMillan</center>
<p>This system is not fault-tolerant. Imagine when one replica receives a write (marked by red incoming &ldquo;write&rdquo;) request and then tries to write the value to other replicas. This replica then fail-stops right after it writes to one replica and never writes to the other replica. In this case, not all replicas see the writes, thus violating consistency.</p>
<p>The solution to this problem is quite simple: reliable atomic broadcast. Under atomic broadcast, all writes are all-or-nothing. It eliminates the possibility for a process to fail-stop amid broadcasting.</p>
<p>Now let&rsquo;s take the above example and update it with additional requirements. Instead of overwriting existing values, we append writes to an array and want to ensure every replica has the same array eventually. The major difference is that replicas needs to wait for acks with higher timestamps before it can append to its array.</p>
<p>This system is also not fault-tolerant. If one replica fail-stops, others will wait forever on a write, because every replicas relies on acks with higher timestamps before committing the append.</p>
<p>Thus, we want to extend the atomic broadcast so that updates become ordered. Under ordered atomic broadcast, writes are all-or-nothing and everyone agrees on the order of updates. If we assume the system to be fully asynchronous, ordered atomic broadcasts are not possible: (1) we can&rsquo;t guarantee termination under asynchrony; (2) we could lose order. Thus, we rely on the synchronous approach.</p>
<p>Under the synchronous assumption, we can safely say a process fails after waiting for time \(t _{fail}\), where \(t _{fail} = 3 t _{msg} + 2 t _{turn}\). Here, \(t _{msg}\) is the message transfer latency, and \(t _{turn}\) is the max time to respond to a message.</p>
<p>To see why \(t _{fail}\) is calculated this way, we use the following example to explain the process:</p>
<p><img src=https://raw.githubusercontent.com/BDHU/Page_pics/bd7266dfbbf067389a62ecded5feb6c1861b8a0f/posts/fault-tolerance-in-distributed-systems/fail-time.png#center alt=process-fail><center>Source: Ken McMillan</center></p>
<p>Imagine process \(p\) sends a message to \(q\) and waits for an ack from \(q\). Before \(q\) is able respond with the ack, it somehow crashes. The max time taken for \(p\) to see an aco from \(q\) would be two message transfer time plus the execution time by \(q\), which is \(2t _{msg} + t _{turn}\). We add \(t\) to indicate the elapsed time when \(p\) sends the request.</p>
<p>Now imagine \(q\) is able to broadcast a request right before it fails. Later, another process is able to forward this request back to \(p\). Then \(p\) needs to wait for three message transfer time plus two message processing time before it can assume that it will no longer receive message from \(q\).</p>
<p><img src=https://raw.githubusercontent.com/BDHU/Page_pics/d129b7823a217934cd3a826e5c4c4ee83ff30824/posts/fault-tolerance-in-distributed-systems/time-fail.png#center alt=process-fail></p>
<p>Under the synchronous assumption, ordered reliable atomic broadcast works as follows:</p>
<ul>
<li>When a client send a request to process \(p\), the process records logical time \(r _l(p,p)\) and physical time \(r _{t}(p,p)\). Then it broadcast the request.</li>
<li>When process \(p\) receives a message \(m\), and if message \(m\) contains previously unseen timestamp \(t_m\), then we record the logical time we see message \(m\) at \(p\), denoted as \(r_l(p, p_m)\) as well as the physical time \(r _t(p, p_m)\). Then we broadcast the request. Finally, we send an ack back to the originator \(p_m\) without updated timestamp.</li>
<li>When process \(p\) receives a message \(m\), \(p\) updates \(t _l(p, p_m)\). It means we update \(p\)&rsquo;s notion of the latest timestamp of another process who just acked.</li>
<li>Process \(p\) sets another process \(q\) as &ldquo;failed&rdquo; (denoted by \(f(p, q)\)) if \(t _l(p, q) \leq r _l(p, p') &lt; +\infty\) and \(t _t &lt; r _t(p, p') + t _{fail}\). In short, it means if we broadcast message and don&rsquo;t receive any response after time \(t _{fail}\), and our last recorded logical time of process \(q\) is before our broadcast, then we know process \(q\) must have failed.</li>
<li>Then we perform updates when for all \(q \neq p\), \(r _l(p,p) &lt; r _l (p, q)\) (meaning everyone else&rsquo;s request time is later than mine) and \(t _l(p,q) > r _l(p,p) \lor f(p, q)\). Intuitively, it means we only perform updates when we receive message from other processes after our broadcast, and when we think other processes' timestamps are after us, or when they have all failed.</li>
</ul>
<div style=width:100% id=comment>
<script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script>
</div>
</article>
</main><footer id=footer>
<p>Copyright Â© 2021 Bodun Hu. All rights reserved.</p>
</footer></body>
</html>