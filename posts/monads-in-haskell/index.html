<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content="Liste - https://www.bodunhu.com/blog/">
<title>Monads in Haskell | std::bodun::blog</title>
<meta name=description content="I've scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads. I take William Cook's [Anatomy of Programming Languages](http://www.cs.utexas.edu/~wcook/anatomy/anatomy.htm) as my reference">
<meta property="og:title" content="Monads in Haskell">
<meta property="og:description" content="I've scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads. I take William Cook's [Anatomy of Programming Languages](http://www.cs.utexas.edu/~wcook/anatomy/anatomy.htm) as my reference">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.bodunhu.com/blog/posts/monads-in-haskell/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-03-01T00:00:00+00:00">
<meta property="article:modified_time" content="2021-05-19T16:25:59-05:00">
<meta itemprop=name content="Monads in Haskell">
<meta itemprop=description content="I've scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads. I take William Cook's [Anatomy of Programming Languages](http://www.cs.utexas.edu/~wcook/anatomy/anatomy.htm) as my reference"><meta itemprop=datePublished content="2020-03-01T00:00:00+00:00">
<meta itemprop=dateModified content="2021-05-19T16:25:59-05:00">
<meta itemprop=wordCount content="832">
<meta itemprop=keywords content="PL,">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Monads in Haskell">
<meta name=twitter:description content="I've scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads. I take William Cook's [Anatomy of Programming Languages](http://www.cs.utexas.edu/~wcook/anatomy/anatomy.htm) as my reference">
<meta name=twitter:site content="@https://twitter.com/BodunHu">
<link rel=canonical href=https://www.bodunhu.com/blog/posts/monads-in-haskell/>
<meta name=monetization content="$twitter.xrptipbot.com/ronaldsvilcins">
<link rel=dns-prefetch href=https://www.google-analytics.com>
<link href=https://www.google-analytics.com rel=preconnect crossorigin>
<link rel=alternate type=application/atom+xml title=std::bodun::blog href=https://www.bodunhu.com/blog/atom.xml>
<link rel=alternate type=application/json title=std::bodun::blog href=https://www.bodunhu.com/blog/feed.json>
<link rel="shortcut icon" href=/blog/images/favicon.ico type=image/x-icon>
<style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:2rem;color:#000}.skip-link{position:absolute;top:-40px;left:0;background:#eee;z-index:100}.skip-link:focus{top:0}h1,h2,h3,h4,h5,strong,b{font-size:inherit;font-weight:600}header{line-height:2;padding-bottom:1.5rem}.link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.time{font-variant-numeric:tabular-nums;white-space:nowrap}blockquote{border-left:5px solid #eee;padding-left:1rem;margin:0}a,a:visited{color:inherit}a:hover,a.heading-link{text-decoration:none}pre{padding:.5rem;overflow:auto;overflow-x:scroll;overflow-wrap:normal}code,pre{font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;font-size:small;background:#eee}code{padding:.1rem;border:none}ul{list-style-type:square}ul,ol{padding-left:1.2rem}.list{line-height:2;list-style-type:none;padding-left:0}.list li{padding-bottom:.1rem}.meta{color:#777}.content{max-width:70ch;margin:0 auto}header{line-height:2;display:flex;justify-content:space-between;padding-bottom:1rem}header a{text-decoration:none}header ul{list-style-type:none;padding:0}header li,header a{display:inline}h2.post{padding-top:.5rem}header ul a:first-child{padding-left:1rem}.nav{height:1px;background:#000;content:'';max-width:10%}.list li{display:flex;align-items:baseline}.list li time{flex:initial}.hr-list{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px dotted #ccc;flex:1 0 1rem}.hr-list-none{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px #ccc;flex:1 0 1rem}.m,hr{border:0;margin:3rem 0}img{max-width:100%;height:auto}</style>
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Monads in Haskell","headline":"Monads in Haskell","alternativeHeadline":"","description":"I\u0027ve scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads. I take William Cook\u0027s [Anatomy of Programming Languages](http:\/\/www.cs.utexas.edu\/~wcook\/anatomy\/anatomy.htm) as my reference","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.bodunhu.com\/blog\/posts\/monads-in-haskell\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"std::bodun::blog","copyrightYear":"2020","dateCreated":"2020-03-01T00:00:00.00Z","datePublished":"2020-03-01T00:00:00.00Z","dateModified":"2021-05-19T16:25:59.00Z","publisher":{"@type":"Organization","name":"std::bodun::blog","url":"https://www.bodunhu.com/blog/","logo":{"@type":"ImageObject","url":"https:\/\/www.bodunhu.com\/blog\/","width":"32","height":"32"}},"image":"https://www.bodunhu.com/blog/","url":"https:\/\/www.bodunhu.com\/blog\/posts\/monads-in-haskell\/","wordCount":"832","genre":["PL"],"keywords":["PL"]}</script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
</head>
<body>
<a class=skip-link href=#main>Skip to main</a>
<main id=main>
<div class=content>
<header>
<p style=padding:0;margin:0><a href=/blog/><b>std::bodun::blog</b></a></p>
<ul style=padding:0;margin:0>
<li><a href=https://www.bodunhu.com/>About</a></li>
</ul>
</header>
<hr class=hr-list style=padding:0;margin:0>
<h2 class=post>Monads in Haskell</h2>
<p>I&rsquo;ve scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads. I take William Cook&rsquo;s <a href=http://www.cs.utexas.edu/~wcook/anatomy/anatomy.htm>Anatomy of Programming Languages</a> as my reference.</p>
<h2 id=definitions-of-monads>Definitions of Monads <a href=#definitions-of-monads class="hash g">#</a></h2>
<p>A monad is defined as a computational structure that involves three parts:</p>
<ul>
<li>A generic data type \(m\)</li>
<li>A <em>return</em> function \(return_m\) :: \(t\rightarrow mt\)</li>
<li>A <em>bind</em> function \(\triangleright_mt\rightarrow (t\rightarrow ms)\rightarrow ms\)</li>
</ul>
<p>Here the symbol \(m\) gives the name of the monad as well as the shape of the computation. We can call the program that uses the monad \(m\) as an m-computation. The instantiation of the generic type \(mt\) at a particular type \(t\) represents n m-computation that produces a value of type \(t\). The \(m\)-computation indicates that in addition to value \(t\), some additional requirements or effects will take place. This is the essence of monads.</p>
<p>The definition of the <code>return</code> function states that how values are converted into m-computations. The <code>return</code> will just return the value of type \(t\). For example, if we pass in a stateful memory information, <code>return</code> shouldn&rsquo;t modify the actual but only provide a context to which the value lies in. The reason we convert value into m-computation is that if any error occur then <code>return</code> will catch the error without adding additional error checking codes.</p>
<p>The bind function \(\triangleright_m\) specifies how computations are combined together. THe general idea is that the computation behavior of \(A\triangleright_m F\) indicates the m-computation \(A\) is performed first, the value it produces wil be passed to the function \(F\) to create a second m-computation. Because \(A\) is a m-computation, if an error happens, the computation will stop and \(F\) will not be performed.</p>
<h2 id=monads-in-haskell>Monads in Haskell <a href=#monads-in-haskell class="hash g">#</a></h2>
<p>In Haskell, we can use Monads using type class. A type class is defined as:</p>
<pre><code class=language-haskell>class Monad m where
  (&gt;&gt;=) :: m t -&gt; (t -&gt; m s) -&gt; m s
  return :: t -&gt; m t
</code></pre>
<p>For a object of generic type \(m\) to be a Monad, it must have those two functions defined. A type class allows us to overload functions according to their type.</p>
<p>So why do we need Monads in the first place? If we are given a function \(func1\) which takes in an Int value and produces an Int output, we could link the function together to form a chain of computation. If we make a function like this:</p>
<pre><code class=language-haskell>func1 :: Int -&gt; (Int, Int) -&gt; (Int, Int) 
x &amp; func1 = func1 x
</code></pre>
<p>we could use the output of the function as the input to the same function to produce another value. This process can be repeated and thus form a chain of operation:</p>
<pre><code class=language-haskell>(0, 0) &amp; func1 1 &amp; func1 2 &amp; func1 3 ...
</code></pre>
<p>However, the function \(func1\) could potentially return a Nothing if the given input doesn&rsquo;t meet certain standards (exp. divide by 0). Therefore, \(func1\) can modified to:</p>
<pre><code class=language-haskell>func1 :: Int -&gt; (Int, Int) -&gt; Maybe (Int, Int)
</code></pre>
<p>The previous definition of \(func1\) says \(func1\) takes a (Int, Int) tuple as one input, but now if we feed the output of \(func1\) directly to the next \(func1\) in the chain, error would occur because \(func1\) takes a raw (Int, Int) tuple as the input, but now we have (Int, Int) wrapped in a Maybe context. The & operator is not able to pass the argument with a context to the next func1. Fortunately, we have the bind operator defined.</p>
<p>If we look at the definition of the <strong>&#187;=</strong> in Monad definition, we see:</p>
<pre><code class=language-haskell>(&gt;&gt;=) :: m t -&gt; (t -&gt; m s) -&gt; m s
</code></pre>
<p>This means <strong>&#187;=</strong> is able to take a value within certain context and map a function that takes the raw value as input to the it. We can simply switch the <strong>&</strong> operator to <strong>&#187;=</strong> such that the chaining would still work:</p>
<pre><code class=language-haskell>return (0, 0) &gt;&gt;= func1 1 &gt;&gt;= func1 2 &gt;&gt;= func1 3 ...
</code></pre>
<p>If an error occurred in one part of the chain (let&rsquo;s assume one computation yields Nothing). Then the Nothing value will be propagated to the next function, which will automatically generate an error, or Nothing. Otherwise we would have written error checking code at the end of each single computation to check their output.</p>
<p>In short, <strong>&#187;=</strong> is just a way to chain functions with parametric polymorphism together.</p>
<h2 id=haskell-do-notation>Haskell <em>do</em> Notation <a href=#haskell-do-notation class="hash g">#</a></h2>
<p>Using the do notation can simply the use of bind operator. The basic pattern of do notation is:</p>
<pre><code class=language-haskell>do
  x &lt;- e1
  e2
</code></pre>
<p>which is equivalent to:</p>
<pre><code class=language-haskell>e1 &gt;&gt;= (\lambda x.e2)
</code></pre>
<p>The <strong>&lt;-</strong> notation simply indicates \(x\) is bind to the value the computation generates. In other words, \(x\) doesn&rsquo;t lie in a context. if \(e1\) returns Nothing, \(x\) is not bind to anything. It&rsquo;s important to remember that do expressions are just different syntax for chaining monadic values.</p>
<p>For a more detailed explanation of Monads, I found <a href=http://learnyouahaskell.com/a-fistful-of-monads>A Fistful of Monads</a> to be extremely helpful in terms of clarifying the concept.</p>
<hr class=hr-list>
<footer>
<p>© 2016-2021 <a href=https://www.bodunhu.com/>Bodun Hu</a>. All rights reserved. <a href=/blog/index.xml>Subscribe</a></p>
</footer>
</div>
</main>
</body>
</html>