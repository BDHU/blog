<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="PhD student at University of Texas at Austin ðŸ¤˜. Doing systems for ML."><link rel="shortcut icon" href=https://www.bodunhu.com/blog/favicon.ico><link rel=stylesheet href=/blog/css/style.min.css><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js async></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-108144808-1","auto"),ga("send","pageview"))</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-108144808-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<link rel=canonical href=https://www.bodunhu.com/blog/posts/monads-in-haskell/><title>Monads in Haskell</title></head><body><header id=banner><h2><a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></h2><nav><ul><li><a href=/blog/posts/ title=posts>Archive</a></li><li><a href=https://www.bodunhu.com/ title=about>About</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Monads in Haskell</h1><div><time>February 13, 2022</time></div></header><p>I&rsquo;ve scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads. I take William Cook&rsquo;s <a href=http://www.cs.utexas.edu/~wcook/anatomy/anatomy.htm>Anatomy of Programming Languages</a> as my reference.</p><h2 id=definitions-of-monads>Definitions of Monads</h2><p>A monad is defined as a computational structure that involves three parts:</p><ul><li>A generic data type \(m\)</li><li>A <em>return</em> function \(return_m\) :: \(t\rightarrow mt\)</li><li>A <em>bind</em> function \(\triangleright_mt\rightarrow (t\rightarrow ms)\rightarrow ms\)</li></ul><p>Here the symbol \(m\) gives the name of the monad as well as the shape of the computation. We can call the program that uses the monad \(m\) as an m-computation. The instantiation of the generic type \(mt\) at a particular type \(t\) represents n m-computation that produces a value of type \(t\). The \(m\)-computation indicates that in addition to value \(t\), some additional requirements or effects will take place. This is the essence of monads.</p><p>The definition of the <code>return</code> function states that how values are converted into m-computations. The <code>return</code> will just return the value of type \(t\). For example, if we pass in a stateful memory information, <code>return</code> shouldn&rsquo;t modify the actual but only provide a context to which the value lies in. The reason we convert value into m-computation is that if any error occur then <code>return</code> will catch the error without adding additional error checking codes.</p><p>The bind function \(\triangleright_m\) specifies how computations are combined together. THe general idea is that the computation behavior of \(A\triangleright_m F\) indicates the m-computation \(A\) is performed first, the value it produces wil be passed to the function \(F\) to create a second m-computation. Because \(A\) is a m-computation, if an error happens, the computation will stop and \(F\) will not be performed.</p><h2 id=monads-in-haskell>Monads in Haskell</h2><p>In Haskell, we can use Monads using type class. A type class is defined as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#66d9ef>Monad</span> m <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>  (<span style=color:#f92672>&gt;&gt;=</span>) <span style=color:#f92672>::</span> m t <span style=color:#f92672>-&gt;</span> (t <span style=color:#f92672>-&gt;</span> m s) <span style=color:#f92672>-&gt;</span> m s
</span></span><span style=display:flex><span>  return <span style=color:#f92672>::</span> t <span style=color:#f92672>-&gt;</span> m t
</span></span></code></pre></div><p>For a object of generic type \(m\) to be a Monad, it must have those two functions defined. A type class allows us to overload functions according to their type.</p><p>So why do we need Monads in the first place? If we are given a function \(func1\) which takes in an Int value and produces an Int output, we could link the function together to form a chain of computation. If we make a function like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>func1</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>) <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>) 
</span></span><span style=display:flex><span><span style=color:#a6e22e>x</span> <span style=color:#f92672>&amp;</span> func1 <span style=color:#f92672>=</span> func1 x
</span></span></code></pre></div><p>we could use the output of the function as the input to the same function to produce another value. This process can be repeated and thus form a chain of operation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&amp;</span> func1 <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;</span> func1 <span style=color:#ae81ff>2</span> <span style=color:#f92672>&amp;</span> func1 <span style=color:#ae81ff>3</span> <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>However, the function \(func1\) could potentially return a Nothing if the given input doesn&rsquo;t meet certain standards (exp. divide by 0). Therefore, \(func1\) can modified to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>func1</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> (<span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>) <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> (<span style=color:#66d9ef>Int</span>, <span style=color:#66d9ef>Int</span>)
</span></span></code></pre></div><p>The previous definition of \(func1\) says \(func1\) takes a (Int, Int) tuple as one input, but now if we feed the output of \(func1\) directly to the next \(func1\) in the chain, error would occur because \(func1\) takes a raw (Int, Int) tuple as the input, but now we have (Int, Int) wrapped in a Maybe context. The & operator is not able to pass the argument with a context to the next func1. Fortunately, we have the bind operator defined.</p><p>If we look at the definition of the <code>>>=</code> in Monad definition, we see:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>(<span style=color:#f92672>&gt;&gt;=</span>) <span style=color:#f92672>::</span> m t <span style=color:#f92672>-&gt;</span> (t <span style=color:#f92672>-&gt;</span> m s) <span style=color:#f92672>-&gt;</span> m s
</span></span></code></pre></div><p>This means <code>>>=</code> is able to take a value within certain context and map a function that takes the raw value as input to the it. We can simply switch the <code>&</code> operator to <code>>>=</code> such that the chaining would still work:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>return</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>) <span style=color:#f92672>&gt;&gt;=</span> func1 <span style=color:#ae81ff>1</span> <span style=color:#f92672>&gt;&gt;=</span> func1 <span style=color:#ae81ff>2</span> <span style=color:#f92672>&gt;&gt;=</span> func1 <span style=color:#ae81ff>3</span> <span style=color:#f92672>...</span>
</span></span></code></pre></div><p>If an error occurred in one part of the chain (let&rsquo;s assume one computation yields Nothing). Then the Nothing value will be propagated to the next function, which will automatically generate an error, or Nothing. Otherwise we would have written error checking code at the end of each single computation to check their output.</p><p>In short, <code>>>=</code> is just a way to chain functions with parametric polymorphism together.</p><h2 id=haskell-do-notation>Haskell <em>do</em> Notation</h2><p>Using the do notation can simply the use of bind operator. The basic pattern of do notation is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  x <span style=color:#f92672>&lt;-</span> e1
</span></span><span style=display:flex><span>  e2
</span></span></code></pre></div><p>which is equivalent to:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>e1</span> <span style=color:#f92672>&gt;&gt;=</span> (<span style=color:#a6e22e>\</span>lambda x<span style=color:#f92672>.</span>e2)
</span></span></code></pre></div><p>The <code>&lt;-</code> notation simply indicates \(x\) is bind to the value the computation generates. In other words, \(x\) doesn&rsquo;t lie in a context. if \(e1\) returns Nothing, \(x\) is not bind to anything. It&rsquo;s important to remember that do expressions are just different syntax for chaining monadic values.</p><p>For a more detailed explanation of Monads, I found <a href=http://learnyouahaskell.com/a-fistful-of-monads>A Fistful of Monads</a> to be extremely helpful in terms of clarifying the concept.</p><div style=width:100% id=comment><script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script></div></article></main><footer id=footer><p>Â© 2023 Bodun Hu. All rights reserved.</p></footer></body></html>