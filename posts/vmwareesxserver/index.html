<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Memory Resource Management in VMware ESX Server - std::bodun:blog</title><link rel=icon type=image/png href=/blog/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Memory Resource Management in VMware ESX Server"><meta property="og:description" content="VMWare ESX Server is a software layer designed to multiplex hardware resources among virtual machines running unmodified commodity operating systems. ESX Server, different to VMware Workstation, is a type 1 hypervisor, which means it runs directly on bare metal."><meta property="og:type" content="article"><meta property="og:url" content="https://www.bodunhu.com/blog/posts/vmwareesxserver/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-21T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-21T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Memory Resource Management in VMware ESX Server"><meta name=twitter:description content="VMWare ESX Server is a software layer designed to multiplex hardware resources among virtual machines running unmodified commodity operating systems. ESX Server, different to VMware Workstation, is a type 1 hypervisor, which means it runs directly on bare metal."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.bodunhu.com/blog/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.bodunhu.com/blog/css/main.css><link rel=stylesheet type=text/css href=https://www.bodunhu.com/blog/css/dark.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://www.bodunhu.com/blog/js/main.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><meta name=google-site-verification content="rCBqGFj-RPsmjg3Aho3_wEfipA1SHxSEDnsAZZrv_J8"></head><body><div class="container wrapper post"><div class=header><base href=https://www.bodunhu.com/blog/><h1 class=site-title><a href=https://www.bodunhu.com/blog/>std::bodun:blog</a></h1><div class=site-description><h2>PhD student at <a href=https://www.utexas.edu/>UT Austin</a>. OS, kernel, network, heterogeneity, anything system.</h2><nav class="nav social"><ul class=flat><a href=https://twitter.com/BodunHu title=Twitter><i data-feather=twitter></i></a><a href=https://github.com/BDHU/ title=Github><i data-feather=github></i></a><a href=/blog/index.xml title=RSS><i data-feather=rss></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/blog/>Home</a></li><li><a href=/blog/posts>All posts</a></li><li><a href=/blog/about>About</a></li><li><a href=/blog/tags>Tags</a></li><li><a href="https://www.google.com/search?sitesearch=https%3A%2F%2Fwww.bodunhu.com/blog%2F&q=">Search</a></li></ul></nav></div><div class=post-header><h1 class=title>Memory Resource Management in VMware ESX Server</h1><div class=meta>Posted at &mdash; Sep 21, 2020</div></div><div class=markdown><p><a href=https://www.vmware.com/products/esxi-and-esx.html>VMWare ESX Server</a> is a software layer designed to multiplex hardware resources among virtual machines running unmodified commodity operating systems. ESX Server, different to <a href=https://www.vmware.com/products/workstation-pro.html>VMware Workstation</a>, is a type 1 hypervisor, which means it runs directly on bare metal. ESX Server focuses on running guest VMs without modifying the guest OSes at all, which is challenging.</p><blockquote><p>Memory Virtualization is done by interposing an extra abstraction layer between a <code>physical address</code> from the VM&rsquo;s point of view, and a <code>machine address</code> which represents the actual hardware memory. ESX Server maintains a <em>pmap</em> data structure for each VM to translate PPMs to MPNs. A seperate <em>shadow page table</em>, consistent with the physical-to-machine mappings, is used to map virtual-to-machine page mappings. This avoids additional overheads as the hardware TLB will cache direct virtual-to-machine address translations read from the shadow page table.</p></blockquote><h2 id=key-features>Key features</h2><p align=center><a href=https://www.vmware.com/pdf/usenix_resource_mgmt.pdf><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/ESXServer/ballooning.png width=70%></a></p><p><strong>Ballooning</strong> is a technique used by the server to acheive memory reclamation. As its name suggests, the hypervisor inflates the balloon by instructing the balloon driver module to allocate pinned phyiscal pages and deflates it by instructing it to deallocate previously-allocated pages. The idea behind this technique is that the hypervisor is unaware of the specific usage patterns of policies of its guests, therefore the making page replacement decisions is best done in the guest VM. When the hypervisor over commits memory, it needs some way to claim memories from the VMs. By consuming some of the memory that the guest OS believes is physically present in the virtual machine. The guest OS will then swap memory to disk reducing the load on the host&rsquo;s phyiscal memory. The host will them reallocate that memory to other VMs. A details description of ballooning can be found in this <a href=https://www.vladan.fr/what-is-vmware-memory-ballooning/>post</a>.</p><p align=center><a href=https://www.vmware.com/pdf/usenix_resource_mgmt.pdf><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/ESXServer/pghash.png width=70%></a></p><blockquote><p>Page Coloring can be used to reduce cache misses or partition resources. But it might comlicates memory management, especially with the presence of huge pages. Because coloring enforeces ownership, thus might result in distinct L2 cache entries.</p></blockquote><p><strong>Sharing memory</strong> is achieved by comparing the content of each page, since modifying guest operating system internals is not possible. Because comparing each page would be \(O(n^2)\), hasing is used to identify pages to make the progress more efficiently. By letting VMs share pages based the contents, the host can potentially save spaces dramatically. For example, the presence of zero pages is a greate opportunity for page sharing by mapping one zero page to multiple VMs. Hint is hash hit, but it doesn&rsquo;t guarantee the content of the page doesn&rsquo;t change at that moment.</p><p><strong>Idle Memory</strong> presents a problem in pure proportional-share algorithms because they do not incorporate any information about active memory usage. More specifically, the memory demand might change dynamically. ESX Server collects <em>idle memory tax</em> from VMs to mitigate this issue. A client is charged more for an idle page than the active one. The cost of idle memory is inflated by tax rate. The metrics of idles pages in guests is collected by hypersior without guests' involvement. The idle page information in virtual page table inside VMs is periodically sampled on random bases.</p><h2 id=questions>Questions</h2><p>a. What is the overhead of ballooning? Triggering memory management in the VM by &ldquo;tricking&rdquo; it into thinking the the memory resource is scarce/plentiful may have unexpected behaviors.<br>b. Do content-based sharing pose secrutiy vulnerabilities?<br>c. Remapping hot I/O pages to low memory can be a bottleneck if the page number is high. How does modern hypervisor solution cope with this issue?</p></div><div class=post-tags><nav class="nav tags"><ul class=flat><li><a href=/blog/tags/os>os</a></li><li><a href=/blog/tags/virtualization>virtualization</a></li><li><a href=/blog/tags/mm>mm</a></li></ul></nav></div><script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script></div><div class="footer wrapper"><nav class=nav><div>Â© Copyright notice | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>