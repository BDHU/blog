<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="PhD student at University of Texas at Austin ðŸ¤˜. Doing systems for ML."><link rel="shortcut icon" href=https://www.bodunhu.com/blog/favicon.ico><link rel=stylesheet href=/blog/css/style.min.css><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZLK2GHB055"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZLK2GHB055")}</script><link rel=canonical href=https://www.bodunhu.com/blog/posts/specifying-token-ring-for-mutual-exclusion/><title>Specifying Token Ring for Mutual Exclusion</title></head><body><header id=banner><h2><a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></h2><nav><ul><li><a href=/blog/posts/ title=posts>Archive</a></li><li><a href=https://www.bodunhu.com/ title=about>About</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Specifying Token Ring for Mutual Exclusion</h1><div><time>February 14, 2022</time></div></header><p>Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it&rsquo;s a mechanism of concurrency control allowing exclusive access to some resource (or &ldquo;critical region&rdquo;). Token passing is an algorithm for distributed mutual exclusion (DME) and will be our focus in this post.</p><p>DME specifications usually make the following assumptions:</p><ul><li>Network delivers message in order, e.g. TCP (sometimes)</li><li>Every message is eventually delivered (usually)</li><li>Messages are never duplicated. Duplication may result granting resources to multiple clients, which is not what mutual exclusion demands (usually)</li></ul><p>Thing we might want to guarantee for DME specifications are:</p><ul><li>Mutual exclusion, at most one client is in a critical section (always)</li><li>Non-starvation. A requesting client enters critical section eventually (usually)</li><li>Non-overtaking. A client cannot enter critical section more than once while another client waits (usually)</li></ul><p>In addition, we need to analyze DME algorithms&rsquo; performance metrics, which usually includes:</p><ul><li>Message complexity, e.g. number of messages sent between clients being served</li><li>response time, or time between request and entering CS</li><li>Throughput, or rate of processing CS requests</li></ul><p>Let&rsquo;s take a token ring as an example. In a token ring, a client holds a token and then sends it to the next one after exiting its critical section. When we make assumptions about a token ring, we</p><ul><li>do not need to have network delivering messages in order, because at any given time in a token, there is at most one message in transit.</li><li>ensure every message is eventually delivered. Otherwise, the system won&rsquo;t make progress, and we will not have non-starvation guarantee.</li><li>need non-duplication for messages. Otherwise, we violate the fundamental properties of this protocol, or no mutual exclusion.</li><li>clients don&rsquo;t spuriously release. This will be clear later when we demonstrate what happens if clients release multiple times.</li></ul><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/token-ring-protocol/token-ring.png#center alt=token-ring></p><p>We want to guarantee that</p><ul><li>mutual exclusion holds.</li><li>non-starvation</li><li>non-overtaking, because token will get through every client in the network first because repetition happens.</li></ul><p>To analyze token performance, we use the above performance metrics (message complexity, response time, and throughput)</p><ul><li>Message complexity: when the system is under low load, the message complexity is unbounded because there may be an arbitrary number of messages being sent throughout the network where no one is in the critical section. When system is under high load, the message complexity is 1.</li><li>Response time: when the system is under low load, there could be \(N\) messages times (where \(N\) is the total number of clients). When under high load, the response time would be 1 message time.</li><li>Throughput: the maximum throughput would be 1/(message time + CS time)</li></ul><p>A naive specification for mutex in <a href=https://microsoft.github.io/ivy/language.html>Ivy</a> would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=nf>action</span> <span class=n>grant</span><span class=p>(</span><span class=n>v</span><span class=kt>:</span><span class=n>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=nf>action</span> <span class=n>release</span><span class=p>(</span><span class=n>v</span><span class=kt>:</span><span class=n>id</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>specification</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>var</span> <span class=n>lock</span><span class=p>(</span><span class=kt>X:</span><span class=n>id</span><span class=p>)</span><span class=kt>:</span><span class=n>bool</span>
</span></span><span class=line><span class=cl>    <span class=n>after</span> <span class=n>init</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>lock</span><span class=p>(</span><span class=kt>X</span><span class=p>)</span> <span class=kt>:=</span> <span class=n>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>before</span> <span class=n>grant</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>require</span> <span class=o>~</span><span class=n>lock</span><span class=p>(</span><span class=kt>X</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>lock</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=kt>:=</span> <span class=n>true</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>before</span> <span class=n>release</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>require</span> <span class=n>lock</span><span class=p>(</span><span class=n>v</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>lock</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=kt>:=</span> <span class=n>false</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>To see token ring in action, we use the demo from <a href=http://mcmil.net/wordpress/>Ken</a>&rsquo;s presentation:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=line><span class=cl><span class=o>#</span><span class=n>lang</span> <span class=n>ivy1</span><span class=o>.</span><span class=mi>8</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>include</span> <span class=n>network</span>
</span></span><span class=line><span class=cl><span class=nf>include</span> <span class=n>numbers</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>global</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>type</span> <span class=n>host_id</span> <span class=ow>=</span> <span class=p>{</span><span class=mi>0</span><span class=o>..</span><span class=n>max</span><span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>alias</span> <span class=n>token</span> <span class=ow>=</span> <span class=n>uint</span><span class=p>[</span><span class=mi>1</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=kr>instance</span> <span class=n>net</span> <span class=kt>:</span> <span class=n>tcp</span><span class=o>.</span><span class=n>net</span><span class=p>(</span><span class=n>token</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nf>process</span> <span class=n>host</span><span class=p>(</span><span class=n>self</span><span class=kt>:</span><span class=n>host_id</span><span class=p>)</span> <span class=ow>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kr>import</span> <span class=nn>action</span> <span class=n>grant</span>
</span></span><span class=line><span class=cl>    <span class=n>export</span> <span class=n>action</span> <span class=n>release</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>specification</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>var</span> <span class=n>lock</span> <span class=kt>:</span> <span class=n>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>after</span> <span class=n>init</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>lock</span> <span class=kt>:=</span> <span class=n>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>before</span> <span class=n>grant</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>require</span> <span class=n>forall</span> <span class=kt>X</span><span class=o>.</span> <span class=o>~</span><span class=n>host</span><span class=p>(</span><span class=kt>X</span><span class=p>)</span><span class=o>.</span><span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>lock</span> <span class=kt>:=</span> <span class=n>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>before</span> <span class=n>release</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>require</span> <span class=n>lock</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>lock</span> <span class=kt>:=</span> <span class=n>false</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>implementation</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=kr>instance</span> <span class=n>sock</span> <span class=kt>:</span> <span class=n>net</span><span class=o>.</span><span class=n>socket</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>after</span> <span class=n>init</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=kr>if</span> <span class=n>self</span> <span class=ow>=</span> <span class=mi>0</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=n>pass</span>
</span></span><span class=line><span class=cl>            <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>action</span> <span class=n>pass</span> <span class=ow>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>var</span> <span class=n>tok</span> <span class=kt>:</span> <span class=n>token</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>var</span> <span class=n>next</span> <span class=kt>:=</span> <span class=mi>0</span> <span class=kr>if</span> <span class=n>self</span> <span class=ow>=</span> <span class=n>max</span> <span class=kr>else</span> <span class=n>self</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>            <span class=n>sock</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>host</span><span class=p>(</span><span class=n>next</span><span class=p>)</span><span class=o>.</span><span class=n>sock</span><span class=o>.</span><span class=n>id</span><span class=p>,</span> <span class=n>tok</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>implement</span> <span class=n>sock</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=n>src</span><span class=kt>:</span><span class=n>tcp</span><span class=o>.</span><span class=n>endpoint</span><span class=p>,</span> <span class=n>val</span><span class=kt>:</span><span class=n>token</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>grant</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>implement</span> <span class=n>release</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pass</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>We put the above code into a file called <code>token_ring.ivy</code> and compile it using <code>ivyc token_ring.ivy</code>. Then we launch the program using <code>ivy_launch max=2 token_ring.ivy</code>, which opens three terminal windows.</p><p>If we type in host(1) with <code>host.release</code>, we see in host(2) it outputs <code>host.grant</code>, which seems to show that the token work properly. However, if we type <code>host.release</code> again in host(1), <code>host.grant</code> will show up again in host(2), resulting in multiple tokens getting created, which violates the requirement that there is at most one token in the ring at any given time.</p><p>If we execute <code>ivyc target=test token_ring.ivy && ivy_launch max=2 token_ring.ivy</code>, then we see the token ring work properly. The reason is we have specified the requirement for <code>grant</code> and <code>release</code> (<code>require forall X. ~host(X).lock</code> for <code>grant</code> and <code>require lock</code> for <code>release</code>).</p><p><code>grant</code> is an action <em>imported</em> from the environment, thus we know when grant happens, all clients in the network do not hold a lock. On the other hand, <code>release</code> is an action <em>exported</em> from the system, which means the tester must perform grant given the host has the lock. So the tester won&rsquo;t perform <em>release</em> multiple times like we did above because the tester can not violate the <code>require lock</code> requirement.</p><script src=https://giscus.app/client.js data-repo=BDHU/blog-comments data-repo-id=R_kgDOKZLDLA data-category=Announcements data-category-id=DIC_kwDOKZLDLM4CZrU- data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=noborder_light data-lang=en crossorigin=anonymous async></script></article></main><footer id=footer><p>Â© 2024 Bodun Hu. All rights reserved.
<a href=/blog/index.xml>Subscribe</a></p></footer></body></html>