<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Personal Blog of Bodun (Edward) Hu. CS PhD student at University of Texas at Austin. Operating systems, network, heterogeneity, MLSys, anything system. UTCS">
<link rel="shortcut icon" href=https://www.bodunhu.com/blog/favicon.ico>
<link rel=stylesheet href=/blog/css/style.min.css>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css rel=stylesheet>
<title>Specifying Token Ring for Mutual Exclusion</title>
</head>
<body><header id=banner>
<h2><a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></h2>
<nav>
<ul>
<li>
<a href=/blog/posts/ title=posts>archive</a>
</li><li>
<a href=https://www.bodunhu.com/ title=about>about</a>
</li>
</ul>
</nav>
</header>
<main id=content>
<article>
<header id=post-header>
<h1>Specifying Token Ring for Mutual Exclusion</h1>
<div>
Updated <time>October 17, 2021</time>
</div>
</header><p>Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it&rsquo;s a mechanism of concurrency control allowing exclusive access to some resource (or &ldquo;critical region&rdquo;). Token passing is an algorithm for distributed mutual exclusion (DME) and will be our focus in this post.</p>
<p>DME specifications usually make the following assumptions:</p>
<ul>
<li>Network delivers message in order, e.g. TCP (sometimes)</li>
<li>Every message is eventually delivered (usually)</li>
<li>Messages are never duplicated. Duplication may result granting resources to multiple clients, which is not what mutual exclusion demands (usually)</li>
</ul>
<p>Thing we might want to guarantee for DME specifications are:</p>
<ul>
<li>Mutual exclusion, at most one client is in a critical section (always)</li>
<li>Non-starvation. A requesting client enters critical section eventually (usually)</li>
<li>Non-overtaking. A client cannot enter critical section more than once while another client waits (usually)</li>
</ul>
<p>In addition, we need to analyze DME algorithms' performance metrics, which usually includes:</p>
<ul>
<li>Message complexity, e.g. number of messages sent between clients being served</li>
<li>response time, or time between request and entering CS</li>
<li>Throughput, or rate of processing CS requests</li>
</ul>
<p>Let&rsquo;s take a token ring as an example. In a token ring, a client holds a token and then sends it to the next one after exiting its critical section. When we make assumptions about a token ring, we</p>
<ul>
<li>do not need to have network delivering messages in order, because at any given time in a token, there is at most one message in transit.</li>
<li>ensure every message is eventually delivered. Otherwise, the system won&rsquo;t make progress, and we will not have non-starvation guarantee.</li>
<li>need non-duplication for messages. Otherwise, we violate the fundamental properties of this protocol, or no mutual exclusion.</li>
<li>clients don&rsquo;t spuriously release. This will be clear later when we demonstrate what happens if clients release multiple times.</li>
</ul>
<p><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/token-ring-protocol/token-ring.png#center alt=token-ring></p>
<p>We want to guarantee that</p>
<ul>
<li>mutual exclusion holds.</li>
<li>non-starvation</li>
<li>non-overtaking, because token will get through every client in the network first because repetition happens.</li>
</ul>
<p>To analyze token performance, we use the above performance metrics (message complexity, response time, and throughput)</p>
<ul>
<li>Message complexity: when the system is under low load, the message complexity is unbounded because there may be an arbitrary number of messages being sent throughout the network where no one is in the critical section. When system is under high load, the message complexity is 1.</li>
<li>Response time: when the system is under low load, there could be \(N\) messages times (where \(N\) is the total number of clients). When under high load, the response time would be 1 message time.</li>
<li>Throughput: the maximum throughput would be 1/(message time + CS time)</li>
</ul>
<p>A naive specification for mutex in <a href=https://microsoft.github.io/ivy/language.html>Ivy</a> would be:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#a6e22e>action</span> grant(v<span style=color:#66d9ef>:</span>id)
<span style=color:#a6e22e>action</span> release(v<span style=color:#66d9ef>:</span>id)

<span style=color:#a6e22e>specification</span> {
    var lock(<span style=color:#66d9ef>X:</span>id)<span style=color:#66d9ef>:</span>bool
    after init {
        lock(<span style=color:#66d9ef>X</span>) <span style=color:#66d9ef>:=</span> false;
    }
    
    before grant {
        require <span style=color:#f92672>~</span>lock(<span style=color:#66d9ef>X</span>);
        lock(v) <span style=color:#66d9ef>:=</span> true
    }

    before release {
        require lock(v);
        lock(v) <span style=color:#66d9ef>:=</span> false
    }
}
</code></pre></div><p>To see token ring in action, we use the demo from <a href=http://mcmil.net/wordpress/>Ken</a>&rsquo;s presentation:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#f92672>#</span>lang ivy1<span style=color:#f92672>.</span><span style=color:#ae81ff>8</span>

<span style=color:#a6e22e>include</span> network
<span style=color:#a6e22e>include</span> numbers

<span style=color:#a6e22e>global</span> {
    <span style=color:#66d9ef>type</span> host_id <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>max}
    alias token <span style=color:#f92672>=</span> uint[<span style=color:#ae81ff>1</span>]
    <span style=color:#66d9ef>instance</span> net <span style=color:#66d9ef>:</span> tcp<span style=color:#f92672>.</span>net(token)
}

<span style=color:#a6e22e>process</span> host(self<span style=color:#66d9ef>:</span>host_id) <span style=color:#f92672>=</span> {
    <span style=color:#66d9ef>import</span> action grant
    export action release

    specification {
        var lock <span style=color:#66d9ef>:</span> bool

        after init {
            lock <span style=color:#66d9ef>:=</span> false;
        }

        before grant {
            require forall <span style=color:#66d9ef>X</span><span style=color:#f92672>.</span> <span style=color:#f92672>~</span>host(<span style=color:#66d9ef>X</span>)<span style=color:#f92672>.</span>lock;
            lock <span style=color:#66d9ef>:=</span> true;
        }

        before release {
            require lock;
            lock <span style=color:#66d9ef>:=</span> false;
        }
    }

    implementation {
        <span style=color:#66d9ef>instance</span> sock <span style=color:#66d9ef>:</span> net<span style=color:#f92672>.</span>socket

        after init {
            <span style=color:#66d9ef>if</span> self <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> {
                pass
            }
        }

        action pass <span style=color:#f92672>=</span> {
            var tok <span style=color:#66d9ef>:</span> token;
            var next <span style=color:#66d9ef>:=</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>if</span> self <span style=color:#f92672>=</span> max <span style=color:#66d9ef>else</span> self <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
            sock<span style=color:#f92672>.</span>send(host(next)<span style=color:#f92672>.</span>sock<span style=color:#f92672>.</span>id, tok);
        }

        implement sock<span style=color:#f92672>.</span>recv(src<span style=color:#66d9ef>:</span>tcp<span style=color:#f92672>.</span>endpoint, val<span style=color:#66d9ef>:</span>token) {
            grant;
        }

        implement release {
            pass;
        }
    }
}
</code></pre></div><p>We put the above code into a file called <code>token_ring.ivy</code> and compile it using <code>ivyc token_ring.ivy</code>. Then we launch the program using <code>ivy_launch max=2 token_ring.ivy</code>, which opens three terminal windows.</p>
<p>If we type in host(1) with <code>host.release</code>, we see in host(2) it outputs <code>host.grant</code>, which seems to show that the token work properly. However, if we type <code>host.release</code> again in host(1), <code>host.grant</code> will show up again in host(2), resulting in multiple tokens getting created, which violates the requirement that there is at most one token in the ring at any given time.</p>
<p>If we execute <code>ivyc target=test token_ring.ivy && ivy_launch max=2 token_ring.ivy</code>, then we see the token ring work properly. The reason is we have specified the requirement for <code>grant</code> and <code>release</code> (<code>require forall X. ~host(X).lock</code> for <code>grant</code> and <code>require lock</code> for <code>release</code>).</p>
<p><code>grant</code> is an action <em>imported</em> from the environment, thus we know when grant happens, all clients in the network do not hold a lock. On the other hand, <code>release</code> is an action <em>exported</em> from the system, which means the tester must perform grant given the host has the lock. So the tester won&rsquo;t perform <em>release</em> multiple times like we did above because the tester can not violate the <code>require lock</code> requirement.</p>
<div style=width:100% id=comment>
<script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script>
</div>
</article>
</main><footer id=footer>
<p>Copyright © 2021 Bodun Hu. All rights reserved.</p>
</footer></body>
</html>