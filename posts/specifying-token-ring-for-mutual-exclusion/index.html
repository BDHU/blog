<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content="Liste - https://www.bodunhu.com/blog/">
<title>Specifying Token Ring for Mutual Exclusion | std::bodun::blog</title>
<meta name=description content="Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it's a mechanism of concurrency control allowing exclusive access to some resource (or &#34;critical region&#34;). Token passing is an algorithm for distributed mutual exclusion and will be our focus in this post">
<meta property="og:title" content="Specifying Token Ring for Mutual Exclusion">
<meta property="og:description" content="Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it's a mechanism of concurrency control allowing exclusive access to some resource (or &#34;critical region&#34;). Token passing is an algorithm for distributed mutual exclusion and will be our focus in this post">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.bodunhu.com/blog/posts/specifying-token-ring-for-mutual-exclusion/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-11T00:00:00+00:00">
<meta property="article:modified_time" content="2021-10-17T22:33:08-05:00">
<meta itemprop=name content="Specifying Token Ring for Mutual Exclusion">
<meta itemprop=description content="Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it's a mechanism of concurrency control allowing exclusive access to some resource (or &#34;critical region&#34;). Token passing is an algorithm for distributed mutual exclusion and will be our focus in this post"><meta itemprop=datePublished content="2021-09-11T00:00:00+00:00">
<meta itemprop=dateModified content="2021-10-17T22:33:08-05:00">
<meta itemprop=wordCount content="804">
<meta itemprop=keywords content="distributed-system,ivy,">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Specifying Token Ring for Mutual Exclusion">
<meta name=twitter:description content="Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it's a mechanism of concurrency control allowing exclusive access to some resource (or &#34;critical region&#34;). Token passing is an algorithm for distributed mutual exclusion and will be our focus in this post">
<meta name=twitter:site content="@https://twitter.com/BodunHu">
<link rel=canonical href=https://www.bodunhu.com/blog/posts/specifying-token-ring-for-mutual-exclusion/>
<meta name=monetization content="$twitter.xrptipbot.com/ronaldsvilcins">
<link rel=dns-prefetch href=https://www.google-analytics.com>
<link href=https://www.google-analytics.com rel=preconnect crossorigin>
<link rel=alternate type=application/atom+xml title=std::bodun::blog href=https://www.bodunhu.com/blog/atom.xml>
<link rel=alternate type=application/json title=std::bodun::blog href=https://www.bodunhu.com/blog/feed.json>
<link rel="shortcut icon" href=/blog/images/favicon.ico type=image/x-icon>
<style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:2rem;color:#000}.skip-link{position:absolute;top:-40px;left:0;background:#eee;z-index:100}.skip-link:focus{top:0}h1,h2,h3,h4,h5,strong,b{font-size:inherit;font-weight:600}header{line-height:2;padding-bottom:1.5rem}.link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.time{font-variant-numeric:tabular-nums;white-space:nowrap}blockquote{border-left:5px solid #eee;padding-left:1rem;margin:0}a,a:visited{color:inherit}a:hover,a.heading-link{text-decoration:none}pre{padding:.5rem;overflow:auto;overflow-x:scroll;overflow-wrap:normal}code,pre{font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;font-size:small;background:#eee}code{padding:.1rem;border:none}ul{list-style-type:square}ul,ol{padding-left:1.2rem}.list{line-height:2;list-style-type:none;padding-left:0}.list li{padding-bottom:.1rem}.meta{color:#777}.content{max-width:70ch;margin:0 auto}header{line-height:2;display:flex;justify-content:space-between;padding-bottom:1rem}header a{text-decoration:none}header ul{list-style-type:none;padding:0}header li,header a{display:inline}h2.post{padding-top:.5rem}header ul a:first-child{padding-left:1rem}.nav{height:1px;background:#000;content:'';max-width:10%}.list li{display:flex;align-items:baseline}.list li time{flex:initial}.hr-list{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px dotted #ccc;flex:1 0 1rem}.hr-list-none{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px #ccc;flex:1 0 1rem}.m,hr{border:0;margin:3rem 0}img{max-width:100%;height:auto}</style>
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Specifying Token Ring for Mutual Exclusion","headline":"Specifying Token Ring for Mutual Exclusion","alternativeHeadline":"","description":"Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it\u0027s a mechanism of concurrency control allowing exclusive access to some resource (or \u0022critical region\u0022). Token passing is an algorithm for distributed mutual exclusion and will be our focus in this post","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.bodunhu.com\/blog\/posts\/specifying-token-ring-for-mutual-exclusion\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"std::bodun::blog","copyrightYear":"2021","dateCreated":"2021-09-11T00:00:00.00Z","datePublished":"2021-09-11T00:00:00.00Z","dateModified":"2021-10-17T22:33:08.00Z","publisher":{"@type":"Organization","name":"std::bodun::blog","url":"https://www.bodunhu.com/blog/","logo":{"@type":"ImageObject","url":"https:\/\/www.bodunhu.com\/blog\/","width":"32","height":"32"}},"image":"https://www.bodunhu.com/blog/","url":"https:\/\/www.bodunhu.com\/blog\/posts\/specifying-token-ring-for-mutual-exclusion\/","wordCount":"804","genre":["distributed-system","ivy"],"keywords":["distributed-system","ivy"]}</script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
</head>
<body>
<a class=skip-link href=#main>Skip to main</a>
<main id=main>
<div class=content>
<header>
<p style=padding:0;margin:0><a href=/blog/><b>std::bodun::blog</b></a></p>
<ul style=padding:0;margin:0>
<li><a href=https://www.bodunhu.com/>About</a></li>
</ul>
</header>
<hr class=hr-list style=padding:0;margin:0>
<h2 class=post>Specifying Token Ring for Mutual Exclusion</h2>
<p>Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it&rsquo;s a mechanism of concurrency control allowing exclusive access to some resource (or &ldquo;critical region&rdquo;). Token passing is an algorithm for distributed mutual exclusion (DME) and will be our focus in this post.</p>
<p>DME specifications usually make the following assumptions:</p>
<ul>
<li>Network delivers message in order, e.g. TCP (sometimes)</li>
<li>Every message is eventually delivered (usually)</li>
<li>Messages are never duplicated. Duplication may result granting resources to multiple clients, which is not what mutual exclusion demands (usually)</li>
</ul>
<p>Thing we might want to guarantee for DME specifications are:</p>
<ul>
<li>Mutual exclusion, at most one client is in a critical section (always)</li>
<li>Non-starvation. A requesting client enters critical section eventually (usually)</li>
<li>Non-overtaking. A client cannot enter critical section more than once while another client waits (usually)</li>
</ul>
<p>In addition, we need to analyze DME algorithms' performance metrics, which usually includes:</p>
<ul>
<li>Message complexity, e.g. number of messages sent between clients being served</li>
<li>response time, or time between request and entering CS</li>
<li>Throughput, or rate of processing CS requests</li>
</ul>
<p>Let&rsquo;s take a token ring as an example. In a token ring, a client holds a token and then sends it to the next one after exiting its critical section. When we make assumptions about a token ring, we</p>
<ul>
<li>do not need to have network delivering messages in order, because at any given time in a token, there is at most one message in transit.</li>
<li>ensure every message is eventually delivered. Otherwise, the system won&rsquo;t make progress, and we will not have non-starvation guarantee.</li>
<li>need non-duplication for messages. Otherwise, we violate the fundamental properties of this protocol, or no mutual exclusion.</li>
<li>clients don&rsquo;t spuriously release. This will be clear later when we demonstrate what happens if clients release multiple times.</li>
</ul>
<p>
<p class=markdown-image style=text-align:center>
<img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/token-ring-protocol/token-ring.png#center alt=token-ring class=center loading=lazy decoding=async>
</p></p>
<p>We want to guarantee that</p>
<ul>
<li>mutual exclusion holds.</li>
<li>non-starvation</li>
<li>non-overtaking, because token will get through every client in the network first because repetition happens.</li>
</ul>
<p>To analyze token performance, we use the above performance metrics (message complexity, response time, and throughput)</p>
<ul>
<li>Message complexity: when the system is under low load, the message complexity is unbounded because there may be an arbitrary number of messages being sent throughout the network where no one is in the critical section. When system is under high load, the message complexity is 1.</li>
<li>Response time: when the system is under low load, there could be \(N\) messages times (where \(N\) is the total number of clients). When under high load, the response time would be 1 message time.</li>
<li>Throughput: the maximum throughput would be 1/(message time + CS time)</li>
</ul>
<p>A naive specification for mutex in <a href=https://microsoft.github.io/ivy/language.html>Ivy</a> would be:</p>
<pre><code class=language-haskell>action grant(v:id)
action release(v:id)

specification {
    var lock(X:id):bool
    after init {
        lock(X) := false;
    }
    
    before grant {
        require ~lock(X);
        lock(v) := true
    }

    before release {
        require lock(v);
        lock(v) := false
    }
}
</code></pre>
<p>To see token ring in action, we use the demo from <a href=http://mcmil.net/wordpress/>Ken</a>&rsquo;s presentation:</p>
<pre><code class=language-haskell>#lang ivy1.8

include network
include numbers

global {
    type host_id = {0..max}
    alias token = uint[1]
    instance net : tcp.net(token)
}

process host(self:host_id) = {
    import action grant
    export action release

    specification {
        var lock : bool

        after init {
            lock := false;
        }

        before grant {
            require forall X. ~host(X).lock;
            lock := true;
        }

        before release {
            require lock;
            lock := false;
        }
    }

    implementation {
        instance sock : net.socket

        after init {
            if self = 0 {
                pass
            }
        }

        action pass = {
            var tok : token;
            var next := 0 if self = max else self + 1;
            sock.send(host(next).sock.id, tok);
        }

        implement sock.recv(src:tcp.endpoint, val:token) {
            grant;
        }

        implement release {
            pass;
        }
    }
}
</code></pre>
<p>We put the above code into a file called <code>token_ring.ivy</code> and compile it using <code>ivyc token_ring.ivy</code>. Then we launch the program using <code>ivy_launch max=2 token_ring.ivy</code>, which opens three terminal windows.</p>
<p>If we type in host(1) with <code>host.release</code>, we see in host(2) it outputs <code>host.grant</code>, which seems to show that the token work properly. However, if we type <code>host.release</code> again in host(1), <code>host.grant</code> will show up again in host(2), resulting in multiple tokens getting created, which violates the requirement that there is at most one token in the ring at any given time.</p>
<p>If we execute <code>ivyc target=test token_ring.ivy && ivy_launch max=2 token_ring.ivy</code>, then we see the token ring work properly. The reason is we have specified the requirement for <code>grant</code> and <code>release</code> (<code>require forall X. ~host(X).lock</code> for <code>grant</code> and <code>require lock</code> for <code>release</code>).</p>
<p><code>grant</code> is an action <em>imported</em> from the environment, thus we know when grant happens, all clients in the network do not hold a lock. On the other hand, <code>release</code> is an action <em>exported</em> from the system, which means the tester must perform grant given the host has the lock. So the tester won&rsquo;t perform <em>release</em> multiple times like we did above because the tester can not violate the <code>require lock</code> requirement.</p>
<hr class=hr-list>
<footer>
<p>© 2016-2021 <a href=https://www.bodunhu.com/>Bodun Hu</a>. All rights reserved. <a href=/blog/index.xml>Subscribe</a></p>
</footer>
</div>
</main>
</body>
</html>