<!doctype html><html lang=en-us><head><meta http-equiv=x-clacks-overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Specifying Token Ring for Mutual Exclusion | std::bodun::blog</title><meta name=title content="Specifying Token Ring for Mutual Exclusion"><meta name=description content="Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it's a mechanism of concurrency control allowing exclusive access to some resource (or &#34;critical region&#34;). Token passing is an algorithm for distributed mutual exclusion and will be our focus in this post"><meta name=keywords content="distributed-system,ivy,"><meta property="og:title" content="Specifying Token Ring for Mutual Exclusion"><meta property="og:description" content="Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it's a mechanism of concurrency control allowing exclusive access to some resource (or &#34;critical region&#34;). Token passing is an algorithm for distributed mutual exclusion and will be our focus in this post"><meta property="og:type" content="article"><meta property="og:url" content="https://www.bodunhu.com/blog/posts/specifying-token-ring-for-mutual-exclusion/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-09-11T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-14T18:31:56-06:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Specifying Token Ring for Mutual Exclusion"><meta name=twitter:description content="Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it's a mechanism of concurrency control allowing exclusive access to some resource (or &#34;critical region&#34;). Token passing is an algorithm for distributed mutual exclusion and will be our focus in this post"><meta name=twitter:site content="@https://twitter.com/BodunHu"><meta itemprop=name content="Specifying Token Ring for Mutual Exclusion"><meta itemprop=description content="Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it's a mechanism of concurrency control allowing exclusive access to some resource (or &#34;critical region&#34;). Token passing is an algorithm for distributed mutual exclusion and will be our focus in this post"><meta itemprop=datePublished content="2021-09-11T00:00:00+00:00"><meta itemprop=dateModified content="2022-02-14T18:31:56-06:00"><meta itemprop=wordCount content="804"><meta itemprop=keywords content="distributed-system,ivy,"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style></head><body><header><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><a href=/blog/ class=title><h2>std::bodun::blog</h2></a><nav><a href=/blog/>Home</a>
<a href=/blog/posts/>Archive</a>
<a href=https://www.bodunhu.com/>About</a></nav></header><main><h1>Specifying Token Ring for Mutual Exclusion</h1><p><i><time datetime=2021-09-11 pubdate>11 Sep, 2021</time></i></p><content><p>Mutual exclusion is a common term appearing frequently in computer sciences. In essence, it&rsquo;s a mechanism of concurrency control allowing exclusive access to some resource (or &ldquo;critical region&rdquo;). Token passing is an algorithm for distributed mutual exclusion (DME) and will be our focus in this post.</p><p>DME specifications usually make the following assumptions:</p><ul><li>Network delivers message in order, e.g. TCP (sometimes)</li><li>Every message is eventually delivered (usually)</li><li>Messages are never duplicated. Duplication may result granting resources to multiple clients, which is not what mutual exclusion demands (usually)</li></ul><p>Thing we might want to guarantee for DME specifications are:</p><ul><li>Mutual exclusion, at most one client is in a critical section (always)</li><li>Non-starvation. A requesting client enters critical section eventually (usually)</li><li>Non-overtaking. A client cannot enter critical section more than once while another client waits (usually)</li></ul><p>In addition, we need to analyze DME algorithms&rsquo; performance metrics, which usually includes:</p><ul><li>Message complexity, e.g. number of messages sent between clients being served</li><li>response time, or time between request and entering CS</li><li>Throughput, or rate of processing CS requests</li></ul><p>Let&rsquo;s take a token ring as an example. In a token ring, a client holds a token and then sends it to the next one after exiting its critical section. When we make assumptions about a token ring, we</p><ul><li>do not need to have network delivering messages in order, because at any given time in a token, there is at most one message in transit.</li><li>ensure every message is eventually delivered. Otherwise, the system won&rsquo;t make progress, and we will not have non-starvation guarantee.</li><li>need non-duplication for messages. Otherwise, we violate the fundamental properties of this protocol, or no mutual exclusion.</li><li>clients don&rsquo;t spuriously release. This will be clear later when we demonstrate what happens if clients release multiple times.</li></ul><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_Pics/posts/token-ring-protocol/token-ring.png#center alt=token-ring></p><p>We want to guarantee that</p><ul><li>mutual exclusion holds.</li><li>non-starvation</li><li>non-overtaking, because token will get through every client in the network first because repetition happens.</li></ul><p>To analyze token performance, we use the above performance metrics (message complexity, response time, and throughput)</p><ul><li>Message complexity: when the system is under low load, the message complexity is unbounded because there may be an arbitrary number of messages being sent throughout the network where no one is in the critical section. When system is under high load, the message complexity is 1.</li><li>Response time: when the system is under low load, there could be \(N\) messages times (where \(N\) is the total number of clients). When under high load, the response time would be 1 message time.</li><li>Throughput: the maximum throughput would be 1/(message time + CS time)</li></ul><p>A naive specification for mutex in <a href=https://microsoft.github.io/ivy/language.html>Ivy</a> would be:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>action</span> grant(v<span style=color:#66d9ef>:</span>id)
</span></span><span style=display:flex><span><span style=color:#a6e22e>action</span> release(v<span style=color:#66d9ef>:</span>id)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>specification</span> {
</span></span><span style=display:flex><span>    var lock(<span style=color:#66d9ef>X:</span>id)<span style=color:#66d9ef>:</span>bool
</span></span><span style=display:flex><span>    after init {
</span></span><span style=display:flex><span>        lock(<span style=color:#66d9ef>X</span>) <span style=color:#66d9ef>:=</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    before grant {
</span></span><span style=display:flex><span>        require <span style=color:#f92672>~</span>lock(<span style=color:#66d9ef>X</span>);
</span></span><span style=display:flex><span>        lock(v) <span style=color:#66d9ef>:=</span> true
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    before release {
</span></span><span style=display:flex><span>        require lock(v);
</span></span><span style=display:flex><span>        lock(v) <span style=color:#66d9ef>:=</span> false
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To see token ring in action, we use the demo from <a href=http://mcmil.net/wordpress/>Ken</a>&rsquo;s presentation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#f92672>#</span>lang ivy1<span style=color:#f92672>.</span><span style=color:#ae81ff>8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>include</span> network
</span></span><span style=display:flex><span><span style=color:#a6e22e>include</span> numbers
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>global</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>type</span> host_id <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>max}
</span></span><span style=display:flex><span>    alias token <span style=color:#f92672>=</span> uint[<span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>instance</span> net <span style=color:#66d9ef>:</span> tcp<span style=color:#f92672>.</span>net(token)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>process</span> host(self<span style=color:#66d9ef>:</span>host_id) <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>import</span> action grant
</span></span><span style=display:flex><span>    export action release
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    specification {
</span></span><span style=display:flex><span>        var lock <span style=color:#66d9ef>:</span> bool
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        after init {
</span></span><span style=display:flex><span>            lock <span style=color:#66d9ef>:=</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        before grant {
</span></span><span style=display:flex><span>            require forall <span style=color:#66d9ef>X</span><span style=color:#f92672>.</span> <span style=color:#f92672>~</span>host(<span style=color:#66d9ef>X</span>)<span style=color:#f92672>.</span>lock;
</span></span><span style=display:flex><span>            lock <span style=color:#66d9ef>:=</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        before release {
</span></span><span style=display:flex><span>            require lock;
</span></span><span style=display:flex><span>            lock <span style=color:#66d9ef>:=</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    implementation {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>instance</span> sock <span style=color:#66d9ef>:</span> net<span style=color:#f92672>.</span>socket
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        after init {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                pass
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        action pass <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>            var tok <span style=color:#66d9ef>:</span> token;
</span></span><span style=display:flex><span>            var next <span style=color:#66d9ef>:=</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>if</span> self <span style=color:#f92672>=</span> max <span style=color:#66d9ef>else</span> self <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            sock<span style=color:#f92672>.</span>send(host(next)<span style=color:#f92672>.</span>sock<span style=color:#f92672>.</span>id, tok);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        implement sock<span style=color:#f92672>.</span>recv(src<span style=color:#66d9ef>:</span>tcp<span style=color:#f92672>.</span>endpoint, val<span style=color:#66d9ef>:</span>token) {
</span></span><span style=display:flex><span>            grant;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        implement release {
</span></span><span style=display:flex><span>            pass;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We put the above code into a file called <code>token_ring.ivy</code> and compile it using <code>ivyc token_ring.ivy</code>. Then we launch the program using <code>ivy_launch max=2 token_ring.ivy</code>, which opens three terminal windows.</p><p>If we type in host(1) with <code>host.release</code>, we see in host(2) it outputs <code>host.grant</code>, which seems to show that the token work properly. However, if we type <code>host.release</code> again in host(1), <code>host.grant</code> will show up again in host(2), resulting in multiple tokens getting created, which violates the requirement that there is at most one token in the ring at any given time.</p><p>If we execute <code>ivyc target=test token_ring.ivy && ivy_launch max=2 token_ring.ivy</code>, then we see the token ring work properly. The reason is we have specified the requirement for <code>grant</code> and <code>release</code> (<code>require forall X. ~host(X).lock</code> for <code>grant</code> and <code>require lock</code> for <code>release</code>).</p><p><code>grant</code> is an action <em>imported</em> from the environment, thus we know when grant happens, all clients in the network do not hold a lock. On the other hand, <code>release</code> is an action <em>exported</em> from the system, which means the tester must perform grant given the host has the lock. So the tester won&rsquo;t perform <em>release</em> multiple times like we did above because the tester can not violate the <code>require lock</code> requirement.</p></content><p></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>