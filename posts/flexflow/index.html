<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="PhD student at University of Texas at Austin ðŸ¤˜. Doing systems for ML."><link rel="shortcut icon" href=https://www.bodunhu.com/blog/favicon.ico><link rel=stylesheet href=/blog/css/style.min.css><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZLK2GHB055"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZLK2GHB055")}</script><link rel=canonical href=https://www.bodunhu.com/blog/posts/flexflow/><title>std::bodun::blog</title></head><body><header id=banner><span><a href=https://www.bodunhu.com/blog/>blog</a> | <a href=https://www.bodunhu.com/blog//posts>posts</a> | <a href=https://www.bodunhu.com/>about</a></span></header><main id=content><article><header id=post-header><h2>FlexFlow</h2><div><time>May 1, 2022</time></div></header><p><a href=https://flexflow.ai/>FlexFlow</a> is a deep learning framework that discovers a fast parallelization strategy for distributed DNN training. It uses <em>SOAP</em> (Sample-Operation-Attribute-Parameter) search space of parallelization strategies. in short, FlexFlow automates the parallelization of model training.</p><p>The four elements in <em>SOAP</em> search space represent something that can be sliced into smaller chunks. For example, <em>sample</em> and <em>parameter</em> can be thought of as slicing training data and model parameters. <em>Operation</em> describes how operations (e.g. <code>matmul</code>, <code>add</code>, etc.) can be parallelized. <em>Attribute</em> further describes how to partition a sample.</p><h2 id=problem-inputs>Problem Inputs</h2><p>Since FlexFlow is about searching for solutions, the framework is given two inputs: an <strong>operator graph</strong> \(\mathcal{G}\), which include all operations and state in a DNN model, and a <strong>device topology</strong> \(\mathcal{D}\). Both are described as graphs.</p><p>Each node \(o_i \in \mathcal{G}\) is an operation (e.g. <code>matmul</code>). Each edge \(o_i, o_j \in \mathcal{G}\) is a tensor. In contrast, each node \(d_i \in \mathcal{D}\) is a computing device, and edge edge \((d_i, d_j) \in \mathcal{D}\) is hardware connection (e.g. NVLink, network link, etc.), Each edge are also labeled with its bandwidth and latency.</p><p>The FlexFlow optimizer uses the operator graph \(\mathcal{G}\) and the device topology graph \(\mathcal{D}\) to generate a discovered strategy to a distributed runtime.</p><h2 id=how-to-search-for-parallelization-strategies>How to search for parallelization strategies</h2><p>Ultimately, FlexFlow is trying to achieve two things: find parallelization configuration on the operator graph \(\mathcal{G}\), and map the output the device topology \(\mathcal{D}\).</p><p>For an operation \(o_i\), it is given <em>parallelizable dimensions</em> \(\mathcal{P}_i\), which is the set of all divisible dimensions in its <em>output</em> tensor. The <a href=https://arxiv.org/pdf/1807.05358.pdf>paper</a> provides a 1D convolution example:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_pics/posts/flexflow/parallelization.png alt=parallelization></p><p>For data parallelism, we can see the input data is splitted into smaller micro-batches. In model parallelism, the batch dimension remains the same, while the model is splitted and handles the same input data. The intuition is for a given tensor, there exists many ways to divide it.</p><p>There are many dimensions in \(\mathcal{P}_i\), each single parallelization configuration is denoted as \(c_i\). Therefore, the product of all \(c_i\), represented as \(|c_i|\), is the total number of divided output tensors.</p><p>Each parallelization configuration \(c_i\) partitions the operation \(o\) into \(|c_i|\) <em>tasks</em>. (denoted as \(t_{i:1}&mldr;, t_{i|c_i|}\)). Each task represents a divided operation and is assigned to a device. The paper claims that, given the output tensor of a task and its operation type, we can infer the input tensors to execute each task. It gives an example of dividing the <code>matmul</code> operation:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_pics/posts/flexflow/matmul.png alt=divided-matmul></p><p>Given the output tensor is splitted across its sample (batch) dimension and feature dimension, and the task type is <code>matmul</code>, we can use these information to infer the input tensors \(X\) and \(W\).</p><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>let isDark=window.matchMedia("(prefers-color-scheme: dark)").matches,mermaidTheme="default",mermaidConfig={theme:mermaidTheme,logLevel:"fatal",securityLevel:"strict",startOnLoad:!0,arrowMarkerAbsolute:!1,er:{diagramPadding:20,layoutDirection:"TB",minEntityWidth:100,minEntityHeight:75,entityPadding:15,stroke:"gray",fill:"honeydew",fontSize:12,useMaxWidth:!0},flowchart:{diagramPadding:8,htmlLabels:!0,curve:"basis"},sequence:{diagramMarginX:50,diagramMarginY:10,actorMargin:50,width:150,height:65,boxMargin:10,boxTextMargin:5,noteMargin:10,messageMargin:35,messageAlign:"center",mirrorActors:!0,bottomMarginAdj:1,useMaxWidth:!0,rightAngles:!1,showSequenceNumbers:!1},gantt:{titleTopMargin:25,barHeight:20,barGap:4,topPadding:50,leftPadding:75,gridLineStartPadding:35,fontSize:11,fontFamily:'"Open-Sans", "sans-serif"',numberSectionStyles:4,axisFormat:"%Y-%m-%d",topAxis:!1}};mermaid.initialize(mermaidConfig)</script><center><div class=mermaid>graph TD;
Operator-Graph-->Parallelization-Strategy;
Device-Topology-->Parallelization-Strategy;</div></center><p>The parallelization configurations \(c_i\) for each operation \(o_i\) is combined in a final configuration \(\mathcal{S}\).</p><h2 id=building-task-graph>Building Task Graph</h2><p>Now we have the operation graph \(\mathcal{G}\), the device topology graph \(\mathcal{D}\), and the parallelization strategy \(\mathcal{S}\), we can construct the <em>task graph</em>.</p><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>let isDark=window.matchMedia("(prefers-color-scheme: dark)").matches,mermaidTheme="default",mermaidConfig={theme:mermaidTheme,logLevel:"fatal",securityLevel:"strict",startOnLoad:!0,arrowMarkerAbsolute:!1,er:{diagramPadding:20,layoutDirection:"TB",minEntityWidth:100,minEntityHeight:75,entityPadding:15,stroke:"gray",fill:"honeydew",fontSize:12,useMaxWidth:!0},flowchart:{diagramPadding:8,htmlLabels:!0,curve:"basis"},sequence:{diagramMarginX:50,diagramMarginY:10,actorMargin:50,width:150,height:65,boxMargin:10,boxTextMargin:5,noteMargin:10,messageMargin:35,messageAlign:"center",mirrorActors:!0,bottomMarginAdj:1,useMaxWidth:!0,rightAngles:!1,showSequenceNumbers:!1},gantt:{titleTopMargin:25,barHeight:20,barGap:4,topPadding:50,leftPadding:75,gridLineStartPadding:35,fontSize:11,fontFamily:'"Open-Sans", "sans-serif"',numberSectionStyles:4,axisFormat:"%Y-%m-%d",topAxis:!1}};mermaid.initialize(mermaidConfig)</script><center><div class=mermaid>graph TD;
Operator-Graph-->Task-Graph;
Device-Topology-->Task-Graph;
Parallelization-Strategy-->Task-Graph;</div></center><p>In essence, the task graph specifies the dependencies between each computation and communication task. The task graph is denoted as \(\mathcal{T} = (\mathcal{T}_N , \mathcal{T}_E)\). If two tasks are assigned to the same computation device (e.g. same GPU), no communication task is required. Otherwise, we add a communication task to \(\mathcal{T}_E\). For example, given a operator graph with a set of configurations \(\mathcal{S}\):</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_pics/posts/flexflow/operator-graph.png alt=operator-graph></p><p>The task graph will reflect the logical dependency between each task:</p><p><img src=https://cdn.jsdelivr.net/gh/BDHU/Page_pics/posts/flexflow/task-graph.png alt=task-graph></p><p>Each computation task is also marked with its average execution time <code>exeTime</code> (from running on the real device multiple times). A communication task&rsquo;s <code>exeTime</code> is calculated by dividing the tensor size by the bandwidth.</p><h2 id=use-simulation-to-estimate-execution-overhead>Use Simulation to Estimate Execution Overhead</h2><p>Now that we have the task graph with all dependencies specified, it&rsquo;s time to evaluate (or simulate) the execution time of the whole task graph.</p><p>In essence, we know how a model is <strong>partitioned</strong> and <strong>placed</strong> in a cluster, we need to figure out how to <strong>schedule</strong> the execution.</p><p>The simplest way to simulate the task graph execution is as follows:</p><ul><li>Given a task graph, if there are some task nodes that doesn&rsquo;t have an input/s, meaning such tasks represent the beginning layers of a neural network, then they are put into a ready queue waiting to be executed.</li><li>Next, we dequeue the task from the ready queue based on the ready time (the time it is enqueued), or the previously executed task&rsquo;s finish time.</li><li>After this task finishes (simulated) execution, we look at other tasks that depend on this just-finished-execution task, if the other tasks&rsquo; dependees all finish execution, then this task can be put into the ready queue.</li></ul><p>However, we haven&rsquo;t seen how the task graph \(\mathcal{T}\) might change once we update the configuration of an operation node \(o_i\). FlexFlow only propose a new parallelization strategy by change the configuration of a single operation \(o_i\) at a time. Therefore, whenever we generate a new configuration for an operator, we only need to re-simulate task involved in the portion of the execution timeline that changes. It means we can generate a new task graph from a previous task graph, thus speeding up the simulation process.</p><h2 id=execution-optimizer>Execution Optimizer</h2><p>Previously, we assumed the parallelization strategy is generated through some black box function. In fact, the <em>execution optimizer</em> is in charging of taking an operator graph and a device topology as inputs to find an efficient parallelization strategy.</p><p>In fact, the optimizer uses Markov chain Monte Carlo (MCMC) method to sample generated parallelization configurations. It uses the simulation cost as an oracle so that the proposed new configuration will be more likely to be sampled from the ones with less simulation overhead. This method is very greedy but the author argue it can potentially escape from local minimum.</p><script src=https://giscus.app/client.js data-repo=BDHU/blog-comments data-repo-id=R_kgDOKZLDLA data-category=Announcements data-category-id=DIC_kwDOKZLDLM4CZrU- data-mapping=pathname data-strict=0 data-reactions-enabled=0 data-emit-metadata=0 data-input-position=bottom data-theme=light data-lang=en crossorigin=anonymous async></script></article></main><footer id=footer><p>Â© 2025 Bodun Hu â€¢
<a href=/blog/index.xml>RSS</a></p></footer></body></html>