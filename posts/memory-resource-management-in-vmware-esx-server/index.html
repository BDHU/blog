<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content="Liste - https://www.bodunhu.com/blog/">
<title>Memory Resource Management in VMware ESX Server | std::bodun::blog</title>
<meta name=description content="Personal Blog of Bodun (Edward) Hu. CS PhD student at University of Texas at Austin. Operating systems, network, heterogeneity, MLSys, anything system. UTCS">
<meta property="og:title" content="Memory Resource Management in VMware ESX Server">
<meta property="og:description" content="VMWare ESX Server is a software layer designed to multiplex hardware resources among virtual machines running unmodified commodity operating systems. ESX Server, different to VMware Workstation, is a type 1 hypervisor, which means it runs directly on bare metal. ESX Server focuses on running guest VMs without modifying the guest OSes at all, which is challenging.
 Memory Virtualization is done by interposing an extra abstraction layer between a physical address from the VM&rsquo;s point of view, and a machine address which represents the actual hardware memory.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.bodunhu.com/blog/posts/memory-resource-management-in-vmware-esx-server/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2020-09-21T00:00:00+00:00">
<meta property="article:modified_time" content="2021-08-06T22:15:10-05:00">
<meta itemprop=name content="Memory Resource Management in VMware ESX Server">
<meta itemprop=description content="VMWare ESX Server is a software layer designed to multiplex hardware resources among virtual machines running unmodified commodity operating systems. ESX Server, different to VMware Workstation, is a type 1 hypervisor, which means it runs directly on bare metal. ESX Server focuses on running guest VMs without modifying the guest OSes at all, which is challenging.
 Memory Virtualization is done by interposing an extra abstraction layer between a physical address from the VM&rsquo;s point of view, and a machine address which represents the actual hardware memory."><meta itemprop=datePublished content="2020-09-21T00:00:00+00:00">
<meta itemprop=dateModified content="2021-08-06T22:15:10-05:00">
<meta itemprop=wordCount content="577">
<meta itemprop=keywords content="os,virtualization,mm,">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Memory Resource Management in VMware ESX Server">
<meta name=twitter:description content="VMWare ESX Server is a software layer designed to multiplex hardware resources among virtual machines running unmodified commodity operating systems. ESX Server, different to VMware Workstation, is a type 1 hypervisor, which means it runs directly on bare metal. ESX Server focuses on running guest VMs without modifying the guest OSes at all, which is challenging.
 Memory Virtualization is done by interposing an extra abstraction layer between a physical address from the VM&rsquo;s point of view, and a machine address which represents the actual hardware memory.">
<meta name=twitter:site content="@https://twitter.com/BodunHu">
<link rel=canonical href=https://www.bodunhu.com/blog/posts/memory-resource-management-in-vmware-esx-server/>
<meta name=monetization content="$twitter.xrptipbot.com/ronaldsvilcins">
<link rel=dns-prefetch href=https://www.google-analytics.com>
<link href=https://www.google-analytics.com rel=preconnect crossorigin>
<link rel=alternate type=application/atom+xml title=std::bodun::blog href=https://www.bodunhu.com/blog/atom.xml>
<link rel=alternate type=application/json title=std::bodun::blog href=https://www.bodunhu.com/blog/feed.json>
<link rel="shortcut icon" href=/blog/images/favicon.ico type=image/x-icon>
<style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:2rem;color:#000}.skip-link{position:absolute;top:-40px;left:0;background:#eee;z-index:100}.skip-link:focus{top:0}h1,h2,h3,h4,h5,strong,b{font-size:inherit;font-weight:600}header{line-height:2;padding-bottom:1.5rem}.link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.time{font-variant-numeric:tabular-nums;white-space:nowrap}blockquote{border-left:5px solid #eee;padding-left:1rem;margin:0}a,a:visited{color:inherit}a:hover,a.heading-link{text-decoration:none}pre{padding:.5rem;overflow:auto;overflow-x:scroll;overflow-wrap:normal}code,pre{font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;font-size:small;background:#eee}code{padding:.1rem;border:none}ul{list-style-type:square}ul,ol{padding-left:1.2rem}.list{line-height:2;list-style-type:none;padding-left:0}.list li{padding-bottom:.1rem}.meta{color:#777}.content{max-width:70ch;margin:0 auto}header{line-height:2;display:flex;justify-content:space-between;padding-bottom:1rem}header a{text-decoration:none}header ul{list-style-type:none;padding:0}header li,header a{display:inline}h2.post{padding-top:.5rem}header ul a:first-child{padding-left:1rem}.nav{height:1px;background:#000;content:'';max-width:10%}.list li{display:flex;align-items:baseline}.list li time{flex:initial}.hr-list{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px dotted #ccc;flex:1 0 1rem}.hr-list-none{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px #ccc;flex:1 0 1rem}.m,hr{border:0;margin:3rem 0}img{max-width:100%;height:auto}</style>
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Memory Resource Management in VMware ESX Server","headline":"Memory Resource Management in VMware ESX Server","alternativeHeadline":"","description":"VMWare ESX Server is a software layer designed to multiplex hardware resources among virtual machines running unmodified commodity operating systems. ESX Server, different to VMware Workstation, is a type 1 hypervisor, which means it runs directly on bare metal. ESX Server focuses on running guest VMs without modifying the guest OSes at all, which is challenging.\n Memory Virtualization is done by interposing an extra abstraction layer between a physical address from the VM\u0026rsquo;s point of view, and a machine address which represents the actual hardware memory.","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.bodunhu.com\/blog\/posts\/memory-resource-management-in-vmware-esx-server\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"std::bodun::blog","copyrightYear":"2020","dateCreated":"2020-09-21T00:00:00.00Z","datePublished":"2020-09-21T00:00:00.00Z","dateModified":"2021-08-06T22:15:10.00Z","publisher":{"@type":"Organization","name":"std::bodun::blog","url":"https://www.bodunhu.com/blog/","logo":{"@type":"ImageObject","url":"https:\/\/www.bodunhu.com\/blog\/","width":"32","height":"32"}},"image":"https://www.bodunhu.com/blog/","url":"https:\/\/www.bodunhu.com\/blog\/posts\/memory-resource-management-in-vmware-esx-server\/","wordCount":"577","genre":["os","virtualization","mm"],"keywords":["os","virtualization","mm"]}</script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
</head>
<body>
<a class=skip-link href=#main>Skip to main</a>
<main id=main>
<div class=content>
<header>
<p style=padding:0;margin:0><a href=/blog/><b>std::bodun::blog</b></a></p>
<ul style=padding:0;margin:0>
<li><a href=https://www.bodunhu.com/>About</a></li>
</ul>
</header>
<hr class=hr-list style=padding:0;margin:0>
<h2 class=post>Memory Resource Management in VMware ESX Server</h2>
<p><a href=https://www.vmware.com/products/esxi-and-esx.html>VMWare ESX Server</a> is a software layer designed to multiplex hardware resources among virtual machines running unmodified commodity operating systems. ESX Server, different to <a href=https://www.vmware.com/products/workstation-pro.html>VMware Workstation</a>, is a type 1 hypervisor, which means it runs directly on bare metal. ESX Server focuses on running guest VMs without modifying the guest OSes at all, which is challenging.</p>
<blockquote>
<p>Memory Virtualization is done by interposing an extra abstraction layer between a <code>physical address</code> from the VM&rsquo;s point of view, and a <code>machine address</code> which represents the actual hardware memory. ESX Server maintains a <em>pmap</em> data structure for each VM to translate PPMs to MPNs. A separate <em>shadow page table</em>, consistent with the physical-to-machine mappings, is used to map virtual-to-machine page mappings. This avoids additional overheads as the hardware TLB will cache direct virtual-to-machine address translations read from the shadow page table.</p>
</blockquote>
<h2 id=key-features>Key features <a href=#key-features class="hash g">#</a></h2>
<p>
<p class=markdown-image style=text-align:center>
<img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/ESXServer/ballooning.png alt=vmware-esx-server-memory class=center loading=lazy decoding=async>
</p></p>
<p><strong>Ballooning</strong> is a technique used by the server to achieve memory reclamation. As its name suggests, the hypervisor inflates the balloon by instructing the balloon driver module to allocate pinned physical pages and deflates it by instructing it to deallocate previously-allocated pages. The idea behind this technique is that the hypervisor is unaware of the specific usage patterns of policies of its guests, therefore the making page replacement decisions is best done in the guest VM. When the hypervisor over commits memory, it needs some way to claim memories from the VMs. By consuming some of the memory that the guest OS believes is physically present in the virtual machine. The guest OS will then swap memory to disk reducing the load on the host&rsquo;s physical memory. The host will them reallocate that memory to other VMs. A details description of ballooning can be found in this <a href=https://www.vladan.fr/what-is-vmware-memory-ballooning/>post</a>.</p>
<p><a href=https://www.vmware.com/pdf/usenix_resource_mgmt.pdf>
<p class=markdown-image style=text-align:center>
<img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/ESXServer/pghash.png#center alt=vmware-esx-server-page-coloring class=center loading=lazy decoding=async>
</p></a></p>
<blockquote>
<p>Page Coloring can be used to reduce cache misses or partition resources. But it might complicates memory management, especially with the presence of huge pages. Because coloring enforces ownership, thus might result in distinct L2 cache entries.</p>
</blockquote>
<p><strong>Sharing memory</strong> is achieved by comparing the content of each page, since modifying guest operating system internals is not possible. Because comparing each page would be \(O(n^2)\), hashing is used to identify pages to make the progress more efficiently. By letting VMs share pages based the contents, the host can potentially save spaces dramatically. For example, the presence of zero pages is a great opportunity for page sharing by mapping one zero page to multiple VMs. Hint is hash hit, but it doesn&rsquo;t guarantee the content of the page doesn&rsquo;t change at that moment.</p>
<p><strong>Idle Memory</strong> presents a problem in pure proportional-share algorithms because they do not incorporate any information about active memory usage. More specifically, the memory demand might change dynamically. ESX Server collects <em>idle memory tax</em> from VMs to mitigate this issue. A client is charged more for an idle page than the active one. The cost of idle memory is inflated by tax rate. The metrics of idles pages in guests is collected by hypervisor without guests' involvement. The idle page information in virtual page table inside VMs is periodically sampled on random bases.</p>
<h2 id=questions>Questions <a href=#questions class="hash g">#</a></h2>
<p>a. What is the overhead of ballooning? Triggering memory management in the VM by &ldquo;tricking&rdquo; it into thinking the the memory resource is scarce/plentiful may have unexpected behaviors.<br>
b. Do content-based sharing pose security vulnerabilities?<br>
c. Remapping hot I/O pages to low memory can be a bottleneck if the page number is high. How does modern hypervisor solution cope with this issue?</p>
<hr class=hr-list>
<footer>
<p>© 2016-2021 <a href=https://www.bodunhu.com/>Bodun Hu</a>. All rights reserved. <a href=/blog/index.xml>Subscribe</a></p>
</footer>
</div>
</main>
</body>
</html>