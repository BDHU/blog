<!doctype html><html lang=en-us><head><meta http-equiv=x-clacks-overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Pascal GPU memory and cache hierarchy | std::bodun::blog</title><meta name=title content="Pascal GPU memory and cache hierarchy"><meta name=description content="Memory access efﬁciency is an important factor in fully utilizing the computational power of graphics processing units (GPUs). However, many GPU vendors like NVIDIA kept the GPU memory hierarchy as a secret. Therefore it becomes hard to measure GPUs performance and sets barriers to understand memory access patterns, which is a key component to improve program's performance. Here we introduce a novel fine-grained microbenchmark approach and apply to the Pascal generation. Turing architecture might have different results, but the method we used here can be applied as well with slight modification. The method we use in this guide is inspired by the research paper: [Dissecting GPU Memory Hierarchy through Microbenchmarking](https://ieeexplore.ieee.org/document/7445236). Here we will explain how P-Chase works and walk through a small example"><meta name=keywords content="gpu,os,mm,"><meta property="og:title" content="Pascal GPU memory and cache hierarchy"><meta property="og:description" content="Memory access efﬁciency is an important factor in fully utilizing the computational power of graphics processing units (GPUs). However, many GPU vendors like NVIDIA kept the GPU memory hierarchy as a secret. Therefore it becomes hard to measure GPUs performance and sets barriers to understand memory access patterns, which is a key component to improve program's performance. Here we introduce a novel fine-grained microbenchmark approach and apply to the Pascal generation. Turing architecture might have different results, but the method we used here can be applied as well with slight modification. The method we use in this guide is inspired by the research paper: [Dissecting GPU Memory Hierarchy through Microbenchmarking](https://ieeexplore.ieee.org/document/7445236). Here we will explain how P-Chase works and walk through a small example"><meta property="og:type" content="article"><meta property="og:url" content="https://www.bodunhu.com/blog/posts/pascal-gpu-memory-and-cache-hierarchy/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2019-01-15T00:00:00+00:00"><meta property="article:modified_time" content="2022-02-13T15:35:05-06:00"><meta property="og:site_name" content="std::bodun::blog"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pascal GPU memory and cache hierarchy"><meta name=twitter:description content="Memory access efﬁciency is an important factor in fully utilizing the computational power of graphics processing units (GPUs). However, many GPU vendors like NVIDIA kept the GPU memory hierarchy as a secret. Therefore it becomes hard to measure GPUs performance and sets barriers to understand memory access patterns, which is a key component to improve program's performance. Here we introduce a novel fine-grained microbenchmark approach and apply to the Pascal generation. Turing architecture might have different results, but the method we used here can be applied as well with slight modification. The method we use in this guide is inspired by the research paper: [Dissecting GPU Memory Hierarchy through Microbenchmarking](https://ieeexplore.ieee.org/document/7445236). Here we will explain how P-Chase works and walk through a small example"><meta name=twitter:site content="@https://twitter.com/BodunHu"><meta itemprop=name content="Pascal GPU memory and cache hierarchy"><meta itemprop=description content="Memory access efﬁciency is an important factor in fully utilizing the computational power of graphics processing units (GPUs). However, many GPU vendors like NVIDIA kept the GPU memory hierarchy as a secret. Therefore it becomes hard to measure GPUs performance and sets barriers to understand memory access patterns, which is a key component to improve program's performance. Here we introduce a novel fine-grained microbenchmark approach and apply to the Pascal generation. Turing architecture might have different results, but the method we used here can be applied as well with slight modification. The method we use in this guide is inspired by the research paper: [Dissecting GPU Memory Hierarchy through Microbenchmarking](https://ieeexplore.ieee.org/document/7445236). Here we will explain how P-Chase works and walk through a small example"><meta itemprop=datePublished content="2019-01-15T00:00:00+00:00"><meta itemprop=dateModified content="2022-02-13T15:35:05-06:00"><meta itemprop=wordCount content="2106"><meta itemprop=keywords content="gpu,os,mm,"><meta name=referrer content="no-referrer-when-downgrade"><style>body{font-family:Verdana,sans-serif;margin:auto;padding:20px;max-width:720px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}</style></head><body><header><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><a href=/blog/ class=title><h2>std::bodun::blog</h2></a><nav><a href=/blog/>Home</a>
<a href=/blog/blog/posts/>Archive</a>
<a href=https://www.bodunhu.com/>About</a></nav></header><main><h1>Pascal GPU memory and cache hierarchy</h1><p><i><time datetime=2019-01-15 pubdate>15 Jan, 2019</time></i></p><content><p>Memory access efficiency allows fully utilizing the computational power of graphics processing units (GPUs). However, many GPU vendors like NVIDIA kept the GPU memory hierarchy as a secret. Therefore it becomes hard to measure GPUs performance and sets barriers to understand memory access patterns, which is a key component to improve program&rsquo;s performance.</p><p>We introduce a novel fine-grained micro-benchmark approach and apply to the Pascal generation. Turing architecture might have different results, but the method we used here can be applied as well with slight modification. The method we use in this guide is inspired by the research paper: <a href=https://ieeexplore.ieee.org/document/7445236>Dissecting GPU Memory Hierarchy through Microbenchmarking</a>. Here we will explain how P-Chase works and walk through a small example.</p><h2 id=memory-hierarchy-overview>Memory Hierarchy Overview</h2><p>GPU memory hierarchy is different compared to CPU memory hierarchy. Using the terminologies of CUDA, GPU memory space can be categorized in these groups: register, constant memory, shared memory, texture memory, local memory, and global memory. Each different memory space have its own properties. Since we are interested the cache systems, here is a picture demonstrating the memory hierarchy of a NVIDIA GPU:</p><p align=center><img src=https://gistbok.ucgis.org/sites/default/files/1000px-Memory.svg_.png width=450></p><p align=center><a href=https://gistbok.ucgis.org/bok-topics/graphics-processing-units-gpus>Image source</a></p><p>The characteristics of each memory space can be found in <a href=https://developer.download.nvidia.com/compute/DevZone/docs/html/C/doc/CUDA_C_Programming_Guide.pdf>NVIDIA CUDA C Programming Guide
</a>. Here we will focus on some target memory space we are interested in. The paper lists some properties of our target memory space:</p><table><thead><tr><th>Memory</th><th style=text-align:center>Type</th><th style=text-align:right>Cached</th><th style=text-align:right>Scope</th></tr></thead><tbody><tr><td>Global</td><td style=text-align:center>R/W</td><td style=text-align:right>Yes</td><td style=text-align:right>All Threads</td></tr><tr><td>Shared</td><td style=text-align:center>R/W</td><td style=text-align:right>N/A</td><td style=text-align:right>Thread Blocks</td></tr><tr><td>Texture</td><td style=text-align:center>R</td><td style=text-align:right>Yes</td><td style=text-align:right>All Threads</td></tr></tbody></table><p>Even though the paper targets Fermi, Kepler and Maxwell generations of GPU, the properties of the table still holds for Pascal GPU and possibly Turing as well. The cached global/texture memory uses a two-level caching system. The L1 cache is located in each stream multiprocessor (SM), while the L2 cache is off-chip and shared among all SMs. It is unified for instruction, data and page table access. According to CUDA documentation, like Maxwell, Pascal combines the functionality of the L1 and texture caches into a unified L1/Texture cache which acts as a coalescing buffer for memory accesses, gathering up the data requested by the threads of a warp prior to delivery of that data to the warp. This function previously was served by the separate L1 cache in Fermi and Kepler. Page table is used by GPU to map virtual addresses to physical addresses, and is usually stored in the global memory. The page table is cached in TLB to reduce memory access latency. Once a thread cannot ﬁnd the page entry in the TLB, it would access the global memory to search in the page table, which introduced significant memory access latency. The GPU-specific shared memory is located in the SMs. On the Fermi and Kepler devices, it shares memory space with the L1 data cache. On Maxwell and Pascal devices, it has a dedicated space, since the functionality of the L1 and texture caches have been merged. One thing to note here is that shared memory is accessed by the thread blocks. Thread-blocks remain limited to 48 KB of shared memory in Pascal. Therefore, NVIDIA recommends that applications use at most 32 KB of shared memory in any one thread block. This would, for example, allow at least two thread blocks to fit per GP100 SM, or 3 thread blocks per GP104 SM.</p><p>However, we should be careful that by default, GP100 caches global loads in the L1/Texture cache. In contrast, GP104 follows Kepler and Maxwell in caching global loads in L2 only, unless using the LDG read-only data cache mechanism introduced in Kepler. As with previous architectures, GP104 allows the developer to opt-in to caching all global loads in the unified L1/Texture cache by passing the -Xptxas -dlcm=ca flag to <code>nvcc</code> at compile time. Even though both GP100 and GP104 belongs to Pascal family, we only focus on GP100 here because that&rsquo;s the GPU we use. Another thing to notice is that unlike Maxwell but similar to Kepler, Pascal caches thread-local memory in the L1 cache. This can mitigate the cost of register spills compared to Maxwell. To illustrate our point, we checked both <code>cudaDevAttrGlobalL1CacheSupported</code> and <code>cudaDevAttrLocalL1CacheSupported</code> on Tesla P100 and GTX 1080 and find both attributes to be 1.</p><p>In addition to the L2 data cache, global memory data that is read-only for the entire lifetime of a kernel can be cached in the read-only data cache with a compute capability of 3.5 or above. We will also explore the size of this read-only cache using __ldg() intrinsic.</p><h2 id=p-chase>P-Chase</h2><p>Most existing GPU microbenchmark studies on cache architecture assume a classical set-associative cache model with the least recently used (LRU) replacement policy, the same as the conventional CPU cache. So here we will use this assumption and proceed with our experiments. Here are some notations we will use throughout this post.</p><table><thead><tr><th>Notation</th><th style=text-align:center>Description</th><th style=text-align:right>Notation</th><th style=text-align:right>Description</th></tr></thead><tbody><tr><td>C</td><td style=text-align:center>Cache Size</td><td style=text-align:right>N</td><td style=text-align:right>array size</td></tr><tr><td>b</td><td style=text-align:center>cache line size</td><td style=text-align:right>s</td><td style=text-align:right>stride size</td></tr><tr><td>a</td><td style=text-align:center>cache associativity</td><td style=text-align:right>k</td><td style=text-align:right>iterations</td></tr><tr><td>T</td><td style=text-align:center>number of cache set</td><td style=text-align:right>r</td><td style=text-align:right>cache miss rate</td></tr></tbody></table><p>Under our assumptions, data is loaded from main memory to lower cache in the basic unit of a cache line. The number of words in a cache line is referred to as the line size (b). For the LRU set-associative cache, the cache memory is divided into T cache sets, each of which consists of \(a\) cache lines. It is essential to have these three assumptions using this kind of cache model:</p><ul><li><p><strong>Assumption 1</strong> All cache sets have the same size. The cache parameter should satisfy \(T \cdot a \cdot b = C\).</p></li><li><p><strong>Assumption 2</strong> In the memory address, the bits representing the cache set are immediately followed by the bits representing the offset.</p></li><li><p><strong>Assumption 3</strong> Cache replacement policy should be LRU.</p></li></ul><p>We will later see why these assumptions are essential as we proceed with the experiment. We won&rsquo;t go through how P-Chase work exactly. To find more information, this <a href=https://arxiv.org/pdf/1509.02308.pdf>paper</a> does a good job illustrating how P-Chase work. The takeaway is, we need to brute force an array with one element more than a cache can hold so that cache miss will start to occur periodically whereas such array with less or equal elements to the cache capacity will always result in cache hit and thus no access overhead will be introduced after all data is loaded into the cache. This is the algorithm the paper proposed and we will use it to do the experiment:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>__global__ <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>KernelFunction</span> ( . . . ) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>//declare shared memory space
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    __shared__ <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> s tvalue [ ] ;
</span></span><span style=display:flex><span>    __shared__ <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>int</span> s index [ ] ;
</span></span><span style=display:flex><span>    preheat the data ; <span style=color:#75715e>// implementation varies
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (it <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; it <span style=color:#f92672>&lt;</span> iter ; it<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        start_time<span style=color:#f92672>=</span><span style=color:#a6e22e>clock</span>();
</span></span><span style=display:flex><span>        j <span style=color:#f92672>=</span> my_array[j];
</span></span><span style=display:flex><span>        <span style=color:#75715e>//store the array index
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// This following line is essential because due to
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// instruction-level parallelism (ILP), function clock() may
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// overlap with its previous instruction and even return before
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// the previous instruction finishes. For example,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// end_time=clock() can return before j = my_array[j] returns.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// adding s_index [it]= j since it have data dependency on the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// previous line. Thus the memory access will be over before
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// end_time=clock() started.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        s_index [it]<span style=color:#f92672>=</span> j;
</span></span><span style=display:flex><span>        end_time<span style=color:#f92672>=</span><span style=color:#a6e22e>clock</span>();
</span></span><span style=display:flex><span>        <span style=color:#75715e>//store the access latency
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        s_tvalue[it]<span style=color:#f92672>=</span> end_time<span style=color:#960050;background-color:#1e0010>−</span>start_time ;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The steps is the same as the paper proposes, so here we show the paper&rsquo;s method:</p><ol><li><p>Determine cache size C . We set s to 1. We then initialize N with a small value and increase it gradually until the ﬁrst cache miss appears. C equals the maximum N where all memory accesses are cache hits.</p></li><li><p>Determine cache line size b. We set s to 1. We begin with N = C + 1 and increase N gradually again. When N &lt; C + b + 1, the numbers of cache misses are close. When N is increased to C + b + 1, there is a sudden increase on the number of cache misses, despite that we only increase N by 1. Accordingly we can ﬁnd b. Based on the memory access patterns, we can also have a general idea on the cache replacement policy.</p></li><li><p>Determine number of cache sets T . We set s to b. We then start with N = C and increase N at the granularity of b. Every increment causes cache misses of a new cache set. When N > C + (T − 1)b, all cache sets are missed. We can then deduce T from cache miss patterns accordingly.</p></li><li><p>Determine cache replacement policy. As mentioned before, if the cache replacement policy is LRU, then the memory access process should be periodic and all the cache ways in the cache set are missed. If memory access process is aperiodic, then the replacement policy cannot be LRU. Under this circumstance, we set N = C + b, s = b with a considerable large k (k &#187; N/s) so that we can traverse the array multiple times. All cache misses are from one cache set. Every cache miss is caused by its former cache replacement because we overflow the cache by only one cache line. We have the accessed data indices thus we can reproduce the full memory access process and ﬁnd how the cache lines are updated.</p></li></ol><h2 id=texture-l1-cache-and-read-only-data-cache>Texture L1 Cache and Read-only Data Cache</h2><p>When use the <a href=http://www.comp.hkbu.edu.hk/~chxw/Code/fine_grain_Maxwell_texture_L1.cu>code</a> with increased our own data preheat implementation because the texture L1 cache can potentially be greater than the shared memory. The original code uses the first iteration of the loop in the algorithm as a way to preheat data:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> it <span style=color:#f92672>=</span>  <span style=color:#ae81ff>6144</span> <span style=color:#75715e>// texture L1 may hold more elements,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                     <span style=color:#75715e>// So the first iteration may not cold
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                     <span style=color:#75715e>// hit all elements, some cold hits can
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                     <span style=color:#75715e>// be moved to the second iteration,
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                     <span style=color:#75715e>// causing confusion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> cnt<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; cnt <span style=color:#f92672>&lt;</span> it; cnt<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    start<span style=color:#f92672>=</span><span style=color:#a6e22e>clock</span>();
</span></span><span style=display:flex><span>    j<span style=color:#f92672>=</span><span style=color:#a6e22e>tex1Dfetch</span>(tex_ref, j);
</span></span><span style=display:flex><span>    s_value[cnt] <span style=color:#f92672>=</span> j;
</span></span><span style=display:flex><span>    end<span style=color:#f92672>=</span><span style=color:#a6e22e>clock</span>();
</span></span><span style=display:flex><span>    s_tvalue[cnt] <span style=color:#f92672>=</span> (end <span style=color:#f92672>-</span>start);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>However, if texture L1 cache is greater than the shared memory allowed for each thread block, then some reads in the second loop will trigger cache misses. But such misses are in fact cold misses, not misses caused after the texture L1 cache is completely filled up. One solution is increase iteration to a much larger number so that the first iteration will always fill up the texture L1 cache. Note that if you move the data
preheat out such as</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> cnt<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; cnt <span style=color:#f92672>&lt;</span> it; cnt<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        tmp<span style=color:#f92672>=</span><span style=color:#a6e22e>tex1Dfetch</span>(tex_ref, tmp);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The compiler can optimize this whole step out and thus nothing actually gets executed.</p><p>After we run the modified code, the result shows that the we the cache missed starts when we set our array size to 6145, indicating the texture L1 cache can hold 6144 ints, which is equivalent to 24 kb. We also notice that each miss is followed by 7 consecutive hits. This means the cache line size is 8 words(b = 32 bytes). The structure of the L1 TLB is shown below, notice there are 192 lines in each set:</p><table><thead><tr><th>Set1</th><th style=text-align:center>Set2</th><th style=text-align:right>Set3</th><th style=text-align:right>Set4</th></tr></thead><tbody><tr><td>1-8</td><td style=text-align:center>33-40</td><td style=text-align:right>65-72</td><td style=text-align:right>97-104</td></tr><tr><td>9-16</td><td style=text-align:center>41-48</td><td style=text-align:right>&mldr;</td><td style=text-align:right>&mldr;</td></tr><tr><td>17-24</td><td style=text-align:center>46-56</td><td style=text-align:right>&mldr;</td><td style=text-align:right>&mldr;</td></tr><tr><td>25-32</td><td style=text-align:center>57-64</td><td style=text-align:right>89-96</td><td style=text-align:right>121-128</td></tr><tr><td>129-136</td><td></td><td></td><td></td></tr><tr><td>&mldr;</td><td style=text-align:center>&mldr;</td><td style=text-align:right>&mldr;</td><td style=text-align:right>&mldr;</td></tr><tr><td>2969-2976</td><td style=text-align:center>3001-3008</td><td style=text-align:right>3033-3040</td><td style=text-align:right>3065-3072</td></tr></tbody></table><p>According to CUDA documentation, GK110 adds the ability for read-only data in global memory to be loaded through the same cache used by the texture pipeline via a standard pointer without the need to bind a texture beforehand and without the sizing limitations of standard textures. The read-only data cache is loaded by calling __ldg(const restricted * address). We modified the code used to test texture L1 cache. The basic logic remains the same. When the arrays size is set to 6144 integers no cache misses occur with stride set as 32 (s=32 bytes). As soon as we increased one more element in the array cache misses start occurring. This shows the read-only cache is 24kb. We then noticed that the misses occur in a group of either 4 or 8. We infer the cache line to be 32 bytes and the replacement policy is LRU, same as Maxwell. We we increase the array to include 6248 elements(6144+32<em>3+8, 6144 is the max capacity of the cache, 32 consecutive number in a set, 32</em>3 to cause cache miss in set1, set2, and set3, only need to include 8 more to cause cache miss in set4 since s=32bytes), no caches hits occur. Therefore, we infer the caches set number to be 4, each cache line is 32 bytes, and each set contains 192 cache lines, the same as the texture L1 cache. The memory mapping seems arbitrary because the hit and miss patterns didn&rsquo;t follow that of the texture L1 cache.</p></content><p><a href=https://www.bodunhu.com/blog/tags/gpu/>#gpu</a>
<a href=https://www.bodunhu.com/blog/tags/os/>#os</a>
<a href=https://www.bodunhu.com/blog/tags/mm/>#mm</a></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>