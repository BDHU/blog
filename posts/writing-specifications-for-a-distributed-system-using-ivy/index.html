<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width"><title>Writing Specifications for a Distributed System using Ivy</title><link rel=stylesheet href=https://www.bodunhu.com/blog/css/colors-preference.min.6664643cf79a5299d3f7e39dce5f9dfdc1b81853c24fde4bd69be08c4a131534.css><link rel="shortcut icon" href=https://www.bodunhu.com/blog/favicon.ico><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js async></script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,o,i,a,t,n,s){e.GoogleAnalyticsObject=t,e[t]=e[t]||function(){(e[t].q=e[t].q||[]).push(arguments)},e[t].l=1*new Date,n=o.createElement(i),s=o.getElementsByTagName(i)[0],n.async=1,n.src=a,s.parentNode.insertBefore(n,s)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-108144808-1","auto"),ga("send","pageview"))</script><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-108144808-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></head><body><header id=header><h1><a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></h1><p>PhD student at University of Texas at Austin ðŸ¤˜. Doing systems for ML.</p></header><div id=page><div id=sidebar><nav><ul class=nav><li><a href=/blog/posts/><span>Archive</span></a></li><li><a href=https://www.bodunhu.com/><span>About</span></a></li><li><a href=/blog/index.xml><span>Feed</span></a></li></ul></nav></div><div id=content><article class=post><h1><a href=https://www.bodunhu.com/blog/posts/writing-specifications-for-a-distributed-system-using-ivy/>Writing Specifications for a Distributed System using Ivy</a></h1><div class=post-content><p>Before we jump into writing specifications in a distributed setting, we first define what a specification is. I take the definition from the magnificent <a href=http://mcmil.net/wordpress/>Ken McMillan</a>: a specification is a <em>statement</em>.</p><p>A statement describes an abstract view of a program. The view itself is often at an interface, which hides or abstracts internal states. A specification is stated in terms of two elements:</p><ul><li>Assumption: properties of the environment the system relies on</li><li>Guarantee: properties that most hold <em>if</em> the assumption(s) is met</li></ul><p>The way we write specifications is through an abstract program that observes or monitors all program events. This abstract program is able to remember the execution history of program being monitored, and decides, at any given moment, whether an action is allowable according to the specification.</p><p>One way to implement this abstract monitor program is to use guarded command form:</p><ul><li>Let \(A\) be a set of program actions</li><li>An event \(e(x_1,\ &mldr;,\ x_n)\) is an action \(e\in A\) with parameter values \(x_1,\ &mldr;,\ x_n\) of the right types for \(e\).</li><li>Let \(S\) be a set of states and \(s_0 \in S\) be the initial state.</li><li>Guarded command set \(G\) is specified as:</li></ul><p>\[e(V):\ \gamma (S,V) \rightarrow {S := \tau(S, V)}\]</p><p>It means if a guarded command \(\gamma\) determines a given event \(e\) satisfies certain specifications with parameter \(V\) under state \(S\), then we accept the code and then deterministically update the state with a function \(\tau\).</p><p>The observation \(E\) of system is going to be a finite sequence of events, which corresponds to the system behavior, denoted as \(e_0(V_0)&mldr;e_{n-1}(V_{n-1})\). A run of \(E\) is a state sequence \(s_0\ &mldr;s_n\) such that for \(i\in 0\ &mldr; n- 1\), \(\gamma(s_i, V_i)\) is true and \(s_{i+1} = \tau(s_i, v_i)\). Observation \(E\) is accepted by the specification iff it has a run. We can test whether an observation is accepted by just executing the guarded commands. In layman&rsquo;s term, if all guarded commands accepts the their corresponding event at a given time, then the sequence events must satisfy our specification and should be accepted.</p><p>Now let&rsquo;s replicated file as an example. Out first informal attempt to the specification for &ldquo;append&rdquo; operation would be:</p><ul><li>Assumption: network is ordered and non-duplicating</li><li>Guarantee: if no further append requests, eventually replicas are equal</li></ul><p>However, the problem with this specification is that this is a liveness property, meaning that we can&rsquo;t practically test such property by observing a finite sequence of events. Therefore, we resort to a different safety specification we can test:</p><ul><li>If all sent messages are delivered, the two replicas are identical.</li></ul><p>Now we convert liveness to safety by explicitly defining the moment hen the eventuality should hold.</p><blockquote><p>Liveness property means a good thing eventually happens. A liveness property can be <em>refuted</em> by finite execution. Safety property means a bad thing never happens. A safety property can always be refuted by a finite execution.</p></blockquote><p>To see how replicated file specification plays in action, we use the example given in <a href=http://mcmil.net/wordpress/>Prof. McMillan</a>&rsquo;s presentation. The code is written in <a href=http://microsoft.github.io/ivy/language.html>Ivy</a> and is pretty self-explanatory. In this demo we only have two processes.</p><blockquote><p>To install Ivy, simply execute <code>virtualenv ivyenv && source ivyenv/bin/activate && pip install ms-ivy</code>. This is tested on Ubuntu 18.04 LTS and may vary slight on other distros.</p></blockquote><div class=highlight><pre tabindex=0 style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>#lang ivy1.<span style=color:#00afaf>8</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0087ff>include</span> numbers
</span></span><span style=display:flex><span><span style=color:#0087ff>include</span> collections
</span></span><span style=display:flex><span><span style=color:#0087ff>include</span> network
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0087ff>global</span> {
</span></span><span style=display:flex><span>    alias byte <span style=color:#5f8700>=</span> uint[<span style=color:#00afaf>8</span>]
</span></span><span style=display:flex><span>    <span style=color:#0087ff>instance</span> file <span style=color:#af0000>:</span> vector(byte)
</span></span><span style=display:flex><span>    <span style=color:#0087ff>type</span> pid <span style=color:#5f8700>=</span> {<span style=color:#00afaf>0</span>..<span style=color:#00afaf>1</span>}
</span></span><span style=display:flex><span>    <span style=color:#0087ff>instance</span> net <span style=color:#af0000>:</span> tcp.net(byte)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0087ff>process</span> host(self<span style=color:#af0000>:</span>pid) <span style=color:#5f8700>=</span> {
</span></span><span style=display:flex><span>    export action append(val<span style=color:#af0000>:</span>byte)
</span></span><span style=display:flex><span>    <span style=color:#0087ff>import</span> action show(content<span style=color:#af0000>:</span>file)
</span></span><span style=display:flex><span>    <span style=color:#0087ff>instance</span> sock <span style=color:#af0000>:</span> net.socket
</span></span><span style=display:flex><span>    var contents <span style=color:#af0000>:</span> file
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    after init{
</span></span><span style=display:flex><span>        contents <span style=color:#af0000>:=</span> file.empty;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    implement append {
</span></span><span style=display:flex><span>        contents <span style=color:#af0000>:=</span> contents.append(val);
</span></span><span style=display:flex><span>        sock.send(host(<span style=color:#00afaf>1</span>-self).sock.id, val);
</span></span><span style=display:flex><span>        show(contents);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    implement sock.recv(src<span style=color:#af0000>:</span>tcp.endpoint, val<span style=color:#af0000>:</span>byte) {
</span></span><span style=display:flex><span>        contents <span style=color:#af0000>:=</span> contents.append(val);
</span></span><span style=display:flex><span>        show(contents);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Then we form our specification based on the guarantee that if all sent messages are delivered, the two replicas are identical. The specification is equivalent to the <em>guarded command</em> we&rsquo;ve talked about earlier.</p><div class=highlight><pre tabindex=0 style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#0087ff>specification</span> {
</span></span><span style=display:flex><span>    var msg_count <span style=color:#af0000>:</span> nat
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    after init {
</span></span><span style=display:flex><span>        msg_count <span style=color:#af0000>:=</span> <span style=color:#00afaf>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    after host.sock.send(self<span style=color:#af0000>:</span>pid, dst<span style=color:#af0000>:</span>tcp.endpoint, val<span style=color:#af0000>:</span>byte) {
</span></span><span style=display:flex><span>        msg_count <span style=color:#af0000>:=</span> msg_count + <span style=color:#00afaf>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    after host.sock.recv(self<span style=color:#af0000>:</span>pid, src<span style=color:#af0000>:</span>tcp.endpoint, val<span style=color:#af0000>:</span>byte) {
</span></span><span style=display:flex><span>        msg_count <span style=color:#af0000>:=</span> msg_count - <span style=color:#00afaf>1</span>;
</span></span><span style=display:flex><span>        ensure msg_count <span style=color:#5f8700>=</span> <span style=color:#00afaf>0</span> <span style=color:#5f8700>-&gt;</span> host(<span style=color:#00afaf>0</span>).contents.eq(host(<span style=color:#00afaf>1</span>).contents);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We wrote the above code into a file named <code>append.ivy</code> and we generate the testing code using <code>ivyc target=test append.ivy</code>. Then we run the code using <code>ivy_launch append.ivy</code>.</p><p>Interestingly, the program yields an error message:</p><div class=highlight><pre tabindex=0 style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>`ivy_shell`; ./append &#34;[[0,{addr:0x7f000001,port:49124}],[1,{addr:0x7f000001,port:49125}]]&#34;
</span></span><span style=display:flex><span>&gt; host.append(1,251)
</span></span><span style=display:flex><span>&lt; host.show(1,[251])
</span></span><span style=display:flex><span>&lt; host.show(0,[251])
</span></span><span style=display:flex><span>&gt; host.append(1,46)
</span></span><span style=display:flex><span>&lt; host.show(1,[251,46])
</span></span><span style=display:flex><span>&gt; host.append(0,183)
</span></span><span style=display:flex><span>&lt; host.show(0,[251,183])
</span></span><span style=display:flex><span>&lt; host.show(0,[251,183,46])
</span></span><span style=display:flex><span>&lt; host.show(1,[251,46,183])
</span></span><span style=display:flex><span>assertion_failed(&#34;append.ivy: line 49&#34;)
</span></span><span style=display:flex><span>append.ivy: line 49: error: assertion failed
</span></span></code></pre></div><p>What happens is the program generates tests that randomizes message arrival times and we can see a delivered message may arrive after its target sends another message, therefore creating corrupted file contents.</p><p>Notice that here we are actually running on real network to find counter examples, the downside is the test may be arbitrary long depending on the randomized testing cases. Instead, we will use bounded model checking (BMC) to test if the specification is correct. This way we can reply purely on the logic of our specification instead of running on the real network. The Ivy checker uses <a href=https://en.wikipedia.org/wiki/Z3_Theorem_Prover>Z3 Theorem Prover</a>.</p><blockquote><p>BMC construct a boolean formula that is satisfiable if and only if the underlying state transition system can realize a finite sequence of state transitions that reaches certain states of interest.</p></blockquote><p>To tell Ivy using bounded model checking, we add the following lines to <code>append.ivy</code>:</p><div class=highlight><pre tabindex=0 style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#0087ff>axiom</span> host(<span style=color:#00afaf>0</span>).sock.id ~= host(<span style=color:#00afaf>1</span>).sock.id
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#0087ff>attribute</span> method<span style=color:#5f8700>=</span>bmc[<span style=color:#00afaf>10</span>]
</span></span></code></pre></div><p>Executing <code>ivy_check detailed=false append.ivy</code>, we see an error message:</p><div class=highlight><pre tabindex=0 style=color:#8a8a8a;background-color:#1c1c1c;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>&gt; host.append(1,80)
</span></span><span style=display:flex><span>&lt; host.show(1,[80])
</span></span><span style=display:flex><span>&gt; host.append(0,64)
</span></span><span style=display:flex><span>&lt; host.show(0,[64])
</span></span><span style=display:flex><span>&gt; host.sock.recv(0,{tcp.endpoint.addr:...,tcp.endpoint.port:...},80)
</span></span><span style=display:flex><span>&lt; host.show(0,[64,80])
</span></span><span style=display:flex><span>&gt; host.sock.recv(1,{tcp.endpoint.addr:...,tcp.endpoint.port:...},64)
</span></span><span style=display:flex><span>&lt; host.show(1,[80,64])
</span></span><span style=display:flex><span>append.ivy: line 49: error: assertion failed
</span></span></code></pre></div><p>Sometimes BMC can help us find the error faster because it is systematically checking all possible actions. However, increasing the number of steps for the BMC can result in the exploration space growing exponentially, so we are going to use some combination of BMC and randomized test cases.</p></div><p class=meta>Posted on <span class=postdate>08. September 2021</span></p></article></div><footer id=footer><p class=copyright><p>Â© 2022 <a href=https://www.bodunhu.com>Bodun Hu</a>. All rights reserved.</p></p></footer></div></body></html>