<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="std::bodun::blog. Personal Blog of Bodun (Edward) Hu. CS PhD student at University of Texas at Austin. Operating systems, network, heterogeneity, MLSys, anything system. UTCS">
<link rel="shortcut icon" href=https://www.bodunhu.com/blog/favicon.ico>
<link rel=stylesheet href=/blog/css/style.min.css>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
<script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script>
<script>let isDark=window.matchMedia('(prefers-color-scheme: dark)').matches,mermaidTheme=isDark?'dark':'default',mermaidConfig={startOnLoad:!0,securityLevel:'strict',flowchart:{useMaxWidth:!0,htmlLabels:!0},theme:mermaidTheme};mermaid.initialize(mermaidConfig)</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css rel=stylesheet>
<title>Writing Specifications for a Distributed System using Ivy</title>
</head>
<body>
<header id=return>
<h2></h2><a href=https://www.bodunhu.com/blog/><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" style="vertical-align:-.125em" width="18" height="18" viewBox="0 0 16 16"><g fill="currentcolor"><path fill-rule="evenodd" d="M15 2a1 1 0 00-1-1H2A1 1 0 001 2v12a1 1 0 001 1h12a1 1 0 001-1V2zM0 2a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H2a2 2 0 01-2-2V2zm11.5 5.5a.5.5.0 010 1H5.707l2.147 2.146a.5.5.0 01-.708.708l-3-3a.5.5.0 010-.708l3-3a.5.5.0 11.708.708L5.707 7.5H11.5z"/></g></svg>
</a>
</header>
<main id=content>
<article>
<header id=post-header>
<h1>Writing Specifications for a Distributed System using Ivy</h1>
<div>
<time>Sep 8, 2021</time>
</div>
</header><p>Before we jump into writing specifications in a distributed setting, we first define what a specification is. I take the definition from the magnificent <a href=http://mcmil.net/wordpress/>Ken McMillan</a>: a specification is a <em>statement</em>.</p>
<p>A statement describes an abstract view of a program. The view itself is often at an interface, which hides or abstracts internal states. A specification is stated in terms of two elements:</p>
<ul>
<li>Assumption: properties of the environment the system relies on</li>
<li>Guarantee: properties that most hold <em>if</em> the assumption(s) is met</li>
</ul>
<p>The way we write specifications is through an abstract program that observes or monitors all program events. This abstract program is able to remember the execution history of program being monitored, and decides, at any given moment, whether an action is allowable according to the specification.</p>
<p>One way to implement this abstract monitor program is to use guarded command form:</p>
<ul>
<li>Let \(A\) be a set of program actions</li>
<li>An event \(e(x_1,\ &mldr;,\ x_n)\) is an action \(e\in A\) with parameter values \(x_1,\ &mldr;,\ x_n\) of the right types for \(e\).</li>
<li>Let \(S\) be a set of states and \(s_0 \in S\) be the initial state.</li>
<li>Guarded command set \(G\) is specified as:</li>
</ul>
<p>\[e(V):\ \gamma (S,V) \rightarrow {S := \tau(S, V)}\]</p>
<p>It means if a guarded command \(\gamma\) determines a given event \(e\) satisfies certain specifications with parameter \(V\) under state \(S\), then we accept the code and then deterministically update the state with a function \(\tau\).</p>
<p>The observation \(E\) of system is going to be a finite sequence of events, which corresponds to the system behavior, denoted as \(e_0(V_0)&mldr;e_{n-1}(V_{n-1})\). A run of \(E\) is a state sequence \(s_0\ &mldr;s_n\) such that for \(i\in 0\ &mldr; n- 1\), \(\gamma(s_i, V_i)\) is true and \(s_{i+1} = \tau(s_i, v_i)\). Observation \(E\) is accepted by the specification iff it has a run. We can test whether an observation is accepted by just executing the guarded commands. In layman&rsquo;s term, if all guarded commands accepts the their corresponding event at a given time, then the sequence events must satisfy our specification and should be accepted.</p>
<p>Now let&rsquo;s replicated file as an example. Out first informal attempt to the specification for &ldquo;append&rdquo; operation would be:</p>
<ul>
<li>Assumption: network is ordered and non-duplicating</li>
<li>Guarantee: if no further append requests, eventually replicas are equal</li>
</ul>
<p>However, the problem with this specification is that this is a liveness property, meaning that we can&rsquo;t practically test such property by observing a finite sequence of events. Therefore, we resort to a different safety specification we can test:</p>
<ul>
<li>If all sent messages are delivered, the two replicas are identical.</li>
</ul>
<p>Now we convert liveness to safety by explicitly defining the moment hen the eventuality should hold.</p>
<blockquote>
<p>Liveness property means a good thing eventually happens. A liveness property can be <em>refuted</em> by finite execution. Safety property means a bad thing never happens. A safety property can always be refuted by a finite execution.</p>
</blockquote>
<p>To see how replicated file specification plays in action, we use the example given in <a href=http://mcmil.net/wordpress/>Prof. McMillan</a>&rsquo;s presentation. The code is written in <a href=http://microsoft.github.io/ivy/language.html>Ivy</a> and is pretty self-explanatory. In this demo we only have two processes.</p>
<blockquote>
<p>To install Ivy, simply execute <code>virtualenv ivyenv && source ivyenv/bin/activate && pip install ms-ivy</code>. This is tested on Ubuntu 18.04 LTS and may vary slight on other distros.</p>
</blockquote>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=o>#</span><span class=n>lang</span> <span class=n>ivy1</span><span class=o>.</span><span class=mi>8</span>

<span class=nf>include</span> <span class=n>numbers</span>
<span class=nf>include</span> <span class=n>collections</span>
<span class=nf>include</span> <span class=n>network</span>

<span class=nf>global</span> <span class=p>{</span>
    <span class=n>alias</span> <span class=n>byte</span> <span class=ow>=</span> <span class=n>uint</span><span class=p>[</span><span class=mi>8</span><span class=p>]</span>
    <span class=kr>instance</span> <span class=n>file</span> <span class=kt>:</span> <span class=n>vector</span><span class=p>(</span><span class=n>byte</span><span class=p>)</span>
    <span class=kr>type</span> <span class=n>pid</span> <span class=ow>=</span> <span class=p>{</span><span class=mi>0</span><span class=o>..</span><span class=mi>1</span><span class=p>}</span>
    <span class=kr>instance</span> <span class=n>net</span> <span class=kt>:</span> <span class=n>tcp</span><span class=o>.</span><span class=n>net</span><span class=p>(</span><span class=n>byte</span><span class=p>)</span>
<span class=p>}</span>

<span class=nf>process</span> <span class=n>host</span><span class=p>(</span><span class=n>self</span><span class=kt>:</span><span class=n>pid</span><span class=p>)</span> <span class=ow>=</span> <span class=p>{</span>
    <span class=n>export</span> <span class=n>action</span> <span class=n>append</span><span class=p>(</span><span class=n>val</span><span class=kt>:</span><span class=n>byte</span><span class=p>)</span>
    <span class=kr>import</span> <span class=nn>action</span> <span class=n>show</span><span class=p>(</span><span class=n>content</span><span class=kt>:</span><span class=n>file</span><span class=p>)</span>
    <span class=kr>instance</span> <span class=n>sock</span> <span class=kt>:</span> <span class=n>net</span><span class=o>.</span><span class=n>socket</span>
    <span class=n>var</span> <span class=n>contents</span> <span class=kt>:</span> <span class=n>file</span>

    <span class=n>after</span> <span class=n>init</span><span class=p>{</span>
        <span class=n>contents</span> <span class=kt>:=</span> <span class=n>file</span><span class=o>.</span><span class=n>empty</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>implement</span> <span class=n>append</span> <span class=p>{</span>
        <span class=n>contents</span> <span class=kt>:=</span> <span class=n>contents</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
        <span class=n>sock</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>host</span><span class=p>(</span><span class=mi>1</span><span class=o>-</span><span class=n>self</span><span class=p>)</span><span class=o>.</span><span class=n>sock</span><span class=o>.</span><span class=n>id</span><span class=p>,</span> <span class=n>val</span><span class=p>);</span>
        <span class=n>show</span><span class=p>(</span><span class=n>contents</span><span class=p>);</span>
    <span class=p>}</span>

    <span class=n>implement</span> <span class=n>sock</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=n>src</span><span class=kt>:</span><span class=n>tcp</span><span class=o>.</span><span class=n>endpoint</span><span class=p>,</span> <span class=n>val</span><span class=kt>:</span><span class=n>byte</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>contents</span> <span class=kt>:=</span> <span class=n>contents</span><span class=o>.</span><span class=n>append</span><span class=p>(</span><span class=n>val</span><span class=p>);</span>
        <span class=n>show</span><span class=p>(</span><span class=n>contents</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Then we form our specification based on the guarantee that if all sent messages are delivered, the two replicas are identical. The specification is equivalent to the <em>guarded command</em> we&rsquo;ve talked about earlier.</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>specification</span> <span class=p>{</span>
    <span class=n>var</span> <span class=n>msg_count</span> <span class=kt>:</span> <span class=n>nat</span>

    <span class=n>after</span> <span class=n>init</span> <span class=p>{</span>
        <span class=n>msg_count</span> <span class=kt>:=</span> <span class=mi>0</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>after</span> <span class=n>host</span><span class=o>.</span><span class=n>sock</span><span class=o>.</span><span class=n>send</span><span class=p>(</span><span class=n>self</span><span class=kt>:</span><span class=n>pid</span><span class=p>,</span> <span class=n>dst</span><span class=kt>:</span><span class=n>tcp</span><span class=o>.</span><span class=n>endpoint</span><span class=p>,</span> <span class=n>val</span><span class=kt>:</span><span class=n>byte</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>msg_count</span> <span class=kt>:=</span> <span class=n>msg_count</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>
    <span class=p>}</span>

    <span class=n>after</span> <span class=n>host</span><span class=o>.</span><span class=n>sock</span><span class=o>.</span><span class=n>recv</span><span class=p>(</span><span class=n>self</span><span class=kt>:</span><span class=n>pid</span><span class=p>,</span> <span class=n>src</span><span class=kt>:</span><span class=n>tcp</span><span class=o>.</span><span class=n>endpoint</span><span class=p>,</span> <span class=n>val</span><span class=kt>:</span><span class=n>byte</span><span class=p>)</span> <span class=p>{</span>
        <span class=n>msg_count</span> <span class=kt>:=</span> <span class=n>msg_count</span> <span class=o>-</span> <span class=mi>1</span><span class=p>;</span>
        <span class=n>ensure</span> <span class=n>msg_count</span> <span class=ow>=</span> <span class=mi>0</span> <span class=ow>-&gt;</span> <span class=n>host</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>contents</span><span class=o>.</span><span class=n>eq</span><span class=p>(</span><span class=n>host</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>contents</span><span class=p>);</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>We wrote the above code into a file named <code>append.ivy</code> and we generate the testing code using <code>ivyc target=test append.ivy</code>. Then we run the code using <code>ivy_launch append.ivy</code>.</p>
<p>Interestingly, the program yields an error message:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text>`ivy_shell`; ./append &#34;[[0,{addr:0x7f000001,port:49124}],[1,{addr:0x7f000001,port:49125}]]&#34;
&gt; host.append(1,251)
&lt; host.show(1,[251])
&lt; host.show(0,[251])
&gt; host.append(1,46)
&lt; host.show(1,[251,46])
&gt; host.append(0,183)
&lt; host.show(0,[251,183])
&lt; host.show(0,[251,183,46])
&lt; host.show(1,[251,46,183])
assertion_failed(&#34;append.ivy: line 49&#34;)
append.ivy: line 49: error: assertion failed
</code></pre></div><p>What happens is the program generates tests that randomizes message arrival times and we can see a delivered message may arrive after its target sends another message, therefore creating corrupted file contents.</p>
<p>Notice that here we are actually running on real network to find counter examples, the downside is the test may be arbitrary long depending on the randomized testing cases. Instead, we will use bounded model checking (BMC) to test if the specification is correct. This way we can reply purely on the logic of our specification instead of running on the real network. The Ivy checker uses <a href=https://en.wikipedia.org/wiki/Z3_Theorem_Prover>Z3 Theorem Prover</a>.</p>
<blockquote>
<p>BMC construct a boolean formula that is satisfiable if and only if the underlying state transition system can realize a finite sequence of state transitions that reaches certain states of interest.</p>
</blockquote>
<p>To tell Ivy using bounded model checking, we add the following lines to <code>append.ivy</code>:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-haskell data-lang=haskell><span class=nf>axiom</span> <span class=n>host</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span><span class=o>.</span><span class=n>sock</span><span class=o>.</span><span class=n>id</span> <span class=o>~=</span> <span class=n>host</span><span class=p>(</span><span class=mi>1</span><span class=p>)</span><span class=o>.</span><span class=n>sock</span><span class=o>.</span><span class=n>id</span>

<span class=nf>attribute</span> <span class=n>method</span><span class=ow>=</span><span class=n>bmc</span><span class=p>[</span><span class=mi>10</span><span class=p>]</span>
</code></pre></div><p>Executing <code>ivy_check detailed=false append.ivy</code>, we see an error message:</p>
<div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text>&gt; host.append(1,80)
&lt; host.show(1,[80])
&gt; host.append(0,64)
&lt; host.show(0,[64])
&gt; host.sock.recv(0,{tcp.endpoint.addr:...,tcp.endpoint.port:...},80)
&lt; host.show(0,[64,80])
&gt; host.sock.recv(1,{tcp.endpoint.addr:...,tcp.endpoint.port:...},64)
&lt; host.show(1,[80,64])
append.ivy: line 49: error: assertion failed
</code></pre></div><p>Sometimes BMC can help us find the error faster because it is systematically checking all possible actions. However, increasing the number of steps for the BMC can result in the exploration space growing exponentially, so we are going to use some combination of BMC and randomized test cases.</p>
<div style=width:100% id=comment>
<script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script>
</div>
</article>
</main><footer id=footer>
<p>© 2022 Bodun Hu. All rights reserved.</p>
</footer>
</body>
</html>