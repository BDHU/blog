<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Monads in Haskell - std::bodun:blog</title><link rel=icon type=image/png href=/blog/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Monads in Haskell"><meta property="og:description" content="I&rsquo;ve scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads."><meta property="og:type" content="article"><meta property="og:url" content="https://www.bodunhu.com/blog/posts/monad/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-03-01T00:00:00+00:00"><meta property="article:modified_time" content="2020-03-01T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Monads in Haskell"><meta name=twitter:description content="I&rsquo;ve scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.bodunhu.com/blog/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.bodunhu.com/blog/css/main.css><link rel=stylesheet type=text/css href=https://www.bodunhu.com/blog/css/dark.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://www.bodunhu.com/blog/js/main.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><meta name=google-site-verification content="rCBqGFj-RPsmjg3Aho3_wEfipA1SHxSEDnsAZZrv_J8"></head><body><div class="container wrapper post"><div class=header><base href=https://www.bodunhu.com/blog/><h1 class=site-title><a href=https://www.bodunhu.com/blog/>std::bodun:blog</a></h1><div class=site-description><h2>PhD student at <a href=https://www.utexas.edu/>UT Austin</a>. OS, kernel, network, heterogeneity, anything system.</h2><nav class="nav social"><ul class=flat><a href=https://twitter.com/BodunHu title=Twitter><i data-feather=twitter></i></a><a href=https://github.com/BDHU/ title=Github><i data-feather=github></i></a><a href=/blog/index.xml title=RSS><i data-feather=rss></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/blog/>Home</a></li><li><a href=/blog/posts>All posts</a></li><li><a href=/blog/about>About</a></li><li><a href=/blog/tags>Tags</a></li><li><a href="https://www.google.com/search?sitesearch=https%3A%2F%2Fwww.bodunhu.com/blog%2F&q=">Search</a></li></ul></nav></div><div class=post-header><h1 class=title>Monads in Haskell</h1><div class=meta>Posted at &mdash; Mar 1, 2020</div></div><div class=markdown><p>I&rsquo;ve scratched my head for quite a while trying to understand the concept of monad in Haskell. This is a brief summary of monads. I take William Cook&rsquo;s <a href=http://www.cs.utexas.edu/~wcook/anatomy/anatomy.htm>Anatomy of Programming Languages</a> as my reference.</p><h2 id=definitions-of-monads>Definitions of Monads</h2><p>A monad is defined as a computational structure that involves three parts:</p><ul><li>A generic data type \(m\)</li><li>A <em>return</em> function \(return_m\) :: \(t\rightarrow mt\)</li><li>A <em>bind</em> function \(\triangleright_mt\rightarrow (t\rightarrow ms)\rightarrow ms\)</li></ul><p>Here the symbol \(m\) gives the name of the monad as well as the shape of the computation. We can call the program that uses the monad \(m\) as an m-computation. The instantiation of the generic type \(mt\) at a particular type \(t\) represents n m-computation that produces a value of type \(t\). The \(m\)-computation indicates that in addition to value \(t\), some additional requirements or effects will take place. This is the essence of monads.</p><p>The definition of the <code>return</code> function states that how values are converted into m-computations. The <code>return</code> will just return the value of type \(t\). For example, if we pass in a stateful memory information, <code>return</code> shouldn&rsquo;t modify the actual but only provide a context to which the value lies in. The reason we convert value into m-computation is that if any error occur then <code>return</code> will catch the error without adding additional error checking codes.</p><p>The bind function \(\triangleright_m\) specifies how computations are combined together. THe general idea is that the computation behavior of \(A\triangleright_m F\) indicates the m-computation \(A\) is performed first, the value it produces wil be passed to the function \(F\) to create a second m-computation. Because \(A\) is a m-computation, if an error happens, the computation will stop and \(F\) will not be performed.</p><h2 id=monads-in-haskell>Monads in Haskell</h2><p>In Haskell, we can use Monads using type class. A type class is defined as:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#268bd2>class</span> <span style=color:#dc322f>Monad</span> m <span style=color:#268bd2>where</span>
  (<span style=color:#719e07>&gt;&gt;=</span>) <span style=color:#719e07>::</span> m t <span style=color:#719e07>-&gt;</span> (t <span style=color:#719e07>-&gt;</span> m s) <span style=color:#719e07>-&gt;</span> m s
  return <span style=color:#719e07>::</span> t <span style=color:#719e07>-&gt;</span> m t
</code></pre></div><p>For a object of generic type \(m\) to be a Monad, it must have those two functions defined. A type class allows us to overload functions according to their type.</p><p>So why do we need Monads in the first place? If we are given a function \(func1\) which takes in an Int value and produces an Int output, we could link the function together to form a chain of computation. If we make a function like this:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#268bd2>func1</span> <span style=color:#719e07>::</span> <span style=color:#dc322f>Int</span> <span style=color:#719e07>-&gt;</span> (<span style=color:#dc322f>Int</span>, <span style=color:#dc322f>Int</span>) <span style=color:#719e07>-&gt;</span> (<span style=color:#dc322f>Int</span>, <span style=color:#dc322f>Int</span>) 
<span style=color:#268bd2>x</span> <span style=color:#719e07>&amp;</span> func1 <span style=color:#719e07>=</span> func1 x
</code></pre></div><p>we could use the output of the function as the input to the same function to produce another value. This process can be repeated and thus form a chain of operation:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>(<span style=color:#2aa198>0</span>, <span style=color:#2aa198>0</span>) <span style=color:#719e07>&amp;</span> func1 <span style=color:#2aa198>1</span> <span style=color:#719e07>&amp;</span> func1 <span style=color:#2aa198>2</span> <span style=color:#719e07>&amp;</span> func1 <span style=color:#2aa198>3</span> <span style=color:#719e07>...</span>
</code></pre></div><p>However, the function \(func1\) could potentially return a Nothing if the given input doesn&rsquo;t meet certain standards (exp. devide by 0). Therefore, \(func1\) can modified to:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#268bd2>func1</span> <span style=color:#719e07>::</span> <span style=color:#dc322f>Int</span> <span style=color:#719e07>-&gt;</span> (<span style=color:#dc322f>Int</span>, <span style=color:#dc322f>Int</span>) <span style=color:#719e07>-&gt;</span> <span style=color:#dc322f>Maybe</span> (<span style=color:#dc322f>Int</span>, <span style=color:#dc322f>Int</span>)
</code></pre></div><p>The previous definition of \(func1\) says \(func1\) takes a (Int, Int) tuple as one input, but now if we feed the output of \(func1\) directly to the next \(func1\) in the chain, error would occur because \(func1\) takes a raw (Int, Int) tuple as the input, but now we have (Int, Int) wrapped in a Maybe context. The & operator is not able to pass the argument with a context to the next func1. Fortunately, we have the bind operator defined.</p><p>If we look at the definition of the <strong>&#187;=</strong> in Monad definition, we see:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell>(<span style=color:#719e07>&gt;&gt;=</span>) <span style=color:#719e07>::</span> m t <span style=color:#719e07>-&gt;</span> (t <span style=color:#719e07>-&gt;</span> m s) <span style=color:#719e07>-&gt;</span> m s
</code></pre></div><p>This means <strong>&#187;=</strong> is able to take a value within certain context and map a function that takes the raw value as input to the it. We can simply switch the <strong>&</strong> operator to <strong>&#187;=</strong> such that the chaining would still work:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#268bd2>return</span> (<span style=color:#2aa198>0</span>, <span style=color:#2aa198>0</span>) <span style=color:#719e07>&gt;&gt;=</span> func1 <span style=color:#2aa198>1</span> <span style=color:#719e07>&gt;&gt;=</span> func1 <span style=color:#2aa198>2</span> <span style=color:#719e07>&gt;&gt;=</span> func1 <span style=color:#2aa198>3</span> <span style=color:#719e07>...</span>
</code></pre></div><p>If an error occurred in one part of the chain (let&rsquo;s assume one computation yields Nothing). Then the Nothing value will be propagated to the next function, whill will automatically generate an error, or Nothing. Otherwise we would have written error checking code at the end of each single computation to check their output.</p><p>In short, <strong>&#187;=</strong> is just a way to chain functions with parametric polymorphism together.</p><h2 id=haskell-do-notation>Haskell <em>do</em> Notation</h2><p>Using the do notation can simply the use of bind operator. The basic pattern of do notation is:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#268bd2>do</span>
  x <span style=color:#719e07>&lt;-</span> e1
  e2
</code></pre></div><p>which is equivalent to:</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=color:#268bd2>e1</span> <span style=color:#719e07>&gt;&gt;=</span> (<span style=color:#268bd2>\</span>lambda x<span style=color:#719e07>.</span>e2)
</code></pre></div><p>The <strong>&lt;-</strong> notation simply indicates \(x\) is bind to the value the computation generates. In other words, \(x\) doesn&rsquo;t lie in a context. if \(e1\) returns Nothing, \(x\) is not bind to anything. It&rsquo;s important to remember that do expressions are just different syntax for chaining monadic values.</p><p>For a more detailed explaination of Monads, I found <a href=http://learnyouahaskell.com/a-fistful-of-monads>A Fistful of Monads</a> to be extremely helpful in terms of clarifying the concept.</p></div><div class=post-tags><nav class="nav tags"><ul class=flat><li><a href=/blog/tags/pl>PL</a></li></ul></nav></div><script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script></div><div class="footer wrapper"><nav class=nav><div>Copyright © 2017-present, Bodun. All Rights Reserved | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>