<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=author content="Liste - https://www.bodunhu.com/blog/">
<title>Writing Specifications in a Distributed System using Ivy | std::bodun::blog</title>
<meta name=description content="Before we jump into how to write specifications in a distributed setting, we first define what a specification is. I take the definition from the magnificent [Ken McMillan](http://mcmil.net/wordpress/): a specification is a *statement*">
<meta property="og:title" content="Writing Specifications in a Distributed System using Ivy">
<meta property="og:description" content="Before we jump into how to write specifications in a distributed setting, we first define what a specification is. I take the definition from the magnificent [Ken McMillan](http://mcmil.net/wordpress/): a specification is a *statement*">
<meta property="og:type" content="article">
<meta property="og:url" content="https://www.bodunhu.com/blog/posts/writing-specifications-in-a-distributed-system-using-ivy/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2021-09-08T00:00:00+00:00">
<meta property="article:modified_time" content="2021-09-11T23:33:58-05:00">
<meta itemprop=name content="Writing Specifications in a Distributed System using Ivy">
<meta itemprop=description content="Before we jump into how to write specifications in a distributed setting, we first define what a specification is. I take the definition from the magnificent [Ken McMillan](http://mcmil.net/wordpress/): a specification is a *statement*"><meta itemprop=datePublished content="2021-09-08T00:00:00+00:00">
<meta itemprop=dateModified content="2021-09-11T23:33:58-05:00">
<meta itemprop=wordCount content="986">
<meta itemprop=keywords content="distributed-system,ivy,">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Writing Specifications in a Distributed System using Ivy">
<meta name=twitter:description content="Before we jump into how to write specifications in a distributed setting, we first define what a specification is. I take the definition from the magnificent [Ken McMillan](http://mcmil.net/wordpress/): a specification is a *statement*">
<meta name=twitter:site content="@https://twitter.com/BodunHu">
<link rel=canonical href=https://www.bodunhu.com/blog/posts/writing-specifications-in-a-distributed-system-using-ivy/>
<meta name=monetization content="$twitter.xrptipbot.com/ronaldsvilcins">
<link rel=dns-prefetch href=https://www.google-analytics.com>
<link href=https://www.google-analytics.com rel=preconnect crossorigin>
<link rel=alternate type=application/atom+xml title=std::bodun::blog href=https://www.bodunhu.com/blog/atom.xml>
<link rel=alternate type=application/json title=std::bodun::blog href=https://www.bodunhu.com/blog/feed.json>
<link rel="shortcut icon" href=/blog/images/favicon.ico type=image/x-icon>
<style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1rem/1.5 '-apple-system',BlinkMacSystemFont,avenir next,avenir,helvetica,helvetica neue,ubuntu,roboto,noto,segoe ui,arial,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:2rem;color:#000}.skip-link{position:absolute;top:-40px;left:0;background:#eee;z-index:100}.skip-link:focus{top:0}h1,h2,h3,h4,h5,strong,b{font-size:inherit;font-weight:600}header{line-height:2;padding-bottom:1.5rem}.link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.time{font-variant-numeric:tabular-nums;white-space:nowrap}blockquote{border-left:5px solid #eee;padding-left:1rem;margin:0}a,a:visited{color:inherit}a:hover,a.heading-link{text-decoration:none}pre{padding:.5rem;overflow:auto;overflow-x:scroll;overflow-wrap:normal}code,pre{font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:normal;font-size:small;background:#eee}code{padding:.1rem;border:none}ul{list-style-type:square}ul,ol{padding-left:1.2rem}.list{line-height:2;list-style-type:none;padding-left:0}.list li{padding-bottom:.1rem}.meta{color:#777}.content{max-width:70ch;margin:0 auto}header{line-height:2;display:flex;justify-content:space-between;padding-bottom:1rem}header a{text-decoration:none}header ul{list-style-type:none;padding:0}header li,header a{display:inline}h2.post{padding-top:.5rem}header ul a:first-child{padding-left:1rem}.nav{height:1px;background:#000;content:'';max-width:10%}.list li{display:flex;align-items:baseline}.list li time{flex:initial}.hr-list{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px dotted #ccc;flex:1 0 1rem}.hr-list-none{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:1px #ccc;flex:1 0 1rem}.m,hr{border:0;margin:3rem 0}img{max-width:100%;height:auto}</style>
<script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","articleSection":"posts","name":"Writing Specifications in a Distributed System using Ivy","headline":"Writing Specifications in a Distributed System using Ivy","alternativeHeadline":"","description":"Before we jump into how to write specifications in a distributed setting, we first define what a specification is. I take the definition from the magnificent [Ken McMillan](http:\/\/mcmil.net\/wordpress\/): a specification is a *statement*","inLanguage":"en-us","isFamilyFriendly":"true","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.bodunhu.com\/blog\/posts\/writing-specifications-in-a-distributed-system-using-ivy\/"},"author":{"@type":"Person","name":""},"creator":{"@type":"Person","name":""},"accountablePerson":{"@type":"Person","name":""},"copyrightHolder":"std::bodun::blog","copyrightYear":"2021","dateCreated":"2021-09-08T00:00:00.00Z","datePublished":"2021-09-08T00:00:00.00Z","dateModified":"2021-09-11T23:33:58.00Z","publisher":{"@type":"Organization","name":"std::bodun::blog","url":"https://www.bodunhu.com/blog/","logo":{"@type":"ImageObject","url":"https:\/\/www.bodunhu.com\/blog\/","width":"32","height":"32"}},"image":"https://www.bodunhu.com/blog/","url":"https:\/\/www.bodunhu.com\/blog\/posts\/writing-specifications-in-a-distributed-system-using-ivy\/","wordCount":"986","genre":["distributed-system","ivy"],"keywords":["distributed-system","ivy"]}</script>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
</head>
<body>
<a class=skip-link href=#main>Skip to main</a>
<main id=main>
<div class=content>
<header>
<p style=padding:0;margin:0><a href=/blog/><b>std::bodun::blog</b></a></p>
<ul style=padding:0;margin:0>
<li><a href=https://www.bodunhu.com/>About</a></li>
</ul>
</header>
<hr class=hr-list style=padding:0;margin:0>
<h2 class=post>Writing Specifications in a Distributed System using Ivy</h2>
<p>Before we jump into writing specifications in a distributed setting, we first define what a specification is. I take the definition from the magnificent <a href=http://mcmil.net/wordpress/>Ken McMillan</a>: a specification is a <em>statement</em>.</p>
<p>A statement describes an abstract view of a program. The view itself is often at an interface, which hides or abstracts internal states. A specification is stated in terms of two elements:</p>
<ul>
<li>Assumption: properties of the environment the system relies on</li>
<li>Guarantee: properties that most hold <em>if</em> the assumption(s) is met</li>
</ul>
<p>The way we write specifications is through an abstract program that observes or monitors all program events. This abstract program is able to remember the execution history of program being monitored, and decides, at any given moment, whether an action is allowable according to the specification.</p>
<p>One way to implement this abstract monitor program is to use guarded command form:</p>
<ul>
<li>Let \(A\) be a set of program actions</li>
<li>An event \(e(x_1,\ &mldr;,\ x_n)\) is an action \(e\in A\) with parameter values \(x_1,\ &mldr;,\ x_n\) of the right types for \(e\).</li>
<li>Let \(S\) be a set of states and \(s_0 \in S\) be the initial state.</li>
<li>Guarded command set \(G\) is specified as:</li>
</ul>
<p>\[e(V):\ \gamma (S,V) \rightarrow {S := \tau(S, V)}\]</p>
<p>It means if a guarded command \(\gamma\) determines a given event \(e\) satisfies certain specifications with parameter \(V\) under state \(S\), then we accept the code and then deterministically update the state with a function \(\tau\).</p>
<p>The observation \(E\) of system is going to be a finite sequence of events, which corresponds to the system behavior, denoted as \(e_0(V_0)&mldr;e_{n-1}(V_{n-1})\). A run of \(E\) is a state sequence \(s_0\ &mldr;s_n\) such that for \(i\in 0\ &mldr; n- 1\), \(\gamma(s_i, V_i)\) is true and \(s_{i+1} = \tau(s_i, v_i)\). Observation \(E\) is accepted by the specification iff it has a run. We can test whether an observation is accepted by just executing the guarded commands. In layman&rsquo;s term, if all guarded commands accepts the their corresponding event at a given time, then the sequence events must satisfy our specification and should be accepted.</p>
<p>Now let&rsquo;s replicated file as an example. Out first informal attempt to the specification for &ldquo;append&rdquo; operation would be:</p>
<ul>
<li>Assumption: network is ordered and non-duplicating</li>
<li>Guarantee: if no further append requests, eventually replicas are equal</li>
</ul>
<p>However, the problem with this specification is that this is a liveness property, meaning that we can&rsquo;t practically test such property by observing a finite sequence of events. Therefore, we resort to a different safety specification we can test:</p>
<ul>
<li>If all sent messages are delivered, the two replicas are identical.</li>
</ul>
<p>Now we convert liveness to safety by explicitly defining the moment hen the eventuality should hold.</p>
<blockquote>
<p>Liveness property means a good thing eventually happens. A liveness property can be <em>refuted</em> by finite execution. Safety property means a bad thing never happens. A safety property can always be refuted by a finite execution.</p>
</blockquote>
<p>To see how replicated file specification plays in action, we use the example given in <a href=http://mcmil.net/wordpress/>Prof. McMillan</a>&rsquo;s presentation. The code is written in <a href=http://microsoft.github.io/ivy/language.html>Ivy</a> and is pretty self-explanatory. In this demo we only have two processes.</p>
<blockquote>
<p>To install Ivy, simply execute <code>virtualenv ivyenv && source ivyenv/bin/activate && pip install ms-ivy</code>. This is tested on Ubuntu 18.04 LTS and may vary slight on other distros.</p>
</blockquote>
<pre><code class=language-haskell>#lang ivy1.8

include numbers
include collections
include network

global {
    alias byte = uint[8]
    instance file : vector(byte)
    type pid = {0..1}
    instance net : tcp.net(byte)
}

process host(self:pid) = {
    export action append(val:byte)
    import action show(content:file)
    instance sock : net.socket
    var contents : file

    after init{
        contents := file.empty;
    }

    implement append {
        contents := contents.append(val);
        sock.send(host(1-self).sock.id, val);
        show(contents);
    }

    implement sock.recv(src:tcp.endpoint, val:byte) {
        contents := contents.append(val);
        show(contents);
    }
}
</code></pre>
<p>Then we form our specification based on the guarantee that if all sent messages are delivered, the two replicas are identical. The specification is equivalent to the <em>guarded command</em> we&rsquo;ve talked about earlier.</p>
<pre><code class=language-haskell>specification {
    var msg_count : nat

    after init {
        msg_count := 0;
    }

    after host.sock.send(self:pid, dst:tcp.endpoint, val:byte) {
        msg_count := msg_count + 1;
    }

    after host.sock.recv(self:pid, src:tcp.endpoint, val:byte) {
        msg_count := msg_count - 1;
        ensure msg_count = 0 -&gt; host(0).contents.eq(host(1).contents);
    }
}
</code></pre>
<p>We wrote the above code into a file named <code>append.ivy</code> and we generate the testing code using <code>ivyc target=test append.ivy</code>. Then we run the code using <code>ivy_launch append.ivy</code>.</p>
<p>Interestingly, the program yields an error message:</p>
<pre><code class=language-text>`ivy_shell`; ./append &quot;[[0,{addr:0x7f000001,port:49124}],[1,{addr:0x7f000001,port:49125}]]&quot;
&gt; host.append(1,251)
&lt; host.show(1,[251])
&lt; host.show(0,[251])
&gt; host.append(1,46)
&lt; host.show(1,[251,46])
&gt; host.append(0,183)
&lt; host.show(0,[251,183])
&lt; host.show(0,[251,183,46])
&lt; host.show(1,[251,46,183])
assertion_failed(&quot;append.ivy: line 49&quot;)
append.ivy: line 49: error: assertion failed
</code></pre>
<p>What happens is the program generates tests that randomizes message arrival times and we can see a delivered message may arrive after its target sends another message, therefore creating corrupted file contents.</p>
<p>Notice that here we are actually running on real network to find counter examples, the downside is the test may be arbitrary long depending on the randomized testing cases. Instead, we will use bounded model checking (BMC) to test if the specification is correct. This way we can reply purely on the logic of our specification instead of running on the real network. The Ivy checker uses <a href=https://en.wikipedia.org/wiki/Z3_Theorem_Prover>Z3 Theorem Prover</a>.</p>
<blockquote>
<p>BMC construct a boolean formula that is satisfiable if and only if the underlying state transition system can realize a finite sequence of state transitions that reaches certain states of interest.</p>
</blockquote>
<p>To tell Ivy using bounded model checking, we add the following lines to <code>append.ivy</code>:</p>
<pre><code class=language-haskell>axiom host(0).sock.id ~= host(1).sock.id

attribute method=bmc[10]
</code></pre>
<p>Executing <code>ivy_check detailed=false append.ivy</code>, we see an error message:</p>
<pre><code class=language-text>&gt; host.append(1,80)
&lt; host.show(1,[80])
&gt; host.append(0,64)
&lt; host.show(0,[64])
&gt; host.sock.recv(0,{tcp.endpoint.addr:...,tcp.endpoint.port:...},80)
&lt; host.show(0,[64,80])
&gt; host.sock.recv(1,{tcp.endpoint.addr:...,tcp.endpoint.port:...},64)
&lt; host.show(1,[80,64])
append.ivy: line 49: error: assertion failed
</code></pre>
<p>Sometimes BMC can help us find the error faster because it is systematically checking all possible actions. However, increasing the number of steps for the BMC can result in the exploration space growing exponentially, so we are going to use some combination of BMC and randomized test cases.</p>
<hr class=hr-list>
<footer>
<p>© 2016-2021 <a href=https://www.bodunhu.com/>Bodun Hu</a>. All rights reserved. </p>
</footer>
</div>
</main>
</body>
</html>