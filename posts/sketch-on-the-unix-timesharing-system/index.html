<!doctype html><html><head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Personal Blog of Bodun (Edward) Hu. CS PhD student at University of Texas at Austin. Operating systems, network, heterogeneity, MLSys, anything system. UTCS">
<link rel="shortcut icon" href=https://www.bodunhu.com/blog/favicon.ico>
<link rel=stylesheet href=/blog/css/style.min.css>
<script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script>
<script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<link href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css rel=stylesheet>
<title>Sketch on the UNIX Timesharing System</title>
</head>
<body><header id=banner>
<h2><a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></h2>
<nav>
<ul>
<li>
<a href=/blog/posts/ title=posts>archive</a>
</li><li>
<a href=https://www.bodunhu.com/ title=about>about</a>
</li>
</ul>
</nav>
</header>
<main id=content>
<article>
<header id=post-header>
<h1>Sketch on the UNIX Timesharing System</h1>
<div>
Updated <time>May 19, 2021</time>
</div>
</header><p>Unix is general-purpose, multi-user, interactive operating system, it offers
several new features hardly found in other larger operating systems back in
the day. These features include (1) a hierarchical file system incorporating demountable volumes; (2) compatible file, device, and inter-process I/O; (3) the ability to initiate asynchronous processes; (4) system command language selectable on a per-user basis; and (5) over 100 subsystems including a dozen languages.</p>
<h2 id=simplicity-at-its-core>Simplicity at its Core</h2>
<p>Simplicity was engraved into the gene of Unix since its birth, as the paper states: &ldquo;Perhaps the most important achievement of UNIX is to demonstrate that a powerful operating system for interactive use need not be expensive either in equipment or in human effort&rdquo;. Therefore, it is important to keep in mind how simplicity
is reflected in the design of Unix.</p>
<h2 id=the-file-system>The File System</h2>
<p>Perhaps the singly most important part of Unix. The &ldquo;everything is file&rdquo; concept that influences all modern system designs. Here is a short description of each major file types.</p>
<ul>
<li><strong>Ordinary Files</strong>: no particular structuring is expected by the system. The structure of files is controlled by the programs which use them, not by the system.</li>
<li><strong>Directories</strong> provide the mapping between the names of files and the files themselves, inducing a structure on the file system. The only difference between directory and normal file is the the directory can&rsquo;t be written on by unprivileged programs, meaning the contents of directories are controlled by the system.</li>
</ul>
<blockquote>
<p><em>linking</em> allows the same non-directory file to appear in several directories under possibly different names; a directory entry for a file is sometimes called a link. All links to a file have equal rights. A directory entry for a file consists merely of its name and a pointer to the file metadata. Therefore a file exists independently of any
directory entry. Directory can be considered as link.</p>
</blockquote>
<ul>
<li><strong>Special Files</strong>: perhaps the most prominent feature of the &ldquo;everything is a file&rdquo; principle. They are read and written just like ordinary disk files, but requests to read and write will result in activation of the I/O device. It blurs the line between file and device I/O since they share identical interfaces and are subject to the same protection mechanism.</li>
</ul>
<h2 id=removable-file-system>Removable File System</h2>
<p>The Unix file system has a <em>mount</em> system request which, in effect, replaces a leaf of the hierarchy tree (the ordinary file) by a whole new subtree (the hierarchy stored on the removable volume). It provides a unified abstraction of the file system hierarchy where the underlying storage components become transparent to the user.</p>
<blockquote>
<p>One exception to the identical treatment of files on different devices: no link may exist between one file sys hierarchy and another. Otherwise, some form of bookkeeping would be required to when a removable volume is dismounted from one file system but not the other.</p>
</blockquote>
<h2 id=protection>Protection</h2>
<p>Each user is assigned a unique user ID. A file, upon its creation, is marked with the user ID of its owner. Also given for new files is a set of seven protection bits. Six of these specify independently read, write, and execute permission for the owner of the file and for all other users. This is a perfect example of ACL (access control list) system.</p>
<h2 id=io-calls>I/O Calls</h2>
<p>Once again, we see how Unix is trying to provide a unified interface such that performing I/O on different devices doesn&rsquo;t would not require different accessing patterns or styles. There is no distinction between &ldquo;random&rdquo; and sequential I/O, nor is any logical record size imposed by the system. Calls like <em>open</em>, <em>seed</em>, <em>read</em>, and <em>write</em> can be found in all major Unix-like systems today.</p>
<p>I found it interesting that the authors were arguing why there are no user-visible locks in the file system. The first argument says: &ldquo;they are unnecessary because we are not faced with large, single-file data bases maintained by independent processes&rdquo;. It might be different today on modern systems so I have some doubts on that argument. The next one is &ldquo;they are insufficient because locks in the ordinary sense, whereby one user is prevented from writing on a file which another user is reading, cannot prevent confusion when, for example, both users are editing a file with an editor which makes a copy of the file being edited.&rdquo; This certainly is true because the the copies are separate files with distinct metadata during editing but once the editing is finished then it becomes tricky when the updated content needs to be written back to the original file without some form of synchronization or ordering.</p>
<p>The paper further explains the the system has sufficient internal interlocks to prevent these situations from happening. The exact details of how it works is not quite clear at this stage.</p>
<h2 id=implementation>Implementation</h2>
<p>As we&rsquo;ve already known, a directory entry contains only a name for the associated file and a pointer to the file itself. This pointer is an integer called the <em>i-number</em>. When the file is accessed, its i-number is used as an index into a system table (the i-list) stored in a known part of the device on which the directory resides.</p>
<blockquote>
<p>Directory entry -> (File Name, i-number) -> i-list -> i-node -> description of the file</p>
</blockquote>
<p>Because the file is described by its corresponding i-node, any copy and deleting operations are circulating around modifying directory entry or i-node link-count field without actually touching the bulk of the file itself.</p>
<blockquote>
<p>It important to distinguish between file descriptor and inode. By definition, files are represented by inodes. The inode of a file is a structure kept by the filesystem which holds information about a file, like its type, owner, permissions, inode links count and so on. Other other hand, the file descriptor is the value returned by an open call is termed a file descriptor and is essentially an index into an array of open files kept by the kernel. There is an inode in the i-list but every process can have its own file descriptor for one file.</p>
</blockquote>
<h2 id=processes>Processes</h2>
<p>A process is the execution of an image. An image is a computer execution environment. It includes a core image, general register values, status of open files, current directory, and the like. An image is the current state of a pseudo computer. You can imagine the image as a motionless snapshot of current state of the processor, or you can image as the content saved to the main memory when a currently executing process is preemptied by another one.</p>
<p>The user-core part of an image has three logical segments. The program text segments starting from location 0. At the first 8K byte boundary above the text segment is a non-shared, writable data segment. The highest address in the virtual address space is a stack segment.</p>
<p>One key feature of UNIX is a new process can come into existence only by ise of the <em>fork</em> system call. Another system primitive is invoked by <em>execute</em>. This call resembles a &ldquo;jump&rdquo; machine instruction rather than a sub-routine call.</p>
<h2 id=shell>Shell</h2>
<p>Shell is a command line interpreter. Programs executed by the Shell start off with two open files which have file descriptors 0 and 1, representing files for reading and writing. The symbol &ldquo;&lt;&rdquo; and &ldquo;>&rdquo; represent what files the file descriptor 0 and 1 will refer to for the duration of the command passed to shell.</p>
<p>A filter, represented by &ldquo;|&rdquo;, is a program that copies its standard input to its standard output (without processing).</p>
<p>Command separator, represented by &ldquo;;&rdquo;, is used to separate multiple commands. A related feature is &ldquo;&&rdquo;, which execute the command in the background. When the shell doesn&rsquo;t wait for the completion of a command, the identification of the process running that command is printed. In addition, parentheses can be used to enforce order of execution.</p>
<blockquote>
<p>It&rsquo;s worth noting the shell is itself a command, and may be called recursively.<br>
Since it&rsquo;s a command, it also shared the luxury of having standard I/O file descriptor. Thus, command such as:<br>
<strong>sh &lt; file_containing_shell_commands</strong> would work.</p>
</blockquote>
<p>The last step in the initialization of UNIX is the creation of a single process and the invocation of a program called <em>init</em>. <em>init</em> have various sub-instances prompting for user login information. If the login succeeds, <em>init</em> performs an <em>execute</em> of the Shell. Essentially, <em>init</em> is the parent process of Shell.</p>
<div style=width:100% id=comment>
<script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script>
</div>
</article>
</main><footer id=footer>
<p>Copyright © 2021 Bodun Hu. All rights reserved.</p>
</footer></body>
</html>