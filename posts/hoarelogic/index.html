<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Hoare Logic | std::bodun::blog</title><meta name=keywords content="PL,algorithm,theory,logic,verification"><meta name=description content="Hoare logic forms the basis of all deductive verification. To illustrate Hoare logic, we will first consider a smaller imperative programming language IMP."><meta name=author content><link rel=canonical href=https://www.bodunhu.com/blog/posts/hoarelogic/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/blog/assets/css/stylesheet.min.758151a3f029732139c5ed917da59127bed78e4d7fce57610c1cd24d4cb52b2a.css integrity="sha256-dYFRo/ApcyE5xe2RfaWRJ77Xjk1/zldhDBzSTUy1Kyo=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.cs.utexas.edu/sites/default/files/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.utexas.edu/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.utexas.edu/favicon-32x32.png><link rel=apple-touch-icon href=https://www.utexas.edu/apple-touch-icon.png><link rel=mask-icon href=https://www.cs.utexas.edu/sites/default/files/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Hoare Logic"><meta property="og:description" content="Hoare logic forms the basis of all deductive verification. To illustrate Hoare logic, we will first consider a smaller imperative programming language IMP."><meta property="og:type" content="article"><meta property="og:url" content="https://www.bodunhu.com/blog/posts/hoarelogic/"><meta property="og:image" content="https://www.bodunhu.com/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-17T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-17T00:00:00+00:00"><meta property="og:site_name" content="std::bodun::blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.bodunhu.com/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Hoare Logic"><meta name=twitter:description content="Hoare logic forms the basis of all deductive verification. To illustrate Hoare logic, we will first consider a smaller imperative programming language IMP."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.bodunhu.com/blog/posts/"},{"@type":"ListItem","position":2,"name":"Hoare Logic","item":"https://www.bodunhu.com/blog/posts/hoarelogic/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Hoare Logic","name":"Hoare Logic","description":"Hoare logic forms the basis of all deductive verification. To illustrate Hoare logic, we will first consider a smaller imperative programming language IMP.","keywords":["PL","algorithm","theory","logic","verification"],"articleBody":"Hoare logic forms the basis of all deductive verification. To illustrate Hoare logic, we will first consider a smaller imperative programming language IMP.\nIn IMP, we have three program constructs: expressions, conditionals, and statements:\n  Expression takes the form \\( E := Z\\ |\\ V\\ |\\ e_1 + e_2\\ |\\ e_1 \\times e_2 \\)\n  Conditional is self-explanatory: \\( C := true\\ |\\ false\\ |\\ e_1 = e_2\\ |\\ e_1 \\leq e_2 \\)\n  Statement consists of several different forms:\n \\(S := V := E\\) (Assignment) \\(S_1; S_2\\) (Composition) if \\(C\\) then \\(S_1\\) else \\(S_2\\) (If) while \\(C\\) do \\(S\\) (While)    Hoare Triple In Hoare logic, we specify partial correctness of programs using Hoare triples:\n\\[\\{P\\} S \\{Q\\}\\]\nHere \\(P\\) is the precondition and \\(Q\\) is the post-condition. $S$ is a statement in IMP.\nThe interpretation of Hoare triple is as follows:\n  if \\(S\\) is executed in a state satisfying \\(P\\)\n  and if execution of \\(S\\) terminates\n  then the program state after \\(S\\) terminates satisfies \\(Q\\)\n  Here an example, \\(\\{x = 0 \\} while\\ true\\ do\\ x := 0\\ \\{x = 1 \\}\\) is a valid Hoare triple because the execution of the statement never terminates, thus satisfying the requirement posed by Hoare triple.\nThus the specification \\(\\{P\\} S \\{Q\\}\\) is called partial correctness spec, because it doesn’t require \\(S\\) to terminate.\nThere is also a stronger requirement called total correctness. The total correctness specification is written as:\n\\[ [P] S [Q]\\]\nTotal correctness requires that if \\(P\\) is satisfied when executing \\(S\\), then \\(S\\) must terminate, and the post-conditional \\(Q\\) must be satisfied after \\(S\\) terminates.\nThus the example \\(\\{x = 0 \\} while\\ true\\ do\\ x := 0\\ \\{x = 1 \\}\\) is no longer valid because it never terminates.\nIn summary, we can say that Total correctness \\(=\\) Partial correctness \\(+\\) termination.\nProving Partial Correctness We use \\(\\vDash \\{P\\} S \\{Q\\} \\) to say a Hoare triple is valid and we use \\(\\vdash \\{P\\} S \\{Q\\} \\) to indicate we can prove validity of a Hoare triple.\nLet’s say we are given an assignment \\(x := y \\) with post-condition \\(x  2\\). The question is, what do we need to know before the assignment happens so that the post-condition, \\(x  2\\), holds afterwards?\nTo prove \\(Q\\) holds after the assignment \\(x := E\\), we need to show that \\(Q\\) with \\(E\\) substituting \\(x\\) holds before the assignment. Formally, we write it as:\n\\[\\vdash \\{Q[E / x]\\}\\ x := E \\{Q\\}\\]\nFor example, given \\( \\{ x+1 = n\\}\\ x := x+1 \\ \\{x=n\\} \\), we know this formula is provable because we can take \\(Q\\), which is \\(\\{x=n\\}\\), substituting \\(x\\) with \\(x+1\\) given we need to replace it with \\(E\\), and we will convert \\(x=n\\) to \\(x+1 = n\\), which matches the precondition.\nHere is another interesting example, given \\( \\{z = 2\\}y:= x \\{y = x\\} \\), this Hoare triple is valid but not provable. If we use the above substitution procedure, it will result in the precondition being \\(x=x\\) which is always true but is also different from the original precondition \\(z=2\\).\nIntuitively, we can prove the post-condition \\(y = x\\) given the statement \\(y = x\\) without any assumptions, so even if we do have assumptions like \\(z=2\\), we should still be able to prove it, and here comes proof rule for precondition strengthening.\nProof Rule for Precondition Strengthening Formally, we define precondition strengthening as:\n\\[ \\frac{ \\vDash \\{P'\\} S \\{Q\\}\\ \\ P \\Rightarrow P' }{\\vdash \\{P\\} S \\{Q\\}} \\]\nNow, with the original formula \\( \\{z = 2\\}y:= x \\{y = x\\} \\), we would derive \\( x= x \\equiv true \\). and since \\(z=2 \\rightarrow true\\) is valid, we can now prove the formula!\nA Dual: Post-Condition Weakening Formally, we define post-condition weakening as:\n\\[ \\frac{ \\vDash \\{P\\} S \\{Q'\\}\\ \\ Q' \\Rightarrow Q }{\\vdash \\{P\\} S \\{Q\\}} \\]\nWhat this means if that if we can prove a post-condition \\(Q'\\), we can always relax it to something weaker.\nFor example, given that \\(\\vdash \\{true\\}S\\{x=y \\land z=2\\}\\), we can prove \\(\\{true\\}S\\{x=y\\}\\) because \\(x=y\\) is a weaker condition of \\( x=y \\land z=2 \\).\nProof Rule for Composition For composition, we define the rule as:\n\\[ \\frac{ \\vdash \\{P\\}S_1\\{Q\\}\\ \\ \\vdash \\{Q\\}S_2 \\{R\\} }{ \\vdash \\{P\\}S_1;S_2\\{R\\} }\\]\nI won’t show why this is true, so this will be left as an exercise.\nProof Rule for If Statements Naturally, we define the rule for if statement as:\n\\[ \\frac{_{ \\vdash \\{P \\land C\\} S_1 \\{Q\\} }^{ \\vdash \\{P \\land \\neg C\\} S_2 \\{Q\\} }}{ \\vdash \\{P\\}\\ if\\ C\\ then\\ S_1\\ else \\ S_2 \\ \\{Q\\} } \\]\nIn summary, this means given we know \\(P\\) is true, no matter what \\(C\\) evaluates to, we will come to the same post-condition \\(Q\\). If you still don’t understand it, just stare at it for five minutes and you should figure out why this is the case:)\nProof Rule for While To understand the proof rule for while statement, we need to first understand a simple concept: loop invariant\nLoop Invariant Loop invariant \\(I\\) has two properties:\n  \\(I\\) holds initially before the loop\n  \\(I\\) holds after each loop iteration\n  For example, given a loop\ni := 0; j := 0; n := 0; while i Here, \\(i \\leq n \\) is a loop invariant but \\(i Now, we put the properties of loop invariant \\(I\\) in formal terms. Given that the precondition before a loop executes is \\(C\\), by definition, \\(I\\) holds initially before the loop, we know \\(I \\land C\\) holds.\nFor the second property of loop invariant, it specifies \\(I\\) holds after each loop iteration. So that means \\(\\{ I \\land C\\ \\} S \\{I\\} \\) holds. Formally, we express loop invariant as \\( \\vdash \\{P \\land C\\} S \\{P\\} \\).\nNow, we know if a loop terminates, it must be that condition \\(C\\) no longer holds, meaning \\( P \\land \\neg C \\) must be true after loop terminates. This is because \\(P\\) is a loop invariant and always holds after each loop iteration, including termination.\nPutting all this together, we form the proof rule for while loop:\n\\[ \\frac{ \\vdash \\{P \\land C\\} S \\{P\\} }{ \\vdash \\{P\\} while \\ C \\ do \\ S\\{P \\land \\neg C\\} }\\]\nInductive Loop Invariant It’s not always the case that we can prove loop invariant is valid. Here is a counter example:\nConsider precondition \\( I = j \\geq 1 \\) and the code is:\n\\[i := 1; j := 1; while \\ i We know that the precondition is \\(I = j \\geq 1\\) and \\(C\\) (loop condition) is \\(i \\leq n\\). So we have a Hoare triple:\n\\[ \\{ j \\geq 1 \\land i \\leq n \\} j =j + i;\\ i = i + 1; \\ \\{j \\geq 1\\} \\]\nWe could simply set \\(i = -100\\), then if we execute the code once we will not be sure if the post-condition \\(j \\geq 1\\) holds.\nHowever, if we have strengthened invariant such as \\(j \\geq 1 \\land i \\geq 1\\), the new Hoare triple will be valid. Then \\(I\\) will become inductive invariant because we can prove these invariant.\nTo put everything in action, here is an example showing how to find inductive loop invariant to prove the following Hoare triple:\n\\[ \\{i = o \\land j = o \\land n = 5\\} \\] \\[while\\ i If we have \\( j = \\frac{i(i+1)}{2} \\), this is a loop invariant because we can prove that:\n\\[\\{j = \\frac{i(i+1)}{2} \\land i If we conjoin this condition with \\(i \\geq n\\) as the post-condition, however, we can’t really show that \\(j = 15\\) is true for the given Hoare triple.\nIf we also add condition \\(n = 5\\) and \\(i \\leq n\\), and we conjoin this with the end-loop condition \\( i \\geq n\\), we would realize that \\( i = n = 5\\), and thus prove that \\(j = 15\\) for the given Hoare triple.\nHow we get \\(j = \\frac{i(i+1)}{2}\\) is, however, not trivial to solve, and requires some human effort in program verification.\nBasic Idea behind Program Verification Automating Reasoning in Hoare Logic It’s reasonable to automate the tedious parts of program verification: proving correctness. The basic idea to assume an oracle (human or another program) gives loop invariants but automate the rest of the reasoning.\nAutomating Hoare logic is based on generating verification conditions (VC). Essentially, a verification condition is formula \\(\\phi\\) s.t. program is correct iff \\(\\phi\\) is valid.\nThere are two way to generate verification conditions: forwards and backwards.\nAs their name suggests, a forwards analysis starts from precondition and generates formulas to prove post-condition. Forwards technique computes strongest post-conditions (sp). In contrast, backwards analysis starts from post-condition and tries to prove precondition. Backwards technique computes weakest preconditions (wp).\nHere, we start from backwards method.\nWeakest Preconditions Formally, we define the weakest precondition of \\(Q\\) with respect to \\(S\\) as \\(wp(S, Q)\\).\n\\(wp(S, Q)\\) has the property that it is the weakest condition (least amount of information we need to have) that guarantees \\(Q\\) holds after \\(S\\) in any execution.\nThus, Hoare triple \\( \\{P\\}S\\{Q\\} \\) is valid iff \\( P\\Rightarrow wp(S, Q) \\).\nWeakest preconditions are defined inductively and follow Hoare’s proof rules:\n  \\(wp(x := E, Q) = Q[E/x]\\)\n  \\( wp(s_1 ; s_2, Q) = wp(s_1, wp(s_2, Q) ) \\)\n  \\(wp(if \\ C\\ then \\ s_1\\ else \\ s_2, Q) =C \\rightarrow wp(s_1, Q) \\land \\neg C \\rightarrow wp(s_2, Q) \\)\n  However, for loops, we might not be able to compute the weakest preconditions exactly because there might be cases where we simply don’t know the number loops executed.\nThus, we relax our requirement by computing \\(awp(S,Q)\\) (\\(a\\) stands for approximate)) instead, hoping that \\(awp(S, Q)\\) is weak enough to be implied by \\(P\\) although it may not be the weakest.\nNow, assume all loops are annotated with invariants \\(while \\ C \\ do \\ [I]\\ S\\), we will just define \\(awp(while \\ C \\ do \\ [I]\\ S, Q) \\equiv I\\).\nHowever, there is another program, since \\(awp\\) is only an approximated condition, it doesn’t necessarily mean that if \\(P \\Rightarrow awp(S, Q)\\), \\( \\{P\\}S\\{Q\\} \\) is valid. There are two reasons:\n  We don’t know if the loop invariant \\(I\\) provided by the oracle is correct since it might be provided by human and we know human make mistakes.\n  Even if \\(I\\) is correct, we don’t if \\(I \\land \\neg C\\) is sufficient to establish \\(Q\\)!\n  Thus, for each statement \\(S\\), we need to generate verification condition (VC) \\( VC(S,Q) \\) which encodes additional conditions to prove.\nVerification Conditions So how do formulate VC generation rules for loops?\n\\[ VC(while\\ C\\ do\\ [I]\\ S,Q) = ?\\]\nFirst, we need to ensure that \\(Q\\) is satisfied after loop, which means \\( I \\land \\neg C \\Rightarrow Q \\).\nTo show that \\(I\\) is actually correct, we also need \\( \\{I \\land C\\} S \\{I\\} \\).\nThis implies that we need to show \\( I \\land C \\Rightarrow awp(S, I) \\). In case \\(S\\) contains nested loops, and also add \\(VC(S, I)\\)\nIn summary, to how that loop invariant \\(I\\) provided by the oracle is correct, we need to show \\( I \\land C \\Rightarrow awp(S,I) \\land VC(S, I) \\).\nTo show \\(I\\) is strong enough to establish \\(Q\\), we need to show \\( I \\land \\neg C \\Rightarrow Q \\).\nPutting this together, and to answer the two reason why \\(P \\Rightarrow awp(S, Q)\\), \\( \\{P\\}S\\{Q\\} \\) might not be valid, VC for a while loop \\( S' = while \\ C \\ do \\ \\{I\\} \\) is expressed as:\n\\[ VC(S', Q) = (I \\land C \\Rightarrow awp(S, I) \\land VC(S, I) ) \\land (I \\land \\neg C \\Rightarrow Q) \\]\nIn essence, verification condition simply stands for additional checks we need to verify before we can claim that, if an approximated precondition \\(P\\) is valid, \\( \\{P\\} S \\{Q\\} \\).\nThe verification condition for other statements is as follows:\n  For assignment, we don’t need any additional checks for precondition because if \\( P \\Rightarrow wp(S, Q) \\), it implies that \\( \\{P\\} S \\{Q\\} \\) is valid. Thus, \\( VC(x:= E, Q) = true \\).\n  For composition, we have \\( VC(s_1 ; s_2, Q) = VC(s_2, Q) \\land VC(s_1, awp(s_2 , Q)) \\).\n  For if statement, we have \\( VC(if \\ C \\ then \\ s_1\\ else \\ s_2, Q) = VC(s_1, Q) \\land VC(s_2, Q) \\).\n   Quick question: for if statement, why don’t we instead use verification condition generation rule: \\( C \\Rightarrow VC(s_1, Q) \\land \\neg C \\Rightarrow VC(s_2, Q) \\)?\n Here is a counter example. Suppose we have \\( S = if\\ (x  0) \\ while (*) x - -; else \\ skip\\), and we have given loop invariant \\(x \\geq 0\\).\nIf we use the original rule \\( VC(s_1, Q) \\land VC(s_2, Q) \\), according to the verification condition generation rule for while loop, we would have to verify the loop invariant \\(I\\) is correct, and thus \\(VC(S, I) \\equiv \\{ x \\geq 0 \\} x - - \\{ x \\geq 0 \\} \\), obviously, this not true, and we can use this VC.\nHowever, if we instead use the rule \\( C \\Rightarrow VC(s_1, Q) \\land \\neg C \\Rightarrow VC(s_2, Q) \\). The VC would become \\( x  0 \\Rightarrow (\\{ x \\geq 0 \\} x - - \\{ x \\geq 0 \\}) \\), which is valid, and we will include the wrong VC. Thus we can’t use this VC generation rule.\nVerification of Hoare Triple Thus, to show validity of Hoare triple \\( \\{P\\} S \\{ Q \\} \\), we need to compute:\n  \\( awp(S, Q) \\)\n  \\( VC(S, Q) \\)\n  Therefore, a Hoare triple is valid if the follow formula holds:\n\\begin{equation}\\tag{*} VC(S, Q) \\land P \\rightarrow awp(S, Q) \\end{equation}\nThus, if we can prove the validity of the above equation *, we know the program obeys specification.\n","wordCount":"2392","inLanguage":"en","datePublished":"2021-04-17T00:00:00Z","dateModified":"2021-04-17T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.bodunhu.com/blog/posts/hoarelogic/"},"publisher":{"@type":"Organization","name":"std::bodun::blog","logo":{"@type":"ImageObject","url":"https://www.cs.utexas.edu/sites/default/files/favicon.ico"}}}</script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://www.bodunhu.com/blog/ accesskey=h title="std::bodun::blog (Alt + H)">std::bodun::blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.bodunhu.com/blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.bodunhu.com/blog/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://www.bodunhu.com/blog/about/ title=About><span>About</span></a></li><li><a href=https://www.bodunhu.com/blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.bodunhu.com/blog/>Home</a>&nbsp;»&nbsp;<a href=https://www.bodunhu.com/blog/posts/>Posts</a></div><h1 class=post-title>Hoare Logic</h1><div class=post-meta>April 17, 2021&nbsp;·&nbsp;12 min</div></header><div class=post-content><p>Hoare logic forms the basis of all deductive verification. To illustrate Hoare logic, we will first consider a smaller imperative programming
language <strong>IMP</strong>.</p><p>In IMP, we have three program constructs: expressions, conditionals, and statements:</p><ul><li><p>Expression takes the form \( E := Z\ |\ V\ |\ e_1 + e_2\ |\ e_1 \times e_2 \)</p></li><li><p>Conditional is self-explanatory: \( C := true\ |\ false\ |\ e_1 = e_2\ |\ e_1 \leq e_2 \)</p></li><li><p>Statement consists of several different forms:</p><ul><li>\(S := V := E\) (Assignment)</li><li>\(S_1; S_2\) (Composition)</li><li>if \(C\) then \(S_1\) else \(S_2\) (If)</li><li>while \(C\) do \(S\) (While)</li></ul></li></ul><h2 id=hoare-triple>Hoare Triple<a hidden class=anchor aria-hidden=true href=#hoare-triple>#</a></h2><p>In Hoare logic, we specify partial correctness of programs using Hoare triples:</p><p>\[\{P\} S \{Q\}\]</p><p>Here \(P\) is the precondition and \(Q\) is the post-condition. $S$ is a statement in IMP.</p><p>The interpretation of Hoare triple is as follows:</p><ol><li><p>if \(S\) is executed in a state satisfying \(P\)</p></li><li><p>and if execution of \(S\) terminates</p></li><li><p>then the program state after \(S\) terminates satisfies \(Q\)</p></li></ol><p>Here an example, \(\{x = 0 \} while\ true\ do\ x := 0\ \{x = 1 \}\) is a valid Hoare triple because the execution of the statement never terminates, thus satisfying the requirement posed by Hoare triple.</p><p>Thus the specification \(\{P\} S \{Q\}\) is called <em>partial</em> correctness spec, because it doesn&rsquo;t require \(S\) to terminate.</p><p>There is also a stronger requirement called <em>total</em> correctness. The total correctness specification is written as:</p><p>\[ [P] S [Q]\]</p><p>Total correctness requires that if \(P\) is satisfied when executing \(S\), then \(S\) must terminate, and the post-conditional \(Q\) must be satisfied after \(S\) terminates.</p><p>Thus the example \(\{x = 0 \} while\ true\ do\ x := 0\ \{x = 1 \}\) is no longer valid because it never terminates.</p><p>In summary, we can say that Total correctness \(=\) Partial correctness \(+\) termination.</p><h2 id=proving-partial-correctness>Proving Partial Correctness<a hidden class=anchor aria-hidden=true href=#proving-partial-correctness>#</a></h2><p>We use \(\vDash \{P\} S \{Q\} \) to say a Hoare triple is valid and we use \(\vdash \{P\} S \{Q\} \) to indicate we can prove validity of a Hoare triple.</p><p>Let&rsquo;s say we are given an assignment \(x := y \) with post-condition \(x > 2\). The question is, what do we need to know before the assignment happens so that the post-condition, \(x > 2\), holds afterwards?</p><p>To prove \(Q\) holds after the assignment \(x := E\), we need to show that <strong>\(Q\) with \(E\) substituting \(x\) holds before the assignment</strong>. Formally, we write it as:</p><p>\[\vdash \{Q[E / x]\}\ x := E \{Q\}\]</p><p>For example, given \( \{ x+1 = n\}\ x := x+1 \ \{x=n\} \), we know this formula is provable because we can take \(Q\), which is \(\{x=n\}\), substituting \(x\) with \(x+1\) given we need to replace it with \(E\), and we will convert \(x=n\) to \(x+1 = n\), which matches the precondition.</p><p>Here is another interesting example, given \( \{z = 2\}y:= x \{y = x\} \), this Hoare triple is valid but not provable. If we use the above substitution procedure, it will result in the precondition being \(x=x\) which is always true but is also different from the original precondition \(z=2\).</p><p>Intuitively, we can prove the post-condition \(y = x\) given the statement \(y = x\) without any assumptions, so even if we do have assumptions like \(z=2\), we should still be able to prove it, and here comes proof rule for precondition strengthening.</p><h2 id=proof-rule-for-precondition-strengthening>Proof Rule for Precondition Strengthening<a hidden class=anchor aria-hidden=true href=#proof-rule-for-precondition-strengthening>#</a></h2><p>Formally, we define precondition strengthening as:</p><p>\[ \frac{ \vDash \{P'\} S \{Q\}\ \ P \Rightarrow P' }{\vdash \{P\} S \{Q\}} \]</p><p>Now, with the original formula \( \{z = 2\}y:= x \{y = x\} \), we would derive \( x= x \equiv true \). and since \(z=2 \rightarrow true\) is valid, we can now prove the formula!</p><h2 id=a-dual-post-condition-weakening>A Dual: Post-Condition Weakening<a hidden class=anchor aria-hidden=true href=#a-dual-post-condition-weakening>#</a></h2><p>Formally, we define post-condition weakening as:</p><p>\[ \frac{ \vDash \{P\} S \{Q'\}\ \ Q' \Rightarrow Q }{\vdash \{P\} S \{Q\}} \]</p><p>What this means if that if we can prove a post-condition \(Q'\), we can always relax it to something <strong>weaker</strong>.</p><p>For example, given that \(\vdash \{true\}S\{x=y \land z=2\}\), we can prove \(\{true\}S\{x=y\}\) because \(x=y\) is a weaker condition of \( x=y \land z=2 \).</p><h2 id=proof-rule-for-composition>Proof Rule for Composition<a hidden class=anchor aria-hidden=true href=#proof-rule-for-composition>#</a></h2><p>For composition, we define the rule as:</p><p>\[ \frac{ \vdash \{P\}S_1\{Q\}\ \ \vdash \{Q\}S_2 \{R\} }{ \vdash \{P\}S_1;S_2\{R\} }\]</p><p>I won&rsquo;t show why this is true, so this will be left as an exercise.</p><h2 id=proof-rule-for-if-statements>Proof Rule for If Statements<a hidden class=anchor aria-hidden=true href=#proof-rule-for-if-statements>#</a></h2><p>Naturally, we define the rule for if statement as:</p><p>\[ \frac{_{ \vdash \{P \land C\} S_1 \{Q\} }^{ \vdash \{P \land \neg C\} S_2 \{Q\} }}{ \vdash \{P\}\ if\ C\ then\ S_1\ else \ S_2 \ \{Q\} } \]</p><p>In summary, this means given we know \(P\) is true, no matter what \(C\) evaluates to, we will come to the same post-condition \(Q\). If you still don&rsquo;t understand it, just stare at it for five minutes and you should figure out why this is the case:)</p><h2 id=proof-rule-for-while>Proof Rule for While<a hidden class=anchor aria-hidden=true href=#proof-rule-for-while>#</a></h2><p>To understand the proof rule for while statement, we need to first understand a simple concept: loop invariant</p><h3 id=loop-invariant>Loop Invariant<a hidden class=anchor aria-hidden=true href=#loop-invariant>#</a></h3><p>Loop invariant \(I\) has two properties:</p><ol><li><p>\(I\) holds initially before the loop</p></li><li><p>\(I\) holds after each loop iteration</p></li></ol><p>For example, given a loop</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>i := 0;
j := 0;
n := 0;
while i &lt; n do
    i := i + 1;
    j := i + j
</code></pre></div><p>Here, \(i \leq n \) is a loop invariant but \(i &lt; n \) isn&rsquo;t.</p><p>Now, we put the properties of loop invariant \(I\) in formal terms. Given that the precondition before a loop executes is \(C\), by definition, \(I\) holds initially before the loop, we know \(I \land C\) holds.</p><p>For the second property of loop invariant, it specifies \(I\) holds after each loop iteration. So that means \(\{ I \land C\ \} S \{I\} \) holds. Formally, we express loop invariant as \( \vdash \{P \land C\} S \{P\} \).</p><p>Now, we know if a loop terminates, it must be that condition \(C\) no longer holds, meaning \( P \land \neg C \) must be true after loop terminates. This is because \(P\) is a loop invariant and always holds after each loop iteration, including termination.</p><p>Putting all this together, we form the proof rule for while loop:</p><p>\[ \frac{ \vdash \{P \land C\} S \{P\} }{ \vdash \{P\} while \ C \ do \ S\{P \land \neg C\} }\]</p><h3 id=inductive-loop-invariant>Inductive Loop Invariant<a hidden class=anchor aria-hidden=true href=#inductive-loop-invariant>#</a></h3><p>It&rsquo;s not always the case that we can prove loop invariant is valid. Here is a counter example:</p><p>Consider precondition \( I = j \geq 1 \) and the code is:</p><p>\[i := 1; j := 1; while \ i &lt; n\ do\ \{j := j+i; i ;= i + 1\}\]</p><p>We know that the precondition is \(I = j \geq 1\) and \(C\) (loop condition) is \(i \leq n\). So we have a Hoare triple:</p><p>\[ \{ j \geq 1 \land i \leq n \} j =j + i;\ i = i + 1; \ \{j \geq 1\} \]</p><p>We could simply set \(i = -100\), then if we execute the code once we will not be sure if the post-condition \(j \geq 1\) holds.</p><p>However, if we have <strong>strengthened invariant</strong> such as \(j \geq 1 \land i \geq 1\), the new Hoare triple will be valid. Then \(I\) will become inductive invariant because we can prove these invariant.</p><p>To put everything in action, here is an example showing how to find inductive loop invariant to prove the following Hoare triple:</p><p>\[ \{i = o \land j = o \land n = 5\} \]
\[while\ i &lt; do\ i := i + 1; \ j := j + i; \]
\[\{j = 15\} \]</p><p>If we have \( j = \frac{i(i+1)}{2} \), this is a loop invariant because we can prove that:</p><p>\[\{j = \frac{i(i+1)}{2} \land i &lt; n\} i = i + 1;\ j = j+ i\ \{j = \frac{i(i+1)}{2}\} \]</p><p>If we conjoin this condition with \(i \geq n\) as the post-condition, however, we can&rsquo;t really show that \(j = 15\) is true for the given Hoare triple.</p><p>If we also add condition \(n = 5\) and \(i \leq n\), and we conjoin this with the end-loop condition \( i \geq n\), we would realize that \( i = n = 5\), and thus prove that \(j = 15\) for the given Hoare triple.</p><p>How we get \(j = \frac{i(i+1)}{2}\) is, however, not trivial to solve, and requires some human effort in program verification.</p><h2 id=basic-idea-behind-program-verification>Basic Idea behind Program Verification<a hidden class=anchor aria-hidden=true href=#basic-idea-behind-program-verification>#</a></h2><h3 id=automating-reasoning-in-hoare-logic>Automating Reasoning in Hoare Logic<a hidden class=anchor aria-hidden=true href=#automating-reasoning-in-hoare-logic>#</a></h3><p>It&rsquo;s reasonable to automate the tedious parts of program verification: proving correctness. The basic idea to assume an oracle (human or another program) gives loop invariants but automate the rest of the reasoning.</p><p>Automating Hoare logic is based on generating verification conditions (VC). Essentially, a verification condition is formula \(\phi\) s.t. program is correct iff \(\phi\) is valid.</p><p>There are two way to generate verification conditions: forwards and backwards.</p><p>As their name suggests, a forwards analysis starts from precondition and generates formulas to prove post-condition. Forwards technique computes <strong>strongest post-conditions (sp)</strong>. In contrast, backwards analysis starts from post-condition and tries to prove precondition. Backwards technique computes <strong>weakest preconditions (wp)</strong>.</p><p>Here, we start from backwards method.</p><h3 id=weakest-preconditions>Weakest Preconditions<a hidden class=anchor aria-hidden=true href=#weakest-preconditions>#</a></h3><p>Formally, we define the weakest precondition of \(Q\) with respect to \(S\) as \(wp(S, Q)\).</p><p>\(wp(S, Q)\) has the property that it is the weakest condition (least amount of information we need to have) that guarantees \(Q\) holds after \(S\) in any execution.</p><p>Thus, Hoare triple \( \{P\}S\{Q\} \) is valid iff \( P\Rightarrow wp(S, Q) \).</p><p>Weakest preconditions are defined inductively and follow Hoare&rsquo;s proof rules:</p><ul><li><p>\(wp(x := E, Q) = Q[E/x]\)</p></li><li><p>\( wp(s_1 ; s_2, Q) = wp(s_1, wp(s_2, Q) ) \)</p></li><li><p>\(wp(if \ C\ then \ s_1\ else \ s_2, Q) =C \rightarrow wp(s_1, Q) \land \neg C \rightarrow wp(s_2, Q) \)</p></li></ul><p>However, for loops, we might not be able to compute the weakest preconditions exactly because there might be cases where we simply don&rsquo;t know the number loops executed.</p><p>Thus, we relax our requirement by computing \(awp(S,Q)\) (\(a\) stands for approximate)) instead, hoping that \(awp(S, Q)\) is weak enough to be implied by \(P\) although it may not be the weakest.</p><p>Now, assume all loops are annotated with invariants \(while \ C \ do \ [I]\ S\), we will just define \(awp(while \ C \ do \ [I]\ S, Q) \equiv I\).</p><p>However, there is another program, since \(awp\) is only an approximated condition, it doesn&rsquo;t necessarily mean that if \(P \Rightarrow awp(S, Q)\), \( \{P\}S\{Q\} \) is valid. There are two reasons:</p><ol><li><p>We don&rsquo;t know if the loop invariant \(I\) provided by the oracle is correct since it might be provided by human and we know human make mistakes.</p></li><li><p>Even if \(I\) is correct, we don&rsquo;t if \(I \land \neg C\) is sufficient to establish \(Q\)!</p></li></ol><p>Thus, for each statement \(S\), we need to generate verification condition (VC) \( VC(S,Q) \) which encodes additional conditions to prove.</p><h3 id=verification-conditions>Verification Conditions<a hidden class=anchor aria-hidden=true href=#verification-conditions>#</a></h3><p>So how do formulate VC generation rules for loops?</p><p>\[ VC(while\ C\ do\ [I]\ S,Q) = ?\]</p><p>First, we need to ensure that \(Q\) is satisfied after loop, which means \( I \land \neg C \Rightarrow Q \).</p><p>To show that \(I\) is actually correct, we also need \( \{I \land C\} S \{I\} \).</p><p>This implies that we need to show \( I \land C \Rightarrow awp(S, I) \). In case \(S\) contains nested loops, and also add \(VC(S, I)\)</p><p>In summary, to how that loop invariant \(I\) provided by the oracle is correct, we need to show \( I \land C \Rightarrow awp(S,I) \land VC(S, I) \).</p><p>To show \(I\) is strong enough to establish \(Q\), we need to show \( I \land \neg C \Rightarrow Q \).</p><p>Putting this together, and to answer the two reason why \(P \Rightarrow awp(S, Q)\), \( \{P\}S\{Q\} \) might not be valid, VC for a while loop \( S' = while \ C \ do \ \{I\} \) is expressed as:</p><p>\[ VC(S', Q) = (I \land C \Rightarrow awp(S, I) \land VC(S, I) ) \land (I \land \neg C \Rightarrow Q) \]</p><p>In essence, verification condition simply stands for additional checks we need to verify before we can claim that, if an approximated precondition \(P\) is valid, \( \{P\} S \{Q\} \).</p><p>The verification condition for other statements is as follows:</p><ol><li><p>For assignment, we don&rsquo;t need any additional checks for precondition because if \( P \Rightarrow wp(S, Q) \), it implies that \( \{P\} S \{Q\} \) is valid. Thus, \( VC(x:= E, Q) = true \).</p></li><li><p>For composition, we have \( VC(s_1 ; s_2, Q) = VC(s_2, Q) \land VC(s_1, awp(s_2 , Q)) \).</p></li><li><p>For if statement, we have \( VC(if \ C \ then \ s_1\ else \ s_2, Q) = VC(s_1, Q) \land VC(s_2, Q) \).</p></li></ol><blockquote><p>Quick question: for if statement, why don&rsquo;t we instead use verification condition generation rule: \( C \Rightarrow VC(s_1, Q) \land \neg C \Rightarrow VC(s_2, Q) \)?</p></blockquote><p>Here is a counter example. Suppose we have \( S = if\ (x > 0) \ while (*) x - -; else \ skip\), and we have given loop invariant \(x \geq 0\).</p><p>If we use the original rule \( VC(s_1, Q) \land VC(s_2, Q) \), according to the verification condition generation rule for while loop, we would have to verify the loop invariant \(I\) is correct, and thus \(VC(S, I) \equiv \{ x \geq 0 \} x - - \{ x \geq 0 \} \), obviously, this not true, and we can use this VC.</p><p>However, if we instead use the rule \( C \Rightarrow VC(s_1, Q) \land \neg C \Rightarrow VC(s_2, Q) \). The VC would become \( x > 0 \Rightarrow (\{ x \geq 0 \} x - - \{ x \geq 0 \}) \), which is valid, and we will include the wrong VC. Thus we can&rsquo;t use this VC generation rule.</p><h2 id=verification-of-hoare-triple>Verification of Hoare Triple<a hidden class=anchor aria-hidden=true href=#verification-of-hoare-triple>#</a></h2><p>Thus, to show validity of Hoare triple \( \{P\} S \{ Q \} \), we need to compute:</p><ol><li><p>\( awp(S, Q) \)</p></li><li><p>\( VC(S, Q) \)</p></li></ol><p>Therefore, a Hoare triple is valid if the follow formula holds:</p><p>\begin{equation}\tag{*}
VC(S, Q) \land P \rightarrow awp(S, Q)
\end{equation}</p><p>Thus, if we can prove the validity of the above equation *, we know the program obeys specification.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.bodunhu.com/blog/tags/pl/>PL</a></li><li><a href=https://www.bodunhu.com/blog/tags/algorithm/>algorithm</a></li><li><a href=https://www.bodunhu.com/blog/tags/theory/>theory</a></li><li><a href=https://www.bodunhu.com/blog/tags/logic/>logic</a></li><li><a href=https://www.bodunhu.com/blog/tags/verification/>verification</a></li></ul><nav class=paginav><a class=prev href=https://www.bodunhu.com/blog/posts/blockchain/><span class=title>« Prev Page</span><br><span>Blockchain</span></a>
<a class=next href=https://www.bodunhu.com/blog/posts/congruence_closure/><span class=title>Next Page »</span><br><span>Congruence Closure</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Hoare Logic on twitter" href="https://twitter.com/intent/tweet/?text=Hoare%20Logic&url=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fhoarelogic%2f&hashtags=PL%2calgorithm%2ctheory%2clogic%2cverification"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hoare Logic on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fhoarelogic%2f&title=Hoare%20Logic&summary=Hoare%20Logic&source=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fhoarelogic%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hoare Logic on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fhoarelogic%2f&title=Hoare%20Logic"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hoare Logic on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fhoarelogic%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hoare Logic on whatsapp" href="https://api.whatsapp.com/send?text=Hoare%20Logic%20-%20https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fhoarelogic%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Hoare Logic on telegram" href="https://telegram.me/share/url?text=Hoare%20Logic&url=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fhoarelogic%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2021 <a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>