<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>Hoare Logic - std::bodun:blog</title><link rel=icon type=image/png href=/blog/favicon.ico><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Hoare Logic"><meta property="og:description" content="Hoare logic forms the basis of all deductive verification. To illustrate Hoare logic, we will first consider a smaller imperative programming language IMP."><meta property="og:type" content="article"><meta property="og:url" content="https://www.bodunhu.com/blog/posts/hoarelogic/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-17T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-17T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Hoare Logic"><meta name=twitter:description content="Hoare logic forms the basis of all deductive verification. To illustrate Hoare logic, we will first consider a smaller imperative programming language IMP."><link href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,300italic,400italic|Raleway:200,300" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://www.bodunhu.com/blog/css/normalize.css><link rel=stylesheet type=text/css media=screen href=https://www.bodunhu.com/blog/css/main.css><link rel=stylesheet type=text/css href=https://www.bodunhu.com/blog/css/dark.css media="(prefers-color-scheme: dark)"><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><script src=https://www.bodunhu.com/blog/js/main.js></script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']],displayMath:[['$$','$$'],['\\[','\\]']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><meta name=google-site-verification content="rCBqGFj-RPsmjg3Aho3_wEfipA1SHxSEDnsAZZrv_J8"></head><body><div class="container wrapper post"><div class=header><base href=https://www.bodunhu.com/blog/><h1 class=site-title><a href=https://www.bodunhu.com/blog/>std::bodun:blog</a></h1><div class=site-description><h2>PhD student at <a href=https://www.utexas.edu/>UT Austin</a>. OS, kernel, network, heterogeneity, anything system.</h2><nav class="nav social"><ul class=flat><a href=https://twitter.com/BodunHu title=Twitter><i data-feather=twitter></i></a><a href=https://github.com/BDHU/ title=Github><i data-feather=github></i></a><a href=/blog/index.xml title=RSS><i data-feather=rss></i></a></ul></nav></div><nav class=nav><ul class=flat><li><a href=/blog/>Home</a></li><li><a href=/blog/posts>All posts</a></li><li><a href=/blog/about>About</a></li><li><a href=/blog/tags>Tags</a></li><li><a href="https://www.google.com/search?sitesearch=https%3A%2F%2Fwww.bodunhu.com/blog%2F&q=">Search</a></li></ul></nav></div><div class=post-header><h1 class=title>Hoare Logic</h1><div class=meta>Posted at &mdash; Apr 17, 2021</div></div><div class=markdown><p>Hoare logic forms the basis of all deductive verification. To illustrate Hoare logic, we will first consider a smaller imperative programming
language <strong>IMP</strong>.</p><p>In IMP, we have three program constructs: expressions, conditionals, and statements:</p><ul><li><p>Expression takes the form \( E := Z\ |\ V\ |\ e_1 + e_2\ |\ e_1 \times e_2 \)</p></li><li><p>Conditional is self-explanatory: \( C := true\ |\ false\ |\ e_1 = e_2\ |\ e_1 \leq e_2 \)</p></li><li><p>Statement consists of several different forms:</p><ul><li>\(S := V := E\) (Assignment)</li><li>\(S_1; S_2\) (Composition)</li><li>if \(C\) then \(S_1\) else \(S_2\) (If)</li><li>while \(C\) do \(S\) (While)</li></ul></li></ul><h2 id=hoare-triple>Hoare Triple</h2><hr><p>In Hoare logic, we specify partial correctness of programs using Hoarse triples:</p><p>\[\{P\} S \{Q\}\]</p><p>Here \(P\) is the precondition and \(Q\) is the post-condition. $S$ is a statement in IMP.</p><p>The interpretation of Hoare triple is as follows:</p><ol><li><p>if \(S\) is executed in a state satisfying \(P\)</p></li><li><p>and if execution of \(S\) terminates</p></li><li><p>then the program state after \(S\) terminates satisfies \(Q\)</p></li></ol><p>Here an example, \(\{x = 0 \} while\ true\ do\ x := 0\ \{x = 1 \}\) is a valid Hoare triple because the execution of the statement never terminates, thus satisfying the requirement posed by Hoare triple.</p><p>Thus the specification \(\{P\} S \{Q\}\) is called <em>partial</em> correctness spec, because it doesn&rsquo;t require \(S\) to terminate.</p><p>There is also a stronger requirement called <em>total</em> correctness. The total correctness specification is written as:</p><p>\[ [P] S [Q]\]</p><p>Total correctness requires that if \(P\) is satisfied when executing \(S\), then \(S\) must terminate, and the post-conditional \(Q\) must be satisfied after \(S\) terminates.</p><p>Thus the example \(\{x = 0 \} while\ true\ do\ x := 0\ \{x = 1 \}\) is no longer valid because it never terminates.</p><p>In summary, we can say that Total correctness \(=\) Partial correctness \(+\) termination.</p><h2 id=proving-partial-correctness>Proving Partial Correctness</h2><hr><p>We use \(\vDash \{P\} S \{Q\} \) to say a Hoare triple is valid and we use \(\vdash \{P\} S \{Q\} \) to indicate we can prove validity of a Hoare triple.</p><p>Let&rsquo;s say we are given an assignment \(x := y \) with post-condition \(x > 2\). The question is, what do we need to know before the assignment happens so that the post-condition, \(x > 2\), holds afterwards?</p><p>To prove \(Q\) holds after the assignment \(x := E\), we need to show that <strong>\(Q\) with \(E\) substituting \(x\) folds before the assignment</strong>. Formally, we write it as:</p><p>\[\vdash \{Q[E / x]\}\ x := E \{Q\}\]</p><p>For example, given \( \{ x+1 = n\}\ x := x+1 \ \{x=n\} \), we know this formula is provable because we can take \(Q\), which is \(\{x=n\}\), substituting \(x\) with \(x+1\) given we need to replace it with \(E\), and we will convert \(x=n\) to \(x+1 = n\), which matches the precondition.</p><hr><p>Here is another interesting example, given \( \{z = 2\}y:= x \{y = x\} \), this Hoare triple is valid but not provable. If we use the above substitution procedure, it will result in the precondition being \(x=x\) which is always true but is also different from the original precondition \(z=2\).</p><p>Intuitively, we can prove the post-condition \(y = x\) given the statement \(y = x\) without any assumptions, so even if we do have assumptions like \(z=2\), we should still be able to prove it, and here comes proof rule for precondition strengthening.</p><h2 id=proof-rule-for-precondition-strengthening>Proof Rule for Precondition Strengthening</h2><hr><p>Formally, we define precondition strengthening as:</p><p>\[ \frac{ \vDash \{P'\} S \{Q\}\ \ P \Rightarrow P' }{\vdash \{P\} S \{Q\}} \]</p><p>Now, with the original formula \( \{z = 2\}y:= x \{y = x\} \), we would derive \( x= x \equiv true \). and since \(z=2 \rightarrow true\) is valid, we can now prove the formula!</p><h2 id=a-dual-post-condition-weakening>A Dual: Post-Condition Weakening</h2><hr><p>Formally, we define post-condition weakening as:</p><p>\[ \frac{ \vDash \{P\} S \{Q'\}\ \ Q' \Rightarrow Q }{\vdash \{P\} S \{Q\}} \]</p><p>What this means if that if we can prove a post-condition \(Q'\), we can always relax it to something <strong>weaker</strong>.</p><p>For example, given that \(\vdash \{true\}S\{x=y \land z=2\}\), we can prove \(\{true\}S\{x=y\}\) because \(x=y\) is a weaker condition of \( x=y \land z=2 \).</p><h2 id=proof-rule-for-composition>Proof Rule for Composition</h2><hr><p>For composition, we define the rule as:</p><p>\[ \frac{ \vdash \{P\}S_1\{Q\}\ \ \vdash \{Q\}S_2 \{R\} }{ \vdash \{P\}S_1;S_2\{R\} }\]</p><p>I won&rsquo;t show why this is true, so this will be left as an exercise.</p><h2 id=proof-rule-for-if-statements>Proof Rule for If Statements</h2><hr><p>Naturally, we define the rule for if statement as:</p><p>\[ \frac{_{ \vdash \{P \land C\} S_1 \{Q\} }^{ \vdash \{P \land \neg C\} S_2 \{Q\} }}{ \vdash \{P\}\ if\ C\ then\ S_1\ else \ S_2 \ \{Q\} } \]</p><p>In summary, this means given we know \(P\) is true, no matter what \(C\) evaluates to, we will come to the same post-condition \(Q\). If you still don&rsquo;t understand it, just stare at it for five minutes and you should figure out why this is the case:)</p><h2 id=proof-rule-for-while>Proof Rule for While</h2><p>To understand the proof rule for while statement, we need to first understand a simple concept: loop invariant</p><hr><h3 id=loop-invariant>Loop Invariant</h3><p>Loop invariant \(I\) has two properties:</p><ol><li><p>\(I\) holds initially before the loop</p></li><li><p>\(I\) holds after each loop iteration</p></li></ol><p>For example, given a loop</p><div class=highlight><pre style=color:#93a1a1;background-color:#002b36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>i := 0;
j := 0;
n := 0;
while i &lt; n do
    i := i + 1;
    j := i + j
</code></pre></div><p>Here, \(i \leq n \) is a loop invariant but \(i &lt; n \) isn&rsquo;t.</p><p>Now, we put the properties of loop invariant \(I\) in formal terms. Given that the precondition before a loop executes is \(C\), by definition, \(I\) holds initially before the loop, we know \(I \land C\) holds.</p><p>For the second property of loop invariant, it specifies \(I\) holds after each loop iteration. So that means \(\{ I \land C\ \} S \{I\} \) holds. Formally, we express loop invariant as \( \vdash \{P \land C\} S \{P\} \).</p><hr><p>Now, we know if a loop terminates, it must be that condition \(C\) no longer holds, meaning \( P \land \neg C \) must be true after loop terminates. This is because \(P\) is a loop invariant and always holds after each loop iteration, including termination.</p><p>Putting all this together, we form the proof rule for while loop:</p><p>\[ \frac{ \vdash \{P \land C\} S \{P\} }{ \vdash \{P\} while \ C \ do \ S\{P \land \neg C\} }\]</p></div><div class=post-tags><nav class="nav tags"><ul class=flat><li><a href=/blog/tags/pl>PL</a></li><li><a href=/blog/tags/algorithm>algorithm</a></li><li><a href=/blog/tags/theory>theory</a></li><li><a href=/blog/tags/logic>logic</a></li></ul></nav></div><script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=preferred-color-scheme crossorigin=anonymous async></script></div><div class="footer wrapper"><nav class=nav><div>Copyright Â© 2017-present, Bodun. All Rights Reserved | <a href=https://github.com/vividvilla/ezhil>Ezhil theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></nav></div><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script><script async src=https://www.google-analytics.com/analytics.js></script><script>feather.replace()</script></body></html>