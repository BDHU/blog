<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Start Linux Kernel Hacking | std::bodun::blog</title><meta name=keywords content="os,linux,kernel"><meta name=description content="This is a summary of how to compile and boot the Linux kernel on the KVM-qemu virtual machine. It covers how to get a VM running in KVM, how to build a customized kernel, and how to use GDB with the Linux kernel. The experiment is conducted on an amd64 architecture CPU. We use Ubuntu as our testing environment but the steps covered here should apply to other distros as well."><meta name=author content><link rel=canonical href=https://www.bodunhu.com/blog/posts/kernelhacking/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/blog/assets/css/stylesheet.min.a5e03b66b1e33e7f33d24d6965bc0a1987dd2e5edf97d3a2f7713a6ff21dcecf.css integrity="sha256-peA7ZrHjPn8z0k1pZbwKGYfdLl7fl9Oi93E6b/Idzs8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://www.cs.utexas.edu/sites/default/files/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://www.utexas.edu/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://www.utexas.edu/favicon-32x32.png><link rel=apple-touch-icon href=https://www.utexas.edu/apple-touch-icon.png><link rel=mask-icon href=https://www.cs.utexas.edu/sites/default/files/favicon.ico><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="Start Linux Kernel Hacking"><meta property="og:description" content="This is a summary of how to compile and boot the Linux kernel on the KVM-qemu virtual machine. It covers how to get a VM running in KVM, how to build a customized kernel, and how to use GDB with the Linux kernel. The experiment is conducted on an amd64 architecture CPU. We use Ubuntu as our testing environment but the steps covered here should apply to other distros as well."><meta property="og:type" content="article"><meta property="og:url" content="https://www.bodunhu.com/blog/posts/kernelhacking/"><meta property="og:image" content="https://www.bodunhu.com/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-09-14T00:00:00+00:00"><meta property="article:modified_time" content="2020-09-14T00:00:00+00:00"><meta property="og:site_name" content="Bodun's blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.bodunhu.com/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Start Linux Kernel Hacking"><meta name=twitter:description content="This is a summary of how to compile and boot the Linux kernel on the KVM-qemu virtual machine. It covers how to get a VM running in KVM, how to build a customized kernel, and how to use GDB with the Linux kernel. The experiment is conducted on an amd64 architecture CPU. We use Ubuntu as our testing environment but the steps covered here should apply to other distros as well."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://www.bodunhu.com/blog/posts/"},{"@type":"ListItem","position":2,"name":"Start Linux Kernel Hacking","item":"https://www.bodunhu.com/blog/posts/kernelhacking/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Start Linux Kernel Hacking","name":"Start Linux Kernel Hacking","description":"This is a summary of how to compile and boot the Linux kernel on the KVM-qemu virtual machine. It covers how to get a VM running in KVM, how to build a customized kernel, and how to use GDB with the Linux kernel. The experiment is conducted on an amd64 architecture CPU. We use Ubuntu as our testing environment but the steps covered here should apply to other distros as well.","keywords":["os","linux","kernel"],"articleBody":" This is a summary of how to compile and boot the Linux kernel on the KVM-qemu virtual machine. It covers how to get a VM running in KVM, how to build a customized kernel, and how to use GDB with the Linux kernel. The experiment is conducted on an amd64 architecture CPU. We use Ubuntu as our testing environment but the steps covered here should apply to other distros as well.\n Getting a VM running in KVM The Ubuntu ISO image is downloaded from the Canonical website. The kernel is downloaded directly from kernel.org. The specs of our test environment is:\n CPU: Intel(R) Core(TM) i7-6800K CPU @ 3.40GHz RAM: 32 GB Host and Guest OS: Ubuntu 20.04.1 LTS Host Kernel Version: 5.4.0-47-generic GCC: 7.5.0 QEMU emulator version: 4.2.0 Guest Kernel Version: 5.8.6  After we obtained the Ubuntu ISO image, we use GUI virt-manager to install the OS. One thing to notice here is the default directory for virtual disks is /var/lib/libvirt/images, since my system partition is located on a separate SSD with limited space, the virtual disk directory is changed to my /home directory instead.\nWe also create the new virtual disk inside virt-manager. We chose raw format instead of qcow2. Creating a new image file can also be done in command line using:\nqemu-img create -f raw -o preallocation=full vmdisk.img 40G The preallocation can be turn either on or off depends on personal choices. After the disk image is created, we proceeds in virt-manager to install Ubuntu on the newly allocated virtual disk. We enabled storage for this virtual machine so that we don’t need to repeat the installation process every time we launch the VM. One thing to be noticed here is we don’t need swap area inside a virtual machine. We can simply use the whole virtual disk for / partition.\nTo start the VM from cmd, you might need to change the owner of the disk image. We add the user to both kvm and libvirt. The image created or accessed by virt-manager seems to change the file owner to libvirt-qemu, which may cause problems when starting from cmd.\nAfter the installation is finished, we can simply launch the virtual machine inside virt-manager through its GUI interface. We can also use command line to start the VM:\nkvm -accel kvm -m 8G -smp 6 --snapshot -drive format=raw,file=/home/ed/virtimg/ubuntu20.04 The argument -accel kvm enables Kernel-based Virtual Machine full virtualization, which uses hardware acceleration. Without this option the VM will become extremely slow. The -m 8G assigns the given amount of memory to the VM. The -smp 6 assigns the given number of cores to the guest if the host has multiple cores. The --snapshot ensures that no changes are made to your image during an execution so you can do something dangerous and have the original image file preserved. The -drive option specifies the location of the virtual disk and its format. We will use some of these options later.\nTo confirm the VM has internet access, simply execution apt install pkg-name in the guest terminal. No error message would indicates properly functioning network access from the guest VM. For example, when we execute sudo apt install llvm it shows:\nReading package lists... Done Building dependency tree Reading state information... Done The following additional packages will be installed: llvm-runtime The following NEW packages will be installed: llvm llvm-runtime 0 upgraded, 2 newly installed, 0 to remove and 0 not upgraded. Need to get 6,796 B of archives. After this operation, 128 kB of additional disk space will be used. Do you want to continue? [Y/n] Building the Kernel We can use out customized kernel for our newly created VM. After we obtain the Linux kernel from kernel.org, we extract the source into and create a separate build directory  (outside ).\nThen we enter the  directory, run\nyes \"\" | make -C /home/ed/Desktop/linux_kernel/kbuild O=$(pwd) config This will create a .config file inside  with the default options selected. We then open the configuration file and ensures CONFIG_SATA_AHCI=y, which builds the SATA disk driver into the kernel. That will allow your kernel to boot off a (virtual) SATA drive without having to load a module to do it.\nNext we build the kernel by running make in . We use the -j 6 option speedup the building process using multiple processor cores. This process can take a long time.\nBuild and Install Kernel Modules To build modules locally on host, we create another separate  directory for building kernel modules. Then in , execute\nmake INSTALL_MOD_PATH=/home/ed/Desktop/linux_kernel/install_mod_dir modules_install Now there is a lib directory inside /home/ed/Desktop/linux_kernel/install_mod_dir, which holds all the kernel modules we are about to install.\nThe complete list of modules can be listed using cat modules.builtin inside lib/moduels/5.8.6. Here is a link to all the modules being built. We didn’t modify anything in the configuration.\nThen we use guestmount to mount the virtual disk to a mount point on the host\nguestmount -a /home/ed/virtimg/ubuntu20.04 -i ~/vm/linux/ In Ubuntu this step yields the following message:\nlibguestfs: error: /usr/bin/supermin exited with error status 1. To see full error messages you may need to enable debugging. Do: export LIBGUESTFS_DEBUG=1 LIBGUESTFS_TRACE=1 and run the command again. For further information, read: http://libguestfs.org/guestfs-faq.1.html#debugging-libguestfs You can also run 'libguestfs-test-tool' and post the *complete* output into a bug report or message to the libguestfs mailing list. The underlying problem is that the kernel cannot be read and according to the post and the bug report on Ubuntu Launchpad.\nTo fix the issue, we need to run\nsudo chmod +r /boot/vmlinuz-* We can verify the contents inside ~/vm/linux by simply cd into it.\nTo install the modules we just built, we can copy the lib/modules into the mounted filesystem /lib/modules.\nFinally, we unmount the filesystem by doing\nfusermount -u /mnt/hdd1/vm/linux Booting KVM with new Kernel To boot up the VM with the new kernel, we will add a few extra command line options to kvm. For convenience, we put the scripts into a file. It’s also available on gist:\n#!/bin/bash  kvm \\  -s \\  -display gtk \\  -cpu host \\  -vga qxl \\  -accel kvm \\  -kernel \"/home/ed/Desktop/linux_kernel/kbuild/arch/x86/boot/bzImage\" \\  -append \"root=/dev/sda1 console=ttyS0,115200n8 nokaslr\" \\  -drive format=raw,file=/home/ed/virtimg/ubuntu20.04 \\  -m 8G \\  -smp 6 \\  --snapshot \\  -S Aside from the command line arguments we discussed before, there are a few new members here. the -s switch is a shorthand for -gdb tcp::1234. The -display gtk is optional. It enables the opengl context in the display device for gtk display output. -cpu host says the guest should emulate the host processor. -vga qxl enables 3D acceleration on the guest system. -vga virtio also offers good performance in our case. -kernel allows bootloader to pickup the new kernel. The -append along with its arguments specifies where the root partition of the hard disk is and the console parameter adds a serial console at boot so you can see boot messages. The --snapshot in QEMU says the images that refer to an original image will use Redirect-on-Write to avoid changing the original image. The -S means the kernel won’t start executing unless we attach a debugger to it. We only use it later in the debugging stage.\nAgain, we can verify there is internet access using the new kernel using apt update. There are no errors shown, which indicates the network is functioning correctly.\nBooting Process Now we are able to boot up the VM successfully, we can first measure how much time the kernel spends in booting. Running dmesg -d shows the timestamp and time delta spent between messages. The final line shows [10.842998]. If we use systemd-analyze, it outputs\nStartup finished in 795ms (kernel) + 5.451s (userspace) = 6.247s graphical.target reached after 5.439s in userspace The reason why there is a gap between these two measurement is because dmesg is not a reliable test of how long a boot-up process goes. dmesg itself merely collects information. The drivers and other system processes can output messages at any point in time. There may or may not be processes spawning between those messages.\nNext, we are going to look at how PCI device is involved in kernel startup. lspci outputs the follow\n00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02) 00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II] 00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II] 00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03) 00:02.0 VGA compatible controller: Red Hat, Inc. Virtio GPU (rev 01) 00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03) We can use the PCI address here to search for corresponding information in dmesg. For example, if we use the domain value \\(0000:\\) as query, we get something like:\n[ 0.295026] PCI host bridge to bus 0000:00 [ 0.299055] pci 0000:00:00.0: [8086:1237] type 00 class 0x060000 [ 0.300133] pci 0000:00:01.0: [8086:7000] type 00 class 0x060100 [ 0.301163] pci 0000:00:01.1: [8086:7010] type 00 class 0x010180 [ 0.311006] pci 0000:00:02.0: [1af4:1050] type 00 class 0x030000 [ 0.319650] pci 0000:00:03.0: [8086:100e] type 00 class 0x020000 The full result is also available as gist.\nThe lspci command specifies the type of device right after the address. For example, the first one is host bridge. We specifically selected the message in the type 00 class format here. The significance here is that the class value actually telss us the type of the corresponding device. We can check the include/linux/pci_ids.h for each macro respectively. For example,\n#define PCI_CLASS_NETWORK_ETHERNET\t0x0200 this line shows the value 0x0200 corresponds to a network PCI device. This aligns with our dmesg output as well as the lspci result.\nDebugging Kernel To build KVM+GDB-friendly kernel, we need to have proper CONFIG_DEBUG* options set in the .config file. More specifically, we need to have the following options enabled:\n CONFIG_DEBUG_INFO y: compile the kernel with debug info. The full list of definitions can be found here. CONFIG_DEBUG_INFO_DWARF4 y: generate dwarf4 debug info. Definition can be found here. CONFIG_GDB_SCRIPTS y: creates the required links to GDB helper scripts in the build directory. Full definition can be found here. CONFIG_GDB_INFO_REDUCED n: disable reduced gdb info. CONFIG_KGDB y: kernel debugging location. Full list of definitions found here. CONFIG_FRAME_POINTER y: compile the kernel with frame pointers. Full list of definitions found here. CONFIG_SATA_AHCI y: this option enables support for AHCI Serial ATA. Definition found here. CONFIG_KVM_GUEST y: this option enables various optimizations for running under the KVM hypervisor. Definition found here. CONFIG_RANDOMIZE_BASE n: drop support for Kernel Address Space Layout Randomization (KASLR). Definition found here. We also added nokaslr in our qemu arguments. CONFIG_SMP y: enable Symmetric multi-processing support. Definition found here.  Now we can recompile the kernel and attack gdb to it. We simply add -S option to kvm to only start the VM when gdb is attached. Then we enter our  directory and execute:\ngdb vmlinux (gdb) target remote:1234 The step is also documented in the kernel community documentation.\nSet Breakpoints Spin lock is easy to find in a kernel. Therefore, we will set break points on spin_lock. For kernel 5.8.6, we see that spin_lock is defined in https://elixir.bootlin.com/linux/v5.8.6/source/include/linux/spinlock.h#L351 as a inline function. If we trace the function, we can see the actual function we should use is _raw_spin_lock defined here:\n#ifndef CONFIG_INLINE_SPIN_LOCK void __lockfunc _raw_spin_lock(raw_spinlock_t *lock) { __raw_spin_lock(lock); } If we need to break the execution only when a given program is executed, we can use the program PID to as the condition. The problem is, how do we get the program PID if it doesn’t last for long?\nWe could instead first set a breakpoint on fork. We can break its kernel call at _do_fork which is defined here. After that, we can simply continue executing the kernel until we run the program.\n Note: we need to compile the program and open a new terminal first. Since they both involves forking new processes, which will hit _do_fork before our program runs.\n Then we print the process PID using p $lx_current().pid, we then use this value as the condition for b _raw_spin_lock if $lx_current().pid == pid_value inside gdb.\nIf we want _raw_spin_lock to break under different contexts, we can simply use PID as different contexts. We can also set break points in functions in different contexts that calls spin_lock and see what they do. For example, we can set break point at expand_downwards defined in here, if we back trace this function, we will get a series of calls, we mention the important ones here\n#1 0xffffffff81284c4e in expand_stack #3 0xffffffff813843db in load_elf_binary #8 do_execve #12 0xffffffff81b1f658 in do_syscall_64 We also added a helper script in .gdbinit to print our the name of the function, which is ‘‘anacron’’ in this case. In short, this process execute commands periodically, and it performs a sys call which loads elf binary, thus requiring stack expansion.\nAnother example is timer interrupt. The get_next_timer_interrupt calls _raw_spin_lock. We select some messages from backtrace:\n#1 0xffffffff8113b224 in get_next_timer_interrupt #2 0xffffffff8114d52e in tick_nohz_next_event #4 tick_nohz_idle_stop_tick () #5 0xffffffff810df567 in cpuidle_idle_call () In short, the is a timer interrupt that gets called when CPU is idle.\nThe last example is hrtimer_interrupt. The selected messages are:\n#4 0xffffffff8114d80c in tick_sched_timer #7 0xffffffff8113c8e7 in hrtimer_interrupt #12 run_on_irqstack_cond #14 0xffffffff81c00cc2 in asm_sysvec_apic_timer_interrupt In summary, hrtimer_interrupt is called as event handler. This function is responsible to select all timers that have expired and either move them to the expiration list (if they may be processed in softIRQ context) or call the handler function directly.\nSyscall Essentially, processor switches from the user mode to kernel mode and starts execution of the sys call entry - entry_SYSCALL_64, we can find its definition at here. This is the only entry point used for 64-bit system calls. We can set a break point here. When the break point is hit, we use info registers in gdb to get the value of cr3. In our case, it is 0x22a6d5806. Then we simply step from this breakpoint, and will likely reach SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp. After this call the value in cr3 is changed to 0x22a6d4006. The macro is defined here.\nWe can see whenever the processor switch from the user mode to kernel mode the value of cr3 is changed. The root cause the Page Table Isolation (PTI). It is a countermeasure against attacks on the shared user/kernel address space such as the ‘‘Meltdown’’ approach. To mitigate this class of attacks, two independent page table copies are created, one in kernel space, one in user space. The cr3 register enables the processor to translate linear addresses into physical addresses by locating the page directory and page tables for the current task. So whenever the process enters kernel mode, the kernel copy requires its page directory address to be loaded into cr3 register.\nIf we add nopti in -append in the QEMU cmd argument and perform the same steps. We get 0x231466005 before and after SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp is executed. Based on the desciption in the linux kernel tree, the nopti on X86_64 is equivalent to pti=off, therefore explaining the constant value of cr3.\n","wordCount":"2506","inLanguage":"en","datePublished":"2020-09-14T00:00:00Z","dateModified":"2020-09-14T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.bodunhu.com/blog/posts/kernelhacking/"},"publisher":{"@type":"Organization","name":"std::bodun::blog","logo":{"@type":"ImageObject","url":"https://www.cs.utexas.edu/sites/default/files/favicon.ico"}}}</script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://www.bodunhu.com/blog/ accesskey=h title="std::bodun::blog (Alt + H)">std::bodun::blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.bodunhu.com/blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.bodunhu.com/blog/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://www.bodunhu.com/blog/about/ title=About><span>About</span></a></li><li><a href=https://www.bodunhu.com/blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://www.bodunhu.com/blog/>Home</a>&nbsp;»&nbsp;<a href=https://www.bodunhu.com/blog/posts/>Posts</a></div><h1 class=post-title>Start Linux Kernel Hacking</h1><div class=post-meta>September 14, 2020&nbsp;·&nbsp;12 min</div></header><div class=post-content><p align=center><a href=https://www.redandblack.com/opinion/opinion-make-the-switch-to-a-linux-operating-system/article_0b8bb324-5425-11e9-9d96-ab61c820e566.html><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/linux_kernel_hacking/linux.jpg width=80%></a></p><p>This is a summary of how to compile and boot the Linux kernel on the KVM-qemu virtual machine. It covers how to get a VM running in KVM, how to build a customized kernel, and how to use GDB with the Linux kernel. The experiment is conducted on an amd64 architecture CPU. We use Ubuntu as our testing environment but the steps covered here should apply to other distros as well.</p><h2 id=getting-a-vm-running-in-kvm>Getting a VM running in KVM<a hidden class=anchor aria-hidden=true href=#getting-a-vm-running-in-kvm>#</a></h2><p>The Ubuntu ISO image is downloaded from the <a href=https://ubuntu.com/download/desktop>Canonical website</a>. The kernel is downloaded directly from <a href=https://www.kernel.org/>kernel.org</a>. The specs of our test environment is:</p><ul><li>CPU: Intel(R) Core(TM) i7-6800K CPU @ 3.40GHz</li><li>RAM: 32 GB</li><li>Host and Guest OS: Ubuntu 20.04.1 LTS</li><li>Host Kernel Version: 5.4.0-47-generic</li><li>GCC: 7.5.0</li><li>QEMU emulator version: 4.2.0</li><li>Guest Kernel Version: 5.8.6</li></ul><p>After we obtained the Ubuntu ISO image, we use GUI virt-manager to install the OS. One thing to notice here is the default directory for virtual disks is <code>/var/lib/libvirt/images</code>, since my system partition is located on a separate SSD with limited space, the virtual disk directory is changed to my <code>/home</code> directory instead.</p><p>We also create the new virtual disk inside virt-manager. We chose raw format instead of qcow2. Creating a new image file can also be done in command line using:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>qemu-img create -f raw -o preallocation<span style=color:#f92672>=</span>full vmdisk.img 40G
</code></pre></div><p>The preallocation can be turn either on or off depends on personal choices. After the disk image is created, we proceeds in virt-manager to install Ubuntu on the newly allocated virtual disk. We enabled storage for this virtual machine so that we don&rsquo;t need to repeat the installation process every time we launch the VM. One thing to be noticed here is we don&rsquo;t need swap area inside a virtual machine. We can simply use the whole virtual disk for <code>/</code> partition.</p><p>To start the VM from cmd, you might need to change the owner of the disk image. We add the user to both <code>kvm</code> and <code>libvirt</code>. The image created or accessed by virt-manager seems to change the file owner to libvirt-qemu, which may cause problems when starting from cmd.</p><p>After the installation is finished, we can simply launch the virtual machine inside virt-manager through its GUI interface. We can also use command line to start the VM:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>kvm -accel kvm -m 8G -smp <span style=color:#ae81ff>6</span> --snapshot -drive format<span style=color:#f92672>=</span>raw,file<span style=color:#f92672>=</span>/home/ed/virtimg/ubuntu20.04
</code></pre></div><p>The argument <code>-accel kvm</code> enables Kernel-based Virtual Machine full virtualization, which uses hardware acceleration. Without this option the VM will become extremely slow. The <code>-m 8G</code> assigns the given amount of memory to the VM. The <code>-smp 6</code> assigns the given number of cores to the guest if the host has multiple cores. The <code>--snapshot</code> ensures that no changes are made to your image during an execution so you can do something dangerous and have the original image file preserved. The <code>-drive</code> option specifies the location of the virtual disk and its format. We will use some of these options later.</p><p>To confirm the VM has internet access, simply execution <code>apt install pkg-name</code> in the guest terminal. No error message would indicates properly functioning network access from the guest VM. For example, when we execute <code>sudo apt install llvm</code> it shows:</p><pre><code>Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following additional packages will be installed:
  llvm-runtime
The following NEW packages will be installed:
  llvm llvm-runtime
0 upgraded, 2 newly installed, 0 to remove and 0 not upgraded.
Need to get 6,796 B of archives.
After this operation, 128 kB of additional disk space will be used.
Do you want to continue? [Y/n] 
</code></pre><h2 id=building-the-kernel>Building the Kernel<a hidden class=anchor aria-hidden=true href=#building-the-kernel>#</a></h2><p>We can use out customized kernel for our newly created VM. After we obtain the Linux kernel from <a href=https://www.kernel.org/>kernel.org</a>, we extract the source into &lt;kernel dir> and create a separate build directory &lt;kbuild> (outside &lt;kernel dir>).</p><p>Then we enter the &lt;kbuild> directory, run</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>yes <span style=color:#e6db74>&#34;&#34;</span> | make -C /home/ed/Desktop/linux_kernel/kbuild O<span style=color:#f92672>=</span><span style=color:#66d9ef>$(</span>pwd<span style=color:#66d9ef>)</span> config
</code></pre></div><p>This will create a <code>.config</code> file inside &lt;kbuild> with the default options selected. We then open the configuration file and ensures <code>CONFIG_SATA_AHCI=y</code>, which builds the SATA disk driver into the kernel. That will allow your kernel to boot off a (virtual) SATA drive without having to load a module to do it.</p><p>Next we build the kernel by running <code>make</code> in &lt;kbuild>. We use the -j 6 option speedup the building process using multiple processor cores. This process can take a long time.</p><h2 id=build-and-install-kernel-modules>Build and Install Kernel Modules<a hidden class=anchor aria-hidden=true href=#build-and-install-kernel-modules>#</a></h2><p>To build modules locally on host, we create another separate &lt;install_mod_dir> directory for building kernel modules. Then in &lt;kbuild>, execute</p><pre><code>make INSTALL_MOD_PATH=/home/ed/Desktop/linux_kernel/install_mod_dir modules_install 
</code></pre><p>Now there is a <code>lib</code> directory inside <code>/home/ed/Desktop/linux_kernel/install_mod_dir</code>, which holds all the kernel modules we are about to install.</p><p>The complete list of modules can be listed using <code>cat modules.builtin</code> inside <code>lib/moduels/5.8.6</code>. Here is a <a href=https://gist.github.com/BDHU/4d31d18ad106a13caceac4a961d04a44>link</a> to all the modules being built. We didn&rsquo;t modify anything in the configuration.</p><p>Then we use guestmount to mount the virtual disk to a mount point on the host</p><pre><code>guestmount -a /home/ed/virtimg/ubuntu20.04 -i ~/vm/linux/
</code></pre><p>In Ubuntu this step yields the following message:</p><pre><code>libguestfs: error: /usr/bin/supermin exited with error status 1.
To see full error messages you may need to enable debugging.
Do:
  export LIBGUESTFS_DEBUG=1 LIBGUESTFS_TRACE=1
and run the command again.  For further information, read:
  http://libguestfs.org/guestfs-faq.1.html#debugging-libguestfs
You can also run 'libguestfs-test-tool' and post the *complete* output
into a bug report or message to the libguestfs mailing list.
</code></pre><p>The underlying problem is that the kernel cannot be read and according to the <a href=https://askubuntu.com/questions/1046828/how-to-run-libguestfs-tools-tools-such-as-virt-make-fs-without-sudo>post</a> and the <a href=https://bugs.launchpad.net/fuel/+bug/1467579>bug report</a> on Ubuntu Launchpad.</p><p>To fix the issue, we need to run</p><pre><code>sudo chmod +r /boot/vmlinuz-*
</code></pre><p>We can verify the contents inside ~/vm/linux by simply cd into it.</p><p>To install the modules we just built, we can copy the <code>&lt;install_mod_dir>lib/modules</code> into the mounted filesystem <code>&lt;mount_point>/lib/modules</code>.</p><p>Finally, we unmount the filesystem by doing</p><pre><code>fusermount -u /mnt/hdd1/vm/linux
</code></pre><h2 id=booting-kvm-with-new-kernel>Booting KVM with new Kernel<a hidden class=anchor aria-hidden=true href=#booting-kvm-with-new-kernel>#</a></h2><p>To boot up the VM with the new kernel, we will add a few extra command line options to kvm. For convenience, we put the scripts into a file. It&rsquo;s also available on <a href=https://gist.github.com/BDHU/8c6ab518ab37571a1cae132d79ac9a9e>gist</a>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=color:#75715e>#!/bin/bash
</span><span style=color:#75715e></span>
kvm <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -s <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -display gtk <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -cpu host <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -vga qxl <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -accel kvm <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -kernel <span style=color:#e6db74>&#34;/home/ed/Desktop/linux_kernel/kbuild/arch/x86/boot/bzImage&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -append <span style=color:#e6db74>&#34;root=/dev/sda1 console=ttyS0,115200n8 nokaslr&#34;</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -drive format<span style=color:#f92672>=</span>raw,file<span style=color:#f92672>=</span>/home/ed/virtimg/ubuntu20.04 <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -m 8G <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -smp <span style=color:#ae81ff>6</span> <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    --snapshot <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>    -S
</code></pre></div><p>Aside from the command line arguments we discussed before, there are a few new members here. the <code>-s</code> switch is a shorthand for <code>-gdb tcp::1234</code>. The <code>-display gtk</code> is optional. It enables the opengl context in the display device for gtk display output. <code>-cpu host</code> says the guest should emulate the host processor. <code>-vga qxl</code> enables 3D acceleration on the guest system. <code>-vga virtio</code> also offers good performance in our case. <code>-kernel</code> allows bootloader to pickup the new kernel. The <code>-append</code> along with its arguments specifies where the root partition of the hard disk is and the console parameter adds a serial console at boot so you can see boot messages. The <code>--snapshot</code> in QEMU says the images that refer to an original image will use Redirect-on-Write to avoid changing the original image. The <code>-S</code> means the kernel won&rsquo;t start executing unless we attach a debugger to it. We only use it later in the debugging stage.</p><p>Again, we can verify there is internet access using the new kernel using <code>apt update</code>. There are no errors shown, which indicates the network is functioning correctly.</p><h2 id=booting-process>Booting Process<a hidden class=anchor aria-hidden=true href=#booting-process>#</a></h2><p>Now we are able to boot up the VM successfully, we can first measure how much time the kernel spends in booting. Running <code>dmesg -d</code> shows the timestamp and time delta spent between messages. The final line shows <code>[10.842998]</code>. If we use <code>systemd-analyze</code>, it outputs</p><pre><code>Startup finished in 795ms (kernel) + 5.451s (userspace) = 6.247s
graphical.target reached after 5.439s in userspace
</code></pre><p>The reason why there is a gap between these two measurement is because <code>dmesg</code> is not a reliable test of how long a boot-up process goes. <code>dmesg</code> itself merely collects information. The drivers and other system processes can output messages at any point in time. There may or may not be processes spawning between those messages.</p><p>Next, we are going to look at how PCI device is involved in kernel startup. <code>lspci</code> outputs the follow</p><pre><code>00:00.0 Host bridge: Intel Corporation 440FX - 82441FX PMC [Natoma] (rev 02)
00:01.0 ISA bridge: Intel Corporation 82371SB PIIX3 ISA [Natoma/Triton II]
00:01.1 IDE interface: Intel Corporation 82371SB PIIX3 IDE [Natoma/Triton II]
00:01.3 Bridge: Intel Corporation 82371AB/EB/MB PIIX4 ACPI (rev 03)
00:02.0 VGA compatible controller: Red Hat, Inc. Virtio GPU (rev 01)
00:03.0 Ethernet controller: Intel Corporation 82540EM Gigabit Ethernet Controller (rev 03)
</code></pre><p>We can use the PCI address here to search for corresponding information in <code>dmesg</code>. For example, if we use the domain value \(0000:\) as query, we get something like:</p><pre><code>[    0.295026] PCI host bridge to bus 0000:00
[    0.299055] pci 0000:00:00.0: [8086:1237] type 00 class 0x060000
[    0.300133] pci 0000:00:01.0: [8086:7000] type 00 class 0x060100
[    0.301163] pci 0000:00:01.1: [8086:7010] type 00 class 0x010180
[    0.311006] pci 0000:00:02.0: [1af4:1050] type 00 class 0x030000
[    0.319650] pci 0000:00:03.0: [8086:100e] type 00 class 0x020000
</code></pre><p>The full result is also available as <a href=https://gist.github.com/BDHU/4d31d18ad106a13caceac4a961d04a44#file-dmesg_output>gist</a>.</p><p>The <code>lspci</code> command specifies the type of device right after the address. For example, the first one is host bridge. We specifically selected the message in the <em>type 00 class</em> format here. The significance here is that the class value actually telss us the type of the corresponding device. We can check the <a href=https://github.com/torvalds/linux/blob/master/include/linux/pci_ids.h>include/linux/pci_ids.h</a> for each macro respectively. For example,</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#define PCI_CLASS_NETWORK_ETHERNET	0x0200
</span></code></pre></div><p>this line shows the value 0x0200 corresponds to a network PCI device. This aligns with our <code>dmesg</code> output as well as the <code>lspci</code> result.</p><h2 id=debugging-kernel>Debugging Kernel<a hidden class=anchor aria-hidden=true href=#debugging-kernel>#</a></h2><p>To build KVM+GDB-friendly kernel, we need to have proper CONFIG_DEBUG* options set in the .config file. More specifically, we need to have the following options enabled:</p><ul><li>CONFIG_DEBUG_INFO y: compile the kernel with debug info. The full list of definitions can be found <a href=https://cateee.net/lkddb/web-lkddb/DEBUG_INFO.html>here</a>.</li><li>CONFIG_DEBUG_INFO_DWARF4 y: generate dwarf4 debug info. Definition can be found <a href=https://cateee.net/lkddb/web-lkddb/DEBUG_INFO_DWARF4.html>here</a>.</li><li>CONFIG_GDB_SCRIPTS y: creates the required links to GDB helper scripts in the build directory. Full definition can be found <a href=https://cateee.net/lkddb/web-lkddb/GDB_SCRIPTS.html>here</a>.</li><li>CONFIG_GDB_INFO_REDUCED n: disable reduced gdb info.</li><li>CONFIG_KGDB y: kernel debugging location. Full list of definitions found <a href=https://cateee.net/lkddb/web-lkddb/KGDB.html>here</a>.</li><li>CONFIG_FRAME_POINTER y: compile the kernel with frame pointers. Full list of definitions found <a href=https://cateee.net/lkddb/web-lkddb/FRAME_POINTER.html>here</a>.</li><li>CONFIG_SATA_AHCI y: this option enables support for AHCI Serial ATA. Definition found <a href=https://cateee.net/lkddb/web-lkddb/SATA_AHCI.html>here</a>.</li><li>CONFIG_KVM_GUEST y: this option enables various optimizations for running under the KVM hypervisor. Definition found <a href=https://cateee.net/lkddb/web-lkddb/KVM_GUEST.html>here</a>.</li><li>CONFIG_RANDOMIZE_BASE n: drop support for Kernel Address Space Layout Randomization (KASLR). Definition found <a href=https://cateee.net/lkddb/web-lkddb/RANDOMIZE_BASE.html>here</a>. We also added <code>nokaslr</code> in our qemu arguments.</li><li>CONFIG_SMP y: enable Symmetric multi-processing support. Definition found <a href=https://cateee.net/lkddb/web-lkddb/SMP.html>here</a>.</li></ul><p>Now we can recompile the kernel and attack gdb to it. We simply add <code>-S</code> option to kvm to only start the VM when gdb is attached. Then we enter our &lt;kbuild> directory and execute:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell>gdb vmlinux
<span style=color:#f92672>(</span>gdb<span style=color:#f92672>)</span> target remote:1234
</code></pre></div><p>The step is also documented in the kernel community <a href=https://www.kernel.org/doc/html/latest/dev-tools/gdb-kernel-debugging.html>documentation</a>.</p><h2 id=set-breakpoints>Set Breakpoints<a hidden class=anchor aria-hidden=true href=#set-breakpoints>#</a></h2><p>Spin lock is easy to find in a kernel. Therefore, we will set break points on <code>spin_lock</code>. For kernel 5.8.6, we see that <code>spin_lock</code> is defined in <a href=https://elixir.bootlin.com/linux/v5.8.6/source/include/linux/spinlock.h#L351>https://elixir.bootlin.com/linux/v5.8.6/source/include/linux/spinlock.h#L351</a> as a inline function. If we trace the function, we can see the actual function we should use is <code>_raw_spin_lock</code> defined <a href=https://elixir.bootlin.com/linux/v5.8.6/source/kernel/locking/spinlock.c#L149>here</a>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>#ifndef CONFIG_INLINE_SPIN_LOCK
</span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> __lockfunc <span style=color:#a6e22e>_raw_spin_lock</span>(raw_spinlock_t <span style=color:#f92672>*</span>lock)
{
	__raw_spin_lock(lock);
}
</code></pre></div><p>If we need to break the execution only when a given program is executed, we can use the program PID to as the condition. The problem is, how do we get the program PID if it doesn&rsquo;t last for long?</p><p>We could instead first set a breakpoint on <code>fork</code>. We can break its kernel call at <code>_do_fork</code> which is defined <a href=https://elixir.bootlin.com/linux/v5.8.6/source/kernel/fork.c#L2416>here</a>. After that, we can simply continue executing the kernel until we run the program.</p><blockquote><p>Note: we need to compile the program and open a new terminal first. Since they both involves forking new processes, which will hit <code>_do_fork</code> before our program runs.</p></blockquote><p>Then we print the process PID using <code>p $lx_current().pid</code>, we then use this value as the condition for <code>b _raw_spin_lock if $lx_current().pid == pid_value</code> inside gdb.</p><p>If we want <code>_raw_spin_lock</code> to break under different contexts, we can simply use PID as different contexts. We can also set break points in functions in different contexts that calls <code>spin_lock</code> and see what they do. For example, we can set break point at <code>expand_downwards</code> defined in <a href=https://elixir.bootlin.com/linux/v5.8.6/source/mm/mmap.c#L2428>here</a>, if we back trace this function, we will get a series of calls, we mention the important ones here</p><pre><code>#1  0xffffffff81284c4e in expand_stack
#3 0xffffffff813843db in load_elf_binary
#8  do_execve
#12 0xffffffff81b1f658 in do_syscall_64
</code></pre><p>We also added a helper script in .gdbinit to print our the name of the function, which is &lsquo;&lsquo;anacron&rsquo;&rsquo; in this case.
In short, this process execute commands periodically, and it performs a sys call which loads elf binary, thus requiring stack expansion.</p><p>Another example is timer interrupt. The <code>get_next_timer_interrupt</code> calls <code>_raw_spin_lock</code>. We select some messages from backtrace:</p><pre><code>#1  0xffffffff8113b224 in get_next_timer_interrupt
#2  0xffffffff8114d52e in tick_nohz_next_event
#4  tick_nohz_idle_stop_tick ()
#5  0xffffffff810df567 in cpuidle_idle_call ()
</code></pre><p>In short, the is a timer interrupt that gets called when CPU is idle.</p><p>The last example is <code>hrtimer_interrupt</code>. The selected messages are:</p><pre><code>#4  0xffffffff8114d80c in tick_sched_timer
#7  0xffffffff8113c8e7 in hrtimer_interrupt
#12 run_on_irqstack_cond
#14 0xffffffff81c00cc2 in asm_sysvec_apic_timer_interrupt
</code></pre><p>In summary, <code>hrtimer_interrupt</code> is called as event handler. This function is responsible to select all timers that have expired and either move them to the expiration list (if they may be processed in softIRQ context) or call the handler function directly.</p><h2 id=syscall>Syscall<a hidden class=anchor aria-hidden=true href=#syscall>#</a></h2><p>Essentially, processor switches from the user mode to kernel mode and starts execution of the sys call entry - <code>entry_SYSCALL_64</code>, we can find its definition at <a href=https://elixir.bootlin.com/linux/v5.8.6/source/arch/x86/entry/entry_64.S#L94>here</a>. This is the only entry point used for 64-bit system calls. We can set a break point here. When the break point is hit, we use <code>info registers</code> in gdb to get the value of cr3. In our case, it is 0x22a6d5806. Then we simply step from this breakpoint, and will likely reach <code>SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</code>. After this call the value in cr3 is changed to 0x22a6d4006. The macro is defined <a href=https://elixir.bootlin.com/linux/v5.8.6/source/arch/x86/entry/entry_32.S#L165>here</a>.</p><p>We can see whenever the processor switch from the user mode to kernel mode the value of cr3 is changed. The root cause the Page <a href=https://www.kernel.org/doc/html/latest/x86/pti.html>Table Isolation (PTI)</a>. It is a countermeasure against attacks on the shared user/kernel address space such as the &lsquo;&lsquo;Meltdown&rsquo;&rsquo; approach. To mitigate this class of attacks, two independent page table copies are created, one in kernel space, one in user space. The cr3 register enables the processor to translate linear addresses into physical addresses by locating the page directory and page tables for the current task. So whenever the process enters kernel mode, the kernel copy requires its page directory address to be loaded into cr3 register.</p><p>If we add <code>nopti</code> in <code>-append</code> in the QEMU cmd argument and perform the same steps. We get 0x231466005 before and after <code>SWITCH_TO_KERNEL_CR3 scratch_reg=%rsp</code> is executed. Based on the desciption in the <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/admin-guide/kernel-parameters.txt?h=v5.1.3#L3656">linux kernel tree</a>, the <code>nopti</code> on X86_64 is equivalent to pti=off, therefore explaining the constant value of cr3.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://www.bodunhu.com/blog/tags/os/>os</a></li><li><a href=https://www.bodunhu.com/blog/tags/linux/>linux</a></li><li><a href=https://www.bodunhu.com/blog/tags/kernel/>kernel</a></li></ul><nav class=paginav><a class=prev href=https://www.bodunhu.com/blog/posts/xenvirtualization/><span class=title>« Prev Page</span><br><span>Xen and the Art of Virtualization</span></a>
<a class=next href=https://www.bodunhu.com/blog/posts/wireless_anomaly/><span class=title>Next Page »</span><br><span>Performance Anamoly of 802.11b</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Start Linux Kernel Hacking on twitter" href="https://twitter.com/intent/tweet/?text=Start%20Linux%20Kernel%20Hacking&url=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fkernelhacking%2f&hashtags=os%2clinux%2ckernel"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Start Linux Kernel Hacking on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fkernelhacking%2f&title=Start%20Linux%20Kernel%20Hacking&summary=Start%20Linux%20Kernel%20Hacking&source=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fkernelhacking%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Start Linux Kernel Hacking on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fkernelhacking%2f&title=Start%20Linux%20Kernel%20Hacking"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Start Linux Kernel Hacking on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fkernelhacking%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Start Linux Kernel Hacking on whatsapp" href="https://api.whatsapp.com/send?text=Start%20Linux%20Kernel%20Hacking%20-%20https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fkernelhacking%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Start Linux Kernel Hacking on telegram" href="https://telegram.me/share/url?text=Start%20Linux%20Kernel%20Hacking&url=https%3a%2f%2fwww.bodunhu.com%2fblog%2fposts%2fkernelhacking%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><script src=https://utteranc.es/client.js repo=BDHU/blog issue-term=pathname theme=github-light crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2021 <a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>