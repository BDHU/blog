<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>mm on std::bodun::blog</title>
    <link>https://www.bodunhu.com/blog/tags/mm/</link>
    <description>Recent content in mm on std::bodun::blog</description>
    <image>
      <url>https://www.bodunhu.com/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://www.bodunhu.com/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 03 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://www.bodunhu.com/blog/tags/mm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Program Loading and Memory Mapping in Linux</title>
      <link>https://www.bodunhu.com/blog/posts/programloadingandmemorymappinginlinux/</link>
      <pubDate>Tue, 03 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.bodunhu.com/blog/posts/programloadingandmemorymappinginlinux/</guid>
      <description>The goal here is to familiarize yourself with how programs are loaded, dynamically paged, and some of the mechanics of signal handling and memory mapping in Linux.
 execve Syscall The operating system, as one of itsd basic services, loads programs into memory for them to execute. Programs rely on execve syscall to get the OS to load the program into memory and start it executing as a process. The kernel version we used to testing is 5.</description>
    </item>
    
    <item>
      <title>Linux Program Measurement and mmap</title>
      <link>https://www.bodunhu.com/blog/posts/linuxkernelmeasurementandmmap/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.bodunhu.com/blog/posts/linuxkernelmeasurementandmmap/</guid>
      <description>This is a summary over Linux kernel program measurement and mmap. The specs of our experiment environment is listed below. For more details regarding the CPU spec please refer to cpu world. This is the system spec:
   Attribute Value     Processor name (BIOS) Intel(R) Core(TM) i7-6800K CPU @ 3.40GHz   Cores 6   Logical processors 12   TLB/Cache details 64-byte Prefetching Data TLB: 1-GB pages, 4-way set associative, 4 entries Data TLB: 4-KB Pages, 4-way set associative, 64 entries Instruction TLB: 4-KByte pages, 8-way set associative, 64 entries L2 TLB: 1-MB, 4-way set associative, 64-byte line size Shared 2nd-Level TLB: 4-KB / 2-MB pages, 6-way associative, 1536 entries.</description>
    </item>
    
    <item>
      <title>Memory Resource Management in VMware ESX Server</title>
      <link>https://www.bodunhu.com/blog/posts/vmwareesxserver/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://www.bodunhu.com/blog/posts/vmwareesxserver/</guid>
      <description>VMWare ESX Server is a software layer designed to multiplex hardware resources among virtual machines running unmodified commodity operating systems. ESX Server, different to VMware Workstation, is a type 1 hypervisor, which means it runs directly on bare metal. ESX Server focuses on running guest VMs without modifying the guest OSes at all, which is challenging.
  Memory Virtualization is done by interposing an extra abstraction layer between a physical address from the VM&amp;rsquo;s point of view, and a machine address which represents the actual hardware memory.</description>
    </item>
    
    <item>
      <title>A Little Review on Barrelfish Memory Management </title>
      <link>https://www.bodunhu.com/blog/posts/operatingsystemmemorymanagement/</link>
      <pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.bodunhu.com/blog/posts/operatingsystemmemorymanagement/</guid>
      <description>The memory management has been mentioned numerous times and still remains huge topic. virtual vs. physical memory, physical frame allocation, MMUs, page faults, address space layout, and demand paging and swapping are familiar terms for every undergrad in college.
In monolithic kernels such as Linux, much of the functionality is handled in kernel. However, there are OSes that push these functionalities to user space such as Barrelfish. Many concept here will thus be borrowed from the Barrelfish OS.</description>
    </item>
    
    <item>
      <title>Pascal GPU memory and cache hierarchy</title>
      <link>https://www.bodunhu.com/blog/posts/gpumemoryhierarchy/</link>
      <pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://www.bodunhu.com/blog/posts/gpumemoryhierarchy/</guid>
      <description>Memory access efÔ¨Åciency is an important factor in fully utilizing the computational power of graphics processing units (GPUs). However, many GPU vendors like NVIDIA kept the GPU memory hierarchy as a secret. Therefore it becomes hard to measure GPUs performance and sets barriers to understand memory access patterns, which is a key component to improve program&amp;rsquo;s performance. Here we introduce a novel fine-grained microbenchmark approach and apply to the Pascal generation.</description>
    </item>
    
    <item>
      <title>Virtual Memory Mechanisms</title>
      <link>https://www.bodunhu.com/blog/posts/virtualaddressmechanism/</link>
      <pubDate>Thu, 19 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.bodunhu.com/blog/posts/virtualaddressmechanism/</guid>
      <description>As we can see in the previous post, all allocation algorithms we discussed lead to external fragmentation. As time goes by, external fragmentation is going to get worse and we need solutions for the problem. We can use swap areas to swap out memory onto the disk, or move allocated memory together(a process named memory compaction), leaving empty spaces together. Even these approaches can reduce external fragmentation and allow a higher degree of multiprogramming, they are not perfect.</description>
    </item>
    
    <item>
      <title>Virtual Memory Overview</title>
      <link>https://www.bodunhu.com/blog/posts/virtualaddress/</link>
      <pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://www.bodunhu.com/blog/posts/virtualaddress/</guid>
      <description>I love pointers. Pointer is very a useful feature in programming languages like C/C++. I can pass weird hexidecimal numbers to a function and then it will magically locate where the program is in memory. However, all those values we see are merely virtual addresses, a running program&amp;rsquo;s view of memory in system. Any address we can see while programming user-level programs is a virtual address. It is no more than an illusion of where the data is actually laid out in memory.</description>
    </item>
    
  </channel>
</rss>
