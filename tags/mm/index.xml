<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>mm on std::bodun::blog</title><link>https://www.bodunhu.com/blog/tags/mm/</link><description>Recent content in mm on std::bodun::blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 23 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://www.bodunhu.com/blog/tags/mm/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux Program Measurement and mmap</title><link>https://www.bodunhu.com/blog/posts/linux-program-measurement-and-mmap/</link><pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/linux-program-measurement-and-mmap/</guid><description>This is a summary over Linux kernel program measurement and mmap. The specs of our experiment environment is listed below. For more details regarding the CPU spec please refer to &lt;a href="http://www.cpu-world.com/CPUs/Core_i7/Intel-Core%20i7%20i7-6800K.html">cpu world&lt;/a> for more info</description></item><item><title>Memory Resource Management in VMware ESX Server</title><link>https://www.bodunhu.com/blog/posts/memory-resource-management-in-vmware-esx-server/</link><pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/memory-resource-management-in-vmware-esx-server/</guid><description>VMWare ESX Server is a software layer designed to multiplex hardware resources among virtual machines running unmodified commodity operating systems. ESX Server, different to VMware Workstation, is a type 1 hypervisor, which means it runs directly on bare metal. ESX Server focuses on running guest VMs without modifying the guest OSes at all, which is challenging.
Memory Virtualization is done by interposing an extra abstraction layer between a physical address from the VM&amp;rsquo;s point of view, and a machine address which represents the actual hardware memory.</description></item><item><title>A Little Review on Barrelfish Memory Managements</title><link>https://www.bodunhu.com/blog/posts/a-little-review-on-barrelfish-memory-managements/</link><pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/a-little-review-on-barrelfish-memory-managements/</guid><description>The memory management has been mentioned numerous times and still remains huge topic. virtual vs. physical memory, physical frame allocation, MMUs, page faults, address space layout, and demand paging and swapping are familiar terms for every undergrad in college. In monolithic kernels such as Linux, much of the functionality is handled in kernel. However, there are OSes, such as Barrelfish, that takes a different approach by pushing these functionalities to user space.</description></item><item><title>Pascal GPU memory and cache hierarchy</title><link>https://www.bodunhu.com/blog/posts/pascal-gpu-memory-and-cache-hierarchy/</link><pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/pascal-gpu-memory-and-cache-hierarchy/</guid><description>Memory access efﬁciency is an important factor in fully utilizing the computational power of graphics processing units (GPUs). However, many GPU vendors like NVIDIA kept the GPU memory hierarchy as a secret. Therefore it becomes hard to measure GPUs performance and sets barriers to understand memory access patterns, which is a key component to improve program&amp;rsquo;s performance. Here we introduce a novel fine-grained microbenchmark approach and apply to the Pascal generation. Turing architecture might have different results, but the method we used here can be applied as well with slight modification. The method we use in this guide is inspired by the research paper: &lt;a href="https://ieeexplore.ieee.org/document/7445236">Dissecting GPU Memory Hierarchy through Microbenchmarking&lt;/a>. Here we will explain how P-Chase works and walk through a small example</description></item><item><title>Virtual Memory Mechanisms</title><link>https://www.bodunhu.com/blog/posts/virtual-memory-mechanisms/</link><pubDate>Thu, 19 Oct 2017 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/virtual-memory-mechanisms/</guid><description>As we can see in the previous post, all allocation algorithms we discussed lead to external fragmentation. As time goes by, external fragmentation is going to get worse and we need solutions for the problem. We can use swap areas to swap out memory onto the disk, or move allocated memory together(a process named memory compaction), leaving empty spaces together. Even these approaches can reduce external fragmentation and allow a higher degree of multiprogramming, they are not perfect.</description></item><item><title>Virtual Memory Overview</title><link>https://www.bodunhu.com/blog/posts/virtual-memory-overview/</link><pubDate>Sun, 08 Oct 2017 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/virtual-memory-overview/</guid><description>I love pointers. Pointer is very a useful feature in programming languages like C/C++. I can pass weird hexadecimal numbers to a function and then it will magically locate where the program is in memory. However, all those values we see are merely virtual addresses, a running program&amp;rsquo;s view of memory in system. Any address we can see while programming user-level programs is a virtual address. It is no more than an illusion of where the data is actually laid out in memory.</description></item></channel></rss>