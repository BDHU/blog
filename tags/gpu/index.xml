<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>gpu on std::bodun::blog</title><link>https://www.bodunhu.com/blog/tags/gpu/</link><description>Recent content in gpu on std::bodun::blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 21 Jun 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://www.bodunhu.com/blog/tags/gpu/index.xml" rel="self" type="application/rss+xml"/><item><title>From Autotools to CMake</title><link>https://www.bodunhu.com/blog/posts/from-autotools-to-cmake/</link><pubDate>Mon, 21 Jun 2021 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/from-autotools-to-cmake/</guid><description>Since my paper on GPU benchmarking was published, every once in a while, I got emails asking me why Altis doesn&amp;rsquo;t build on their platforms. It almost always has something to do a small script which is responsible for finding CUDA dependencies. This script is invoked every single time make is executed. For some reason, the regular expression in the script sometimes breaks randomly, depending on the Linux distro, the kernel version, the host architecture, or even the CUDA version.</description></item><item><title>Pascal GPU memory and cache hierarchy</title><link>https://www.bodunhu.com/blog/posts/pascal-gpu-memory-and-cache-hierarchy/</link><pubDate>Tue, 15 Jan 2019 00:00:00 +0000</pubDate><guid>https://www.bodunhu.com/blog/posts/pascal-gpu-memory-and-cache-hierarchy/</guid><description>Memory access efï¬ciency is an important factor in fully utilizing the computational power of graphics processing units (GPUs). However, many GPU vendors like NVIDIA kept the GPU memory hierarchy as a secret. Therefore it becomes hard to measure GPUs performance and sets barriers to understand memory access patterns, which is a key component to improve program&amp;rsquo;s performance. Here we introduce a novel fine-grained microbenchmark approach and apply to the Pascal generation. Turing architecture might have different results, but the method we used here can be applied as well with slight modification. The method we use in this guide is inspired by the research paper: &lt;a href="https://ieeexplore.ieee.org/document/7445236">Dissecting GPU Memory Hierarchy through Microbenchmarking&lt;/a>. Here we will explain how P-Chase works and walk through a small example</description></item></channel></rss>