<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>std::bodun::blog</title><meta name=keywords content="Blog,Portfolio,Bodun,Edward,Hu"><meta name=description content="Personal Blog for Bodun Hu. Longhorn at UT Austin"><meta name=author content><link rel=canonical href=https://www.bodunhu.com/blog/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/blog/assets/css/stylesheet.min.a5e03b66b1e33e7f33d24d6965bc0a1987dd2e5edf97d3a2f7713a6ff21dcecf.css integrity="sha256-peA7ZrHjPn8z0k1pZbwKGYfdLl7fl9Oi93E6b/Idzs8=" rel="preload stylesheet" as=style><link rel=icon href=https://www.bodunhu.com/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://www.bodunhu.com/blog/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://www.bodunhu.com/blog/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://www.bodunhu.com/blog/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://www.bodunhu.com/blog/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.83.1"><link rel=alternate type=application/rss+xml href=https://www.bodunhu.com/blog/index.xml><link rel=alternate type=application/json href=https://www.bodunhu.com/blog/index.json><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)}(window,document,'script','https://www.google-analytics.com/analytics.js','ga'),ga('create','UA-108144808-1','auto'),ga('send','pageview'))</script><meta property="og:title" content="std::bodun::blog"><meta property="og:description" content="Personal Blog for Bodun Hu. Longhorn at UT Austin"><meta property="og:type" content="website"><meta property="og:url" content="https://www.bodunhu.com/blog/"><meta property="og:image" content="https://www.bodunhu.com/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="std::bodun::blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.bodunhu.com/blog/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="std::bodun::blog"><meta name=twitter:description content="Personal Blog for Bodun Hu. Longhorn at UT Austin"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"std::bodun::blog","url":"https://www.bodunhu.com/blog/","description":"Personal Blog for Bodun Hu. Longhorn at UT Austin","thumbnailUrl":"https://www.bodunhu.com/blog/%3Clink%20/%20abs%20url%3E","sameAs":["https://twitter.com/","https://stackoverflow.com","https://github.com/"]}</script><script>MathJax={tex:{inlineMath:[['$','$'],['\\(','\\)']]},svg:{fontCache:'global'}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add('dark')</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://www.bodunhu.com/blog/ accesskey=h title="std::bodun::blog (Alt + H)">std::bodun::blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://www.bodunhu.com/blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://www.bodunhu.com/blog/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://www.bodunhu.com/blog/about/ title=About><span>About</span></a></li><li><a href=https://www.bodunhu.com/blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2><a href=https://www.bodunhu.com/blog/posts/blockchain/>Blockchain</a></h2></header><footer class=entry-footer>April 19, 2021&nbsp;·&nbsp;6 min</footer><section class=entry-content><p><p>The first time I&rsquo;ve heard the term &ldquo;blockchain&rdquo; was around 2014. Since then, its popularity has grown rapidly. However, I&rsquo;ve never actually understand what blockchain is exactly, until recently. In fact, I didn&rsquo;t really understand the difference between blockchain and bitcoin. For me, blockchain is clubbed with cryptocurrencies. So here is a short summary of what blockchain is and why people use blockchain.</p><h2 id=what-is-blockchain>What is Blockchain</h2><p>I tried reading the articles about blockchain before, and it didn&rsquo;t take long before I was completely overwhelmed by technical terms: consensus, asymmetric crypto, consistency, etc. It&rsquo;s hard to combine all these little pieces together and form a big picture. Instead, it&rsquo;s much easier to understand block-chain from a top-to-bottom view. Even better, a small step-by-step example can clarify much of the confusion. I like Prof. Anand&rsquo;s example given in the class slides:</p><ul><li><p>Supposed we own a comic book store, and we want to sell comic books to some customer.</p></li><li><p>Every time we sell a book, 10 of my friends will record the action. Traditionally, we refer to such record as &lsquo;&lsquo;ledger&rsquo;&rsquo;. In the world of blockchain, we call this &lsquo;&lsquo;distributed ledger&rsquo;&rsquo;.</p></li><li><p>Once we sell enough comic books, the 10 records (ledgers) will be collected into a book, all of my friends will get a copy of the book. This is very important because we use duplication to achieve consensus.</p></li><li><p>To make things more secure, all these books are stored in a secure vault. In digital world, we achieve this though ways of encryption, digital signature, and so on. An attacker need to tamper many copies of such book to disrupt our selling records, which tends to be extremely hard in real world scenario.</p></li><li><p>Now we have this secure vault, which is effectively an immutable block. This block (vault) stores the record of we selling a comic book.
If we decide to sell more books, each one will generate an additional block (vault). Each block is appended after the previous block, forming what we call a &lsquo;&lsquo;blockchain&rsquo;&rsquo;.</p></li></ul><p>In essence, a blockchain is a series of immutable blocks, each storing the information of an event(s) whose validity is approved by a majority of other participants. Simple as that.</p><p>I like using the term &lsquo;&lsquo;distributed ledger&rsquo;&rsquo; to characterize blockchain. In Prof. Anand&rsquo;s slides, this graph summarizes how a distributed ledger differs from traditional centralized ledger:</p><p><img loading=lazy src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/blockchain/ledger.png alt></p><p>The main difference is how consensus is achieved. In centralized ledger, we have a single that decides the &lsquo;&lsquo;golden record&rsquo;&rsquo;. In a distributed ledger, consensus is achieved is everybody agrees with it. To give an example, we would pay a 45-dollar electricity bill each month to Texas electricity company because the price standard is set by the company alone. In a distributed ledger world, we might pay 32 dollars instead, if every single residents living in the building agrees this is the best price. Essentially, we eliminate the centralized entity and distribute the ability of making decisions to each individual evenly.</p><p>In super-simple terms, a blockchain is just a computer file for storing data. The reason why it&rsquo;s so secure is because there doesn&rsquo;t exist a single central point of attack for hackers to target.</p><h2 id=how-is-bitcoin-related-to-blockchain>How is Bitcoin related to Blockchain</h2><p>Now we understand what a blockchain is, it&rsquo;s time to find out how blockchain enables the development of digital currencies such as Bitcoin.
There are many great articles talking about Bitcoin in details, but I found the original <a href=https://nakamotoinstitute.org/bitcoin/>paper</a> extremely helpful in terms of understanding the motivation behind Bitcoin. In essence, Bitcoin was introduced to eliminate one problem: the need of a trusted third party to process electronic payments. More abstractly, shift from trust-based system to cryptographic-proof-based system.</p><p>Tha paper claims that trust based model suffers from a fundamental weakness: the need of mediation. The logic is simple: mediation is required in the presence of disputes. Disputes means making non-reversible transactions more difficult, thus comes the possibility of reversal. Reversal causes the need for trust to spread. To establish trust, more price needs to be paid, in the form of money, personal information, etc. Essentially, the need of trust creates a centralized component that participants must rely on. In theory, Bitcoin resorts to a cryptographic-proof based system to replace the trust-based system, with the difference being that cryptographic-proof based system is distributed in nature.</p><p>Imaging a distributed system as a fully connected graph with \(n\) nodes where each node represents a buyer/buyer. A transaction represents an edge connecting two nodes together. We denote set \(T\) as currently ongoing transactions, there could be as many as \(n(n-1)\) transactions going on concurrently, and each transaction \(t \in T\) is independent to each other. There enables 1) extremely scalability; 2) on reliance on central components. If a transaction is committed to a Bitcoin network, it suggests that the transaction has already gained approval from both the buyer and seller side (why this is the case is more technical, and you should Google how symmetric and asymmetric encryption work).</p><p>If we imaging a centralized system, where every buyer node is connected to one node \(c\). Node \(c\) in turn is connected to every seller node \(s\). Assume the centralized component, or node \(c\), has a fixed capacity limiting the amount of traffic flowing thought it in any given moment. To achieve the same level of information flow in a distributed system, we need to increase node \(c\)&rsquo;s capacity, which represents the increased costs of mediation. Assume a buyer node \(b\)&rsquo;s output value is different from a seller node \(s\)&rsquo;s input value (disputes), extra information flow will be required from seller node \(s\), creating the need for more capacity at node \(c\), thus driving the cost.</p><p>From an abstract point of view, I&rsquo;d like to imaging a normal transaction in a Bitcoin network as follows:</p><ol><li><p>Transaction is initiated</p></li><li><p>The buy, the seller, and all witnesses agree with the validity of such transaction.</p></li><li><p>With everyone satisfied as the precondition, transaction completes. If there exists a disagreement, transaction doesn&rsquo;t happen.</p></li></ol><p>On the other hand, in a centralized system, the transaction happens as follows:</p><ol><li><p>Transaction is initiated</p></li><li><p>Seller received payments, but there&rsquo;s a mismatch</p></li><li><p>Now the centralized component must be engaged to mitigate the issue.</p></li><li><p>More shit happens, the centralized component must constantly nag both the buyer and the seller until the problem is solved.</p></li></ol><p>Until I find better terms to capture my thoughts, I would put these two types of transactions into two different catagories: condition-oriented and process-oriented. Condition-oriented (Bitcoin) means we can achieve global optimum (in our case, a successful transaction) if a precondition is met (consensus). Process-oriented (Centralized) means, instead of agreeing on a precondition, we achieve global optimum through constant trial and error, which comes at a cost of disputes.</p><p>In short, I think trust is not &lsquo;&lsquo;removed&rsquo;&rsquo;, it is merely achieved through a different way. I&rsquo;d like to modify Prof. Anand&rsquo;s summary on Bitcoin: Bitcoin is an engineering solution to solve trust issues.</p></p></section></article><article class=post-entry><header class=entry-header><h2><a href=https://www.bodunhu.com/blog/posts/hoarelogic/>Hoare Logic</a></h2></header><footer class=entry-footer>April 17, 2021&nbsp;·&nbsp;12 min</footer><section class=entry-content><p><p>Hoare logic forms the basis of all deductive verification. To illustrate Hoare logic, we will first consider a smaller imperative programming
language <strong>IMP</strong>.</p><p>In IMP, we have three program constructs: expressions, conditionals, and statements:</p><ul><li><p>Expression takes the form \( E := Z\ |\ V\ |\ e_1 + e_2\ |\ e_1 \times e_2 \)</p></li><li><p>Conditional is self-explanatory: \( C := true\ |\ false\ |\ e_1 = e_2\ |\ e_1 \leq e_2 \)</p></li><li><p>Statement consists of several different forms:</p><ul><li>\(S := V := E\) (Assignment)</li><li>\(S_1; S_2\) (Composition)</li><li>if \(C\) then \(S_1\) else \(S_2\) (If)</li><li>while \(C\) do \(S\) (While)</li></ul></li></ul><h2 id=hoare-triple>Hoare Triple</h2><p>In Hoare logic, we specify partial correctness of programs using Hoare triples:</p><p>\[\{P\} S \{Q\}\]</p><p>Here \(P\) is the precondition and \(Q\) is the post-condition. $S$ is a statement in IMP.</p><p>The interpretation of Hoare triple is as follows:</p><ol><li><p>if \(S\) is executed in a state satisfying \(P\)</p></li><li><p>and if execution of \(S\) terminates</p></li><li><p>then the program state after \(S\) terminates satisfies \(Q\)</p></li></ol><p>Here an example, \(\{x = 0 \} while\ true\ do\ x := 0\ \{x = 1 \}\) is a valid Hoare triple because the execution of the statement never terminates, thus satisfying the requirement posed by Hoare triple.</p><p>Thus the specification \(\{P\} S \{Q\}\) is called <em>partial</em> correctness spec, because it doesn&rsquo;t require \(S\) to terminate.</p><p>There is also a stronger requirement called <em>total</em> correctness. The total correctness specification is written as:</p><p>\[ [P] S [Q]\]</p><p>Total correctness requires that if \(P\) is satisfied when executing \(S\), then \(S\) must terminate, and the post-conditional \(Q\) must be satisfied after \(S\) terminates.</p><p>Thus the example \(\{x = 0 \} while\ true\ do\ x := 0\ \{x = 1 \}\) is no longer valid because it never terminates.</p><p>In summary, we can say that Total correctness \(=\) Partial correctness \(+\) termination.</p><h2 id=proving-partial-correctness>Proving Partial Correctness</h2><p>We use \(\vDash \{P\} S \{Q\} \) to say a Hoare triple is valid and we use \(\vdash \{P\} S \{Q\} \) to indicate we can prove validity of a Hoare triple.</p><p>Let&rsquo;s say we are given an assignment \(x := y \) with post-condition \(x > 2\). The question is, what do we need to know before the assignment happens so that the post-condition, \(x > 2\), holds afterwards?</p><p>To prove \(Q\) holds after the assignment \(x := E\), we need to show that <strong>\(Q\) with \(E\) substituting \(x\) holds before the assignment</strong>. Formally, we write it as:</p><p>\[\vdash \{Q[E / x]\}\ x := E \{Q\}\]</p><p>For example, given \( \{ x+1 = n\}\ x := x+1 \ \{x=n\} \), we know this formula is provable because we can take \(Q\), which is \(\{x=n\}\), substituting \(x\) with \(x+1\) given we need to replace it with \(E\), and we will convert \(x=n\) to \(x+1 = n\), which matches the precondition.</p><p>Here is another interesting example, given \( \{z = 2\}y:= x \{y = x\} \), this Hoare triple is valid but not provable. If we use the above substitution procedure, it will result in the precondition being \(x=x\) which is always true but is also different from the original precondition \(z=2\).</p><p>Intuitively, we can prove the post-condition \(y = x\) given the statement \(y = x\) without any assumptions, so even if we do have assumptions like \(z=2\), we should still be able to prove it, and here comes proof rule for precondition strengthening.</p><h2 id=proof-rule-for-precondition-strengthening>Proof Rule for Precondition Strengthening</h2><p>Formally, we define precondition strengthening as:</p><p>\[ \frac{ \vDash \{P'\} S \{Q\}\ \ P \Rightarrow P' }{\vdash \{P\} S \{Q\}} \]</p><p>Now, with the original formula \( \{z = 2\}y:= x \{y = x\} \), we would derive \( x= x \equiv true \). and since \(z=2 \rightarrow true\) is valid, we can now prove the formula!</p><h2 id=a-dual-post-condition-weakening>A Dual: Post-Condition Weakening</h2><p>Formally, we define post-condition weakening as:</p><p>\[ \frac{ \vDash \{P\} S \{Q'\}\ \ Q' \Rightarrow Q }{\vdash \{P\} S \{Q\}} \]</p><p>What this means if that if we can prove a post-condition \(Q'\), we can always relax it to something <strong>weaker</strong>.</p><p>For example, given that \(\vdash \{true\}S\{x=y \land z=2\}\), we can prove \(\{true\}S\{x=y\}\) because \(x=y\) is a weaker condition of \( x=y \land z=2 \).</p><h2 id=proof-rule-for-composition>Proof Rule for Composition</h2><p>For composition, we define the rule as:</p><p>\[ \frac{ \vdash \{P\}S_1\{Q\}\ \ \vdash \{Q\}S_2 \{R\} }{ \vdash \{P\}S_1;S_2\{R\} }\]</p><p>I won&rsquo;t show why this is true, so this will be left as an exercise.</p><h2 id=proof-rule-for-if-statements>Proof Rule for If Statements</h2><p>Naturally, we define the rule for if statement as:</p><p>\[ \frac{_{ \vdash \{P \land C\} S_1 \{Q\} }^{ \vdash \{P \land \neg C\} S_2 \{Q\} }}{ \vdash \{P\}\ if\ C\ then\ S_1\ else \ S_2 \ \{Q\} } \]</p><p>In summary, this means given we know \(P\) is true, no matter what \(C\) evaluates to, we will come to the same post-condition \(Q\). If you still don&rsquo;t understand it, just stare at it for five minutes and you should figure out why this is the case:)</p><h2 id=proof-rule-for-while>Proof Rule for While</h2><p>To understand the proof rule for while statement, we need to first understand a simple concept: loop invariant</p><h3 id=loop-invariant>Loop Invariant</h3><p>Loop invariant \(I\) has two properties:</p><ol><li><p>\(I\) holds initially before the loop</p></li><li><p>\(I\) holds after each loop iteration</p></li></ol><p>For example, given a loop</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text>i := 0;
j := 0;
n := 0;
while i &lt; n do
    i := i + 1;
    j := i + j
</code></pre></div><p>Here, \(i \leq n \) is a loop invariant but \(i &lt; n \) isn&rsquo;t.</p><p>Now, we put the properties of loop invariant \(I\) in formal terms. Given that the precondition before a loop executes is \(C\), by definition, \(I\) holds initially before the loop, we know \(I \land C\) holds.</p><p>For the second property of loop invariant, it specifies \(I\) holds after each loop iteration. So that means \(\{ I \land C\ \} S \{I\} \) holds. Formally, we express loop invariant as \( \vdash \{P \land C\} S \{P\} \).</p><p>Now, we know if a loop terminates, it must be that condition \(C\) no longer holds, meaning \( P \land \neg C \) must be true after loop terminates. This is because \(P\) is a loop invariant and always holds after each loop iteration, including termination.</p><p>Putting all this together, we form the proof rule for while loop:</p><p>\[ \frac{ \vdash \{P \land C\} S \{P\} }{ \vdash \{P\} while \ C \ do \ S\{P \land \neg C\} }\]</p><h3 id=inductive-loop-invariant>Inductive Loop Invariant</h3><p>It&rsquo;s not always the case that we can prove loop invariant is valid. Here is a counter example:</p><p>Consider precondition \( I = j \geq 1 \) and the code is:</p><p>\[i := 1; j := 1; while \ i &lt; n\ do\ \{j := j+i; i ;= i + 1\}\]</p><p>We know that the precondition is \(I = j \geq 1\) and \(C\) (loop condition) is \(i \leq n\). So we have a Hoare triple:</p><p>\[ \{ j \geq 1 \land i \leq n \} j =j + i;\ i = i + 1; \ \{j \geq 1\} \]</p><p>We could simply set \(i = -100\), then if we execute the code once we will not be sure if the post-condition \(j \geq 1\) holds.</p><p>However, if we have <strong>strengthened invariant</strong> such as \(j \geq 1 \land i \geq 1\), the new Hoare triple will be valid. Then \(I\) will become inductive invariant because we can prove these invariant.</p><p>To put everything in action, here is an example showing how to find inductive loop invariant to prove the following Hoare triple:</p><p>\[ \{i = o \land j = o \land n = 5\} \]
\[while\ i &lt; do\ i := i + 1; \ j := j + i; \]
\[\{j = 15\} \]</p><p>If we have \( j = \frac{i(i+1)}{2} \), this is a loop invariant because we can prove that:</p><p>\[\{j = \frac{i(i+1)}{2} \land i &lt; n\} i = i + 1;\ j = j+ i\ \{j = \frac{i(i+1)}{2}\} \]</p><p>If we conjoin this condition with \(i \geq n\) as the post-condition, however, we can&rsquo;t really show that \(j = 15\) is true for the given Hoare triple.</p><p>If we also add condition \(n = 5\) and \(i \leq n\), and we conjoin this with the end-loop condition \( i \geq n\), we would realize that \( i = n = 5\), and thus prove that \(j = 15\) for the given Hoare triple.</p><p>How we get \(j = \frac{i(i+1)}{2}\) is, however, not trivial to solve, and requires some human effort in program verification.</p><h2 id=basic-idea-behind-program-verification>Basic Idea behind Program Verification</h2><h3 id=automating-reasoning-in-hoare-logic>Automating Reasoning in Hoare Logic</h3><p>It&rsquo;s reasonable to automate the tedious parts of program verification: proving correctness. The basic idea to assume an oracle (human or another program) gives loop invariants but automate the rest of the reasoning.</p><p>Automating Hoare logic is based on generating verification conditions (VC). Essentially, a verification condition is formula \(\phi\) s.t. program is correct iff \(\phi\) is valid.</p><p>There are two way to generate verification conditions: forwards and backwards.</p><p>As their name suggests, a forwards analysis starts from precondition and generates formulas to prove post-condition. Forwards technique computes <strong>strongest post-conditions (sp)</strong>. In contrast, backwards analysis starts from post-condition and tries to prove precondition. Backwards technique computes <strong>weakest preconditions (wp)</strong>.</p><p>Here, we start from backwards method.</p><h3 id=weakest-preconditions>Weakest Preconditions</h3><p>Formally, we define the weakest precondition of \(Q\) with respect to \(S\) as \(wp(S, Q)\).</p><p>\(wp(S, Q)\) has the property that it is the weakest condition (least amount of information we need to have) that guarantees \(Q\) holds after \(S\) in any execution.</p><p>Thus, Hoare triple \( \{P\}S\{Q\} \) is valid iff \( P\Rightarrow wp(S, Q) \).</p><p>Weakest preconditions are defined inductively and follow Hoare&rsquo;s proof rules:</p><ul><li><p>\(wp(x := E, Q) = Q[E/x]\)</p></li><li><p>\( wp(s_1 ; s_2, Q) = wp(s_1, wp(s_2, Q) ) \)</p></li><li><p>\(wp(if \ C\ then \ s_1\ else \ s_2, Q) =C \rightarrow wp(s_1, Q) \land \neg C \rightarrow wp(s_2, Q) \)</p></li></ul><p>However, for loops, we might not be able to compute the weakest preconditions exactly because there might be cases where we simply don&rsquo;t know the number loops executed.</p><p>Thus, we relax our requirement by computing \(awp(S,Q)\) (\(a\) stands for approximate)) instead, hoping that \(awp(S, Q)\) is weak enough to be implied by \(P\) although it may not be the weakest.</p><p>Now, assume all loops are annotated with invariants \(while \ C \ do \ [I]\ S\), we will just define \(awp(while \ C \ do \ [I]\ S, Q) \equiv I\).</p><p>However, there is another program, since \(awp\) is only an approximated condition, it doesn&rsquo;t necessarily mean that if \(P \Rightarrow awp(S, Q)\), \( \{P\}S\{Q\} \) is valid. There are two reasons:</p><ol><li><p>We don&rsquo;t know if the loop invariant \(I\) provided by the oracle is correct since it might be provided by human and we know human make mistakes.</p></li><li><p>Even if \(I\) is correct, we don&rsquo;t if \(I \land \neg C\) is sufficient to establish \(Q\)!</p></li></ol><p>Thus, for each statement \(S\), we need to generate verification condition (VC) \( VC(S,Q) \) which encodes additional conditions to prove.</p><h3 id=verification-conditions>Verification Conditions</h3><p>So how do formulate VC generation rules for loops?</p><p>\[ VC(while\ C\ do\ [I]\ S,Q) = ?\]</p><p>First, we need to ensure that \(Q\) is satisfied after loop, which means \( I \land \neg C \Rightarrow Q \).</p><p>To show that \(I\) is actually correct, we also need \( \{I \land C\} S \{I\} \).</p><p>This implies that we need to show \( I \land C \Rightarrow awp(S, I) \). In case \(S\) contains nested loops, and also add \(VC(S, I)\)</p><p>In summary, to how that loop invariant \(I\) provided by the oracle is correct, we need to show \( I \land C \Rightarrow awp(S,I) \land VC(S, I) \).</p><p>To show \(I\) is strong enough to establish \(Q\), we need to show \( I \land \neg C \Rightarrow Q \).</p><p>Putting this together, and to answer the two reason why \(P \Rightarrow awp(S, Q)\), \( \{P\}S\{Q\} \) might not be valid, VC for a while loop \( S' = while \ C \ do \ \{I\} \) is expressed as:</p><p>\[ VC(S', Q) = (I \land C \Rightarrow awp(S, I) \land VC(S, I) ) \land (I \land \neg C \Rightarrow Q) \]</p><p>In essence, verification condition simply stands for additional checks we need to verify before we can claim that, if an approximated precondition \(P\) is valid, \( \{P\} S \{Q\} \).</p><p>The verification condition for other statements is as follows:</p><ol><li><p>For assignment, we don&rsquo;t need any additional checks for precondition because if \( P \Rightarrow wp(S, Q) \), it implies that \( \{P\} S \{Q\} \) is valid. Thus, \( VC(x:= E, Q) = true \).</p></li><li><p>For composition, we have \( VC(s_1 ; s_2, Q) = VC(s_2, Q) \land VC(s_1, awp(s_2 , Q)) \).</p></li><li><p>For if statement, we have \( VC(if \ C \ then \ s_1\ else \ s_2, Q) = VC(s_1, Q) \land VC(s_2, Q) \).</p></li></ol><blockquote><p>Quick question: for if statement, why don&rsquo;t we instead use verification condition generation rule: \( C \Rightarrow VC(s_1, Q) \land \neg C \Rightarrow VC(s_2, Q) \)?</p></blockquote><p>Here is a counter example. Suppose we have \( S = if\ (x > 0) \ while (*) x - -; else \ skip\), and we have given loop invariant \(x \geq 0\).</p><p>If we use the original rule \( VC(s_1, Q) \land VC(s_2, Q) \), according to the verification condition generation rule for while loop, we would have to verify the loop invariant \(I\) is correct, and thus \(VC(S, I) \equiv \{ x \geq 0 \} x - - \{ x \geq 0 \} \), obviously, this not true, and we can use this VC.</p><p>However, if we instead use the rule \( C \Rightarrow VC(s_1, Q) \land \neg C \Rightarrow VC(s_2, Q) \). The VC would become \( x > 0 \Rightarrow (\{ x \geq 0 \} x - - \{ x \geq 0 \}) \), which is valid, and we will include the wrong VC. Thus we can&rsquo;t use this VC generation rule.</p><h2 id=verification-of-hoare-triple>Verification of Hoare Triple</h2><p>Thus, to show validity of Hoare triple \( \{P\} S \{ Q \} \), we need to compute:</p><ol><li><p>\( awp(S, Q) \)</p></li><li><p>\( VC(S, Q) \)</p></li></ol><p>Therefore, a Hoare triple is valid if the follow formula holds:</p><p>\begin{equation}\tag{*}
VC(S, Q) \land P \rightarrow awp(S, Q)
\end{equation}</p><p>Thus, if we can prove the validity of the above equation *, we know the program obeys specification.</p></p></section></article><article class=post-entry><header class=entry-header><h2><a href=https://www.bodunhu.com/blog/posts/congruence_closure/>Congruence Closure</a></h2></header><footer class=entry-footer>March 27, 2021&nbsp;·&nbsp;4 min</footer><section class=entry-content><p><p>This is a summary of how to compute congruence closure. I implemented the algorithm to compute congruence closure and thought I&rsquo;d never forget it. But my memory starts to get blurry just after two days. So I figured I&rsquo;d put things down so I don&rsquo;t have to watch the entire lecture again the next time I need it.</p><h2 id=equivalence-relation>Equivalence Relation</h2><p>Equivalence relation has three properties: reflexive, symmetric, and transitive.
(E.g. \(\geq\) is not an equivalence relation because it break the symmetric property. $4 \geq 6$ does not imply that $6 \geq 4$)
For example, a binary relation $R$ over a set $S$ meeting these three properties can be expressed as:</p><ul><li>Reflexive: $\forall s \in S.\ sRs$</li><li>Symmetric : $\forall s_1, s_2 \in S.\ s_1 R s_2 \rightarrow s_2 R s_1$</li><li>Transitive: $\forall s_1, s_2, s_3 \in S.\ s_1 R s_2 \land s_2 R s_3 \rightarrow s_1 Rs_3$</li></ul><h2 id=congruence-relation>Congruence Relation</h2><p>Given a set $S$ equipped with functions $F = {f_1, &mldr;, f_n}$, a relation $R$ over $S$ is a congruence relation if $R$ is an equivalence relation and for every $n$&lsquo;ary function $f \in F$ we have:</p><p>\[\forall \overset{\rightarrow}{s}, \overset{\rightarrow}{t}.\ \bigwedge\limits_{i=1}^{n}s_i R t_i \rightarrow f(\overset{\rightarrow}{s}) R f(\overset{\rightarrow}{t})\]</p><p>A counter example would be given $R(x, y)$ defined as $|x| = |y|$ on all integers. If we have $R = {2, 2}$ and $f(x) = x + 1$ (successor function), then we know it violates the equivalence relation we mentioned above</p><h2 id=equivalence-closure>Equivalence Closure</h2><p>In short, the equivalence closure $R^E$ is the smallest equivalence relation that includes $R$.
This is illustrated through an example. Given a set $S = {a, b, c}$ and binary relation $R:{\langle a, b \rangle , \langle b, c \rangle, \langle d, d \rangle}$, $R^E$ would contain all elements extended from $R$ based on the three properties of equivalence relation.</p><h2 id=congruence-closure>Congruence Closure</h2><p>Naturally, congruence closure $R^C$ would be the smallest set that contains congruence relation $R$. What this means is $R^C$ contains $R^E$ (the equivlance closure we derived before), and any element generated from $R^E$ by a given function that produces element which also satisfies equivelance relation. For example, Given $S = {a, b, c}$ and function $f$ such that $f(a) = b$, $f(b) = c$, $f(c) = c$, the congruence closure would contain nine elments in total. First, we
would use the procedure above to generated equivalence closure. Then, because $f(a) = b$ and $f(b) = c$ due to congruence relation, we know $b = c$, now we apply the procure for generating equivalence closure again.</p><h2 id=algorithm-to-compute-congruence-closure>Algorithm to Compute Congruence Closure</h2><p>The high-level description of the algorithm is as following:</p><p>To decide satisfiability of $T_{=}$ (equality theory) formula:</p><p>\[F\ : \ s_1 = t_1 \land &mldr; s_m = t_m \land s_{m+1} \neq t_{m+1} \land &mldr; s_n \neq t_n\]</p><ol><li>Compute subterms and construct initial DAG (each node’s representative is itself)</li><li>For each $i \in [1,m]$, process equality $s_i= t_i$ as described. (Essentially, process all equiv expression first)</li><li>For each $i \in [m + 1,n]$, check if $Rep(s_i) =Rep(t_i)$. (Check if any nequiv expression contradicts any equiv expression)</li><li>If there exists some $i \in [m + 1, n]$, for which $Rep(s_i) =Rep(t_i)$, return UNSAT</li><li>if for all $i$, $Rep(s_i) \neq Rep(t_i)$, return SAT</li></ol><p>This is an example for illustration purpose borrowed from Prof. Dillig&rsquo;s slides:</p><p>Given formula $F\ : \ f^3(a) = a \land f^5(a) = a \land f(a) \neq a$</p><p>The initial DAG would be:</p><p align=center><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/congruence_algorithm/DAG.png></p><p>Process equality $f^3(a) = a$ gives us:</p><p align=center><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/congruence_algorithm/DAG_1.png></p><p>Recursively merging the parents results in:</p><p align=center><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/congruence_algorithm/DAG_2.png></p><p>Process equality $f^5(a) = a$ gives us:</p><p align=center><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/congruence_algorithm/DAG_3.png></p><p>Now in this step, $f^2(a)$ and $a$ are in the same congruence class, thus we will perform the same operation on their parents, processing equality $f^3(a) = f(a)$:</p><p align=center><img src=https://raw.githubusercontent.com/BDHU/Page_pics/master/posts/congruence_algorithm/DAG_5.png></p><p>We find $f(a) \neq a$ has a conflict because node $a$&rsquo;s representative is $f(a)$, indicating they are in the same congruence class, meeting congruence relation.
Thus the formula is UNSAT.</p></p></section></article><article class=post-entry><header class=entry-header><h2><a href=https://www.bodunhu.com/blog/posts/programloadingandmemorymappinginlinux/>Program Loading and Memory Mapping in Linux</a></h2></header><footer class=entry-footer>November 3, 2020&nbsp;·&nbsp;5 min</footer><section class=entry-content><p><p>The goal here is to familiarize yourself with how programs are loaded, dynamically paged, and some of the mechanics of signal handling and memory mapping in Linux.</p><h2 id=execve-syscall>execve Syscall</h2><p>The operating system, as one of itsd basic services, loads programs into memory for them to execute. Programs rely on <code>execve</code> syscall to get the OS to load the program into memory and start it executing as a process. The kernel version we used to testing is 5.4.0. Doing a quick search inside <a href=https://elixir.bootlin.com/linux/v5.4/source/fs/exec.c#L1956>Elixir</a> gives us:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>SYSCALL_DEFINE3(execve,
		<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> __user <span style=color:#f92672>*</span>, filename,
		<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> __user <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> __user <span style=color:#f92672>*</span>, argv,
		<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> __user <span style=color:#f92672>*</span><span style=color:#66d9ef>const</span> __user <span style=color:#f92672>*</span>, envp)
{
	<span style=color:#66d9ef>return</span> do_execve(getname(filename), argv, envp);
}
</code></pre></div><p>Follow the function call, we will eventually reach the call to <code>__do_execve_file</code>, the comment of this function says &ldquo;sys_execve() executes a new program&rdquo;, which is pretty straighforward. This function first checks the <code>filename</code> pointer. Then it checks the flags of the current process that limit of running processes is not exceeded:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>if</span> (IS_ERR(filename))
		<span style=color:#66d9ef>return</span> PTR_ERR(filename);

<span style=color:#75715e>/*
</span><span style=color:#75715e> * We move the actual failure in case of RLIMIT_NPROC excess from
</span><span style=color:#75715e> * set*uid() to execve() because too many poorly written programs
</span><span style=color:#75715e> * don&#39;t check setuid() return code.  Here we additionally recheck
</span><span style=color:#75715e> * whether NPROC limit is still exceeded.
</span><span style=color:#75715e> */</span>
<span style=color:#66d9ef>if</span> ((current<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;</span> PF_NPROC_EXCEEDED) <span style=color:#f92672>&amp;&amp;</span>
    atomic_read(<span style=color:#f92672>&amp;</span>current_user()<span style=color:#f92672>-&gt;</span>processes) <span style=color:#f92672>&gt;</span> rlimit(RLIMIT_NPROC)) {
    retval <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>EAGAIN;
    <span style=color:#66d9ef>goto</span> out_ret;
}

<span style=color:#75715e>/* We&#39;re below the limit (still or again), so we don&#39;t want to make
</span><span style=color:#75715e>    * further execve() calls fail. */</span>
current<span style=color:#f92672>-&gt;</span>flags <span style=color:#f92672>&amp;=</span> <span style=color:#f92672>~</span>PF_NPROC_EXCEEDED;
</code></pre></div><p>The next important task is to allocate the <code>struct linux_binprm</code> structure defined <a href=https://elixir.bootlin.com/linux/v5.4/source/include/linux/binfmts.h#L17>here</a>. This structure is used to hold the arguments that are used when loading binaries.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>bprm <span style=color:#f92672>=</span> kzalloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#f92672>*</span>bprm), GFP_KERNEL);
	<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>bprm)
		<span style=color:#66d9ef>goto</span> out_files;
</code></pre></div><p>Next, the function performs a seireis of tasks to prepare the <code>bprm</code> struct. Refer to the <a href=https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-4.html>linux-insides</a> book to find more information on how exactly the <code>bprm</code> structure is filled up.</p><p>The most important function called by <code>__do_execve_file</code> is <code>search_binary_handler</code>. Based on the <a href=https://elixir.bootlin.com/linux/v5.4/source/fs/exec.c>comment</a>, this function cycles the list of binary formats handler, until one recognizes the image. We can find one section of the code surrounded by <code>binfmt_lock</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>list_for_each_entry(fmt, <span style=color:#f92672>&amp;</span>formats, lh) {
    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>try_module_get(fmt<span style=color:#f92672>-&gt;</span>module))
        <span style=color:#66d9ef>continue</span>;
    read_unlock(<span style=color:#f92672>&amp;</span>binfmt_lock);

    bprm<span style=color:#f92672>-&gt;</span>recursion_depth<span style=color:#f92672>++</span>;
    retval <span style=color:#f92672>=</span> fmt<span style=color:#f92672>-&gt;</span>load_binary(bprm);
    bprm<span style=color:#f92672>-&gt;</span>recursion_depth<span style=color:#f92672>--</span>;

    read_lock(<span style=color:#f92672>&amp;</span>binfmt_lock);
    put_binfmt(fmt);
    <span style=color:#66d9ef>if</span> (retval <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>bprm<span style=color:#f92672>-&gt;</span>mm) {
        <span style=color:#75715e>/* we got to flush_old_exec() and failed after it */</span>
        read_unlock(<span style=color:#f92672>&amp;</span>binfmt_lock);
        force_sigsegv(SIGSEGV);
        <span style=color:#66d9ef>return</span> retval;
    }
    <span style=color:#66d9ef>if</span> (retval <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span>ENOEXEC <span style=color:#f92672>||</span> <span style=color:#f92672>!</span>bprm<span style=color:#f92672>-&gt;</span>file) {
        read_unlock(<span style=color:#f92672>&amp;</span>binfmt_lock);
        <span style=color:#66d9ef>return</span> retval;
    }
}
</code></pre></div><p>We can see it calls into <code>load_binary</code>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>retval <span style=color:#f92672>=</span> fmt<span style=color:#f92672>-&gt;</span>load_binary(bprm);
</code></pre></div><p>Here, the <code>load_binary</code> is a pointer in a <code>linux_binfmt</code> struct. For elf format, it can be found <a href=https://elixir.bootlin.com/linux/v5.4/source/fs/binfmt_elf.c#L94>here</a>:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>struct</span> linux_binfmt elf_format <span style=color:#f92672>=</span> {
	.module		<span style=color:#f92672>=</span> THIS_MODULE,
	.load_binary	<span style=color:#f92672>=</span> load_elf_binary,
	.load_shlib	<span style=color:#f92672>=</span> load_elf_library,
	.core_dump	<span style=color:#f92672>=</span> elf_core_dump,
	.min_coredump	<span style=color:#f92672>=</span> ELF_EXEC_PAGESIZE,
};
</code></pre></div><p>We can find the <code>load_elf_binary</code> function defined in the <a href=https://elixir.bootlin.com/linux/v5.4/source/fs/binfmt_elf.c#L673><code>fs/binfmt_elf.c</code></a> file. Then the function will check the magic number in the ELF file header. You can find the ELF format from <a href=https://en.wikipedia.org/wiki/Executable_and_Linkable_Format>wiki</a>.
We can see for both 32-bit and 64-bit systems, the e-ident field should contain the magic number for ELF format files.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* Get the exec-header */</span>
loc<span style=color:#f92672>-&gt;</span>elf_ex <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>((<span style=color:#66d9ef>struct</span> elfhdr <span style=color:#f92672>*</span>)bprm<span style=color:#f92672>-&gt;</span>buf);

retval <span style=color:#f92672>=</span> <span style=color:#f92672>-</span>ENOEXEC;
<span style=color:#75715e>/* First of all, some simple consistency checks */</span>
<span style=color:#66d9ef>if</span> (memcmp(loc<span style=color:#f92672>-&gt;</span>elf_ex.e_ident, ELFMAG, SELFMAG) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>)
    <span style=color:#66d9ef>goto</span> out;
</code></pre></div><p>Then, <code>load_elf_binary</code> will do some tasks to prepare for the executable file. After that, it will try to load the program header table:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>elf_phdata <span style=color:#f92672>=</span> load_elf_phdrs(<span style=color:#f92672>&amp;</span>loc<span style=color:#f92672>-&gt;</span>elf_ex, bprm<span style=color:#f92672>-&gt;</span>file);
<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>elf_phdata)
    <span style=color:#66d9ef>goto</span> out;
</code></pre></div><p>Then it will traverse the program header table and find the interpreter which is responsible of setting up the stack and map elf binary into the correct location in memory. After the interpreter is obtained, the function will perform simple consistency checks on the interpreter. It will load the interpreter program headers:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* Load the interpreter program headers */</span>
interp_elf_phdata <span style=color:#f92672>=</span> load_elf_phdrs(<span style=color:#f92672>&amp;</span>loc<span style=color:#f92672>-&gt;</span>interp_elf_ex,
                    interpreter);
<span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>interp_elf_phdata)
    <span style=color:#66d9ef>goto</span> out_free_dentry;
</code></pre></div><p>This function will call <code>setup_arg_pages</code> to finalize the stack vm_area_struct:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* Do this so that we can load the interpreter, if need be.  We will
</span><span style=color:#75715e>    change some of these later */</span>
retval <span style=color:#f92672>=</span> setup_arg_pages(bprm, randomize_stack_top(STACK_TOP),
                executable_stack);
<span style=color:#66d9ef>if</span> (retval <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
    <span style=color:#66d9ef>goto</span> out_free_dentry;
</code></pre></div><p>It will also mmap the elf image into the correct location in memory. The bss and brk sections are prepared for the executable file:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#75715e>/* Now we do a little grungy work by mmapping the ELF image into
</span><span style=color:#75715e>    the correct location in memory. */</span>
<span style=color:#66d9ef>for</span>(i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, elf_ppnt <span style=color:#f92672>=</span> elf_phdata;
    i <span style=color:#f92672>&lt;</span> loc<span style=color:#f92672>-&gt;</span>elf_ex.e_phnum; i<span style=color:#f92672>++</span>, elf_ppnt<span style=color:#f92672>++</span>) {
        
        ...

        <span style=color:#75715e>/* There was a PT_LOAD segment with p_memsz &gt; p_filesz
</span><span style=color:#75715e>           before this one. Map anonymous pages, if needed,
</span><span style=color:#75715e>           and clear the area.  */</span>
        retval <span style=color:#f92672>=</span> set_brk(elf_bss <span style=color:#f92672>+</span> load_bias,
                    elf_brk <span style=color:#f92672>+</span> load_bias,
                    bss_prot);
        <span style=color:#66d9ef>if</span> (retval)
            <span style=color:#66d9ef>goto</span> out_free_dentry;
        nbyte <span style=color:#f92672>=</span> ELF_PAGEOFFSET(elf_bss);
        <span style=color:#66d9ef>if</span> (nbyte) {
            nbyte <span style=color:#f92672>=</span> ELF_MIN_ALIGN <span style=color:#f92672>-</span> nbyte;
            <span style=color:#66d9ef>if</span> (nbyte <span style=color:#f92672>&gt;</span> elf_brk <span style=color:#f92672>-</span> elf_bss)
                nbyte <span style=color:#f92672>=</span> elf_brk <span style=color:#f92672>-</span> elf_bss;
            <span style=color:#66d9ef>if</span> (clear_user((<span style=color:#66d9ef>void</span> __user <span style=color:#f92672>*</span>)elf_bss <span style=color:#f92672>+</span>
                        load_bias, nbyte)) {
            }
</code></pre></div><p>It will also call <code>elf_map</code> to map the segment to [vaddr, vaddr + file size] and align and then perform some checks:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>error <span style=color:#f92672>=</span> elf_map(bprm<span style=color:#f92672>-&gt;</span>file, load_bias <span style=color:#f92672>+</span> vaddr, elf_ppnt,
				elf_prot, elf_flags, total_size);
</code></pre></div><p>The interpreter is then loaded:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>elf_entry <span style=color:#f92672>=</span> load_elf_interp(<span style=color:#f92672>&amp;</span>loc<span style=color:#f92672>-&gt;</span>interp_elf_ex,
                interpreter,
                <span style=color:#f92672>&amp;</span>interp_map_addr,
                load_bias, interp_elf_phdata);
</code></pre></div><p>Finally, the elf talbe is created:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>retval <span style=color:#f92672>=</span> create_elf_tables(bprm, <span style=color:#f92672>&amp;</span>loc<span style=color:#f92672>-&gt;</span>elf_ex,
            load_addr, interp_load_addr);
</code></pre></div><p>After everything is prepared, we can call the <code>start_thread</code> function, which prepares the new task&rsquo;s registers and segments for execution. We will pass the set of registers for the new task, the address of the entry point of the new task, and the address of the top of of the statck for the new task to this function.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>start_thread(regs, elf_entry, bprm<span style=color:#f92672>-&gt;</span>p);
</code></pre></div><p>A lot of the information here can also be found at the <a href=https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-4.html>linux-insides</a> book. I found it very helpful clearing my confusion.</p><p>In our own implementations, we will not call the loaded program&rsquo;s <code>main</code> function. Instead, our loader will transfer control to the entry point of the loaded program via the <code>jmp</code> instruction. It has two major differences:</p><ul><li>Jumping to the entry point indicates we are going to execute the glibc start up functions before main is called. This includes setting up thread local storge. <code>main</code> simply jump to the main with the loader&rsquo;s TLS, no other setups are involved.</li><li><code>jmp</code> doesn&rsquo;t push return address on stack. When the loaded prgoram finishes execution, it exits the loader program, instead of giving cntrol back to the caller.</li></ul></p></section></article><article class=post-entry><header class=entry-header><h2><a href=https://www.bodunhu.com/blog/posts/scheduleractivation/>Scheduler Activation</a></h2></header><footer class=entry-footer>October 24, 2020&nbsp;·&nbsp;4 min</footer><section class=entry-content><p><p>What is a thread? A thread of execution is the smallest sequence of programmed instructions that can be managed independently by a scheduler.</p><h2 id=kernel-level-threads-proscons>Kernel Level Threads Pros/Cons</h2><ul><li>Good functionality, system wide integration</li><li>Threads are seen and scheduled only by the kernel. A lot of kernel information should be invisible to user thread and can be useful for scheduling</li><li>Poor performance, every thread_related call traps. This situation is a lot worse in the 1990s than it is now mainly due to clock speed.
The scheduling quanta are roughly the same, but because the clock speeds are much faster today, you can execute orders of magnitude more instructions
per quanta today than you could in 1990. Even if traps, let&rsquo;s say, costs 10 cycles to complete, it would be a much bigger fraction of the quanta in 1990 than
it is today.</li></ul><h2 id=user-level-threads-proscons>User Level Threads Pros/Cons</h2><ul><li>Good performances. (most threads operations don&rsquo;t involve kernel)</li><li>Good scheduling policy flexibility: done by thread lib</li><li>Poor system-wide integration</li><li>Multi-programmed workloads are hard to schedule</li><li>I/O, page faults invisible</li><li>Potetntial for incorrect behavior<ul><li>User level scheduler may not be cooperative. With user threads running on kernel threads, it may be that kernel threads block when a user-thread blocks, thus an application can run out of kernel threads to run their user threads.May be gilding the lily.</li></ul></li></ul><h2 id=some-problems-about-user-level-threads-on-kernel-interface>Some Problems about User-Level Threads on Kernel Interface</h2><ul><li>Insufficient visibility between the kernel and user thread lib</li><li>Kernel event such as pr-emption or I/O are not visible to user lib<ul><li>For example, if user level threads block, then the kernel thread serving it also blocks.</li></ul></li><li>Kernel threads are scheduled with respect to user-level thread library, we can have this interferences between two schedulers.</li><li>Kernel time-slicing of threads<ul><li>For example, user level threads holding a spin-lock can be pre-empted, which can potentially cause all other user threads to wait.</li></ul></li></ul><h2 id=scheduler-activation>Scheduler Activation</h2><p>The basic principle about scheduler actication is to expose revocation: telling me when you take something away. This is basically the same idea as the exokernel. For example, interfaces like</p><ul><li>add_processor()</li><li>has_blocked()</li></ul><p>The basics about scheudler activation are</p><ul><li>Multi-threaded programs are still given an address space</li><li>Facilitate flow of kernel information between user and kernel threads</li><li>Kernel explicily vectors kernel events to the user-level thread<ul><li>via scheduler activation (upcall)</li></ul></li><li>Extended kernel interface for processor allcoation-related events<ul><li>Essentially exchanging information</li></ul></li></ul><h2 id=scheduler-activation-vs-kernel-threads>Scheduler Activation vs Kernel Threads</h2><p>Key differences:</p><ul><li>Pre-empted threads never resumed by the kernel direcly.<ul><li>Essentially, every new SA is a brand new context.</li><li>For example, if you do blocking I/O, the kernel will provide a new scheduling activagtion and vector into that application space. There isn&rsquo;t a notion of &ldquo;resume&rdquo;. The kernel is simply going to find some new schedule activation to notify you that a work has unblocked. In modern kernels, you would do somehting like stack unwinding to get back into user space.</li></ul></li></ul><p>An important problem is what happened if a user thread is forced to be de-scheduler while it&rsquo;s in a scheduler. The user thread will hold a a lock on user level run queue. That means no other user thread can be scheduled to run because none of them can acquire the lock. Because there&rsquo;s no notion of &ldquo;resume&rdquo; in scheduling activation, we can&rsquo;t really resume the execution in the scheduler. Thus, we run into a deadlock situation.</p><p>One solution is to detect whether we are using a lock and keep executing until we leave the locked region. Of course, there are too many gotchas in this solution.</p><p>Another solution is that the kernel can make a copy of the critical section and execute the critical section itself regardless of what the user thread chooses to do. Therefore, we can guarantee by the time you vector back into user space the lock is no longer held. So the kernel is basically executing the user code! Crazy, right?
Now we ran into more gotchas. What if the code is written in Java? How to find a locked region in userspace? What if &mldr;</p><p>Another thing we want to mention is page fault. Page fault indicates that you are missing part of your address. So there will be a notification with a new scheduler activation. Once you do soemthing with it, you will liekly touch that same piece in the space and double fault again.</p><p>What is the solution?</p></p></section></article><footer class=page-footer><nav class=pagination><a class=next href=https://www.bodunhu.com/blog/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>&copy; 2021 <a href=https://www.bodunhu.com/blog/>std::bodun::blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script>let menu=document.getElementById('menu');menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)},document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>